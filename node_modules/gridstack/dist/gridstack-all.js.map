{"version":3,"file":"gridstack-all.js","mappings":"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","sources":["webpack://GridStack/webpack/universalModuleDefinition","webpack://GridStack/webpack/bootstrap","webpack://GridStack/webpack/runtime/define property getters","webpack://GridStack/webpack/runtime/hasOwnProperty shorthand","webpack://GridStack/./src/utils.ts","webpack://GridStack/./src/gridstack-engine.ts","webpack://GridStack/./src/types.ts","webpack://GridStack/./src/dd-manager.ts","webpack://GridStack/./src/dd-touch.ts","webpack://GridStack/./src/dd-resizable-handle.ts","webpack://GridStack/./src/dd-base-impl.ts","webpack://GridStack/./src/dd-resizable.ts","webpack://GridStack/./src/dd-draggable.ts","webpack://GridStack/./src/dd-droppable.ts","webpack://GridStack/./src/dd-element.ts","webpack://GridStack/./src/gridstack.ts","webpack://GridStack/./src/dd-gridstack.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"GridStack\"] = factory();\n\telse\n\t\troot[\"GridStack\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\r\n * utils.ts 12.3.0\r\n * Copyright (c) 2021-2025 Alain Dumesny - see GridStack root license\r\n */\r\n\r\nimport { GridStackElement, GridStackNode, GridStackOptions, numberOrString, GridStackPosition, GridStackWidget } from './types';\r\n\r\nexport interface HeightData {\r\n  h: number;\r\n  unit: string;\r\n}\r\n\r\nexport interface DragTransform {\r\n  xScale: number;\r\n  yScale: number;\r\n  xOffset: number;\r\n  yOffset: number;\r\n}\r\n\r\n/**\r\n * @internal Checks for obsolete method names and provides deprecation warnings.\r\n * Creates a wrapper function that logs a deprecation warning when called.\r\n * \r\n * @param self the object context to apply the function to\r\n * @param f the new function to call\r\n * @param oldName the deprecated method name\r\n * @param newName the new method name to use instead\r\n * @param rev the version when the deprecation was introduced\r\n * @returns a wrapper function that warns about deprecation\r\n */\r\n// eslint-disable-next-line\r\nexport function obsolete(self, f, oldName: string, newName: string, rev: string): (...args: any[]) => any {\r\n  const wrapper = (...args) => {\r\n    console.warn('gridstack.js: Function `' + oldName + '` is deprecated in ' + rev + ' and has been replaced ' +\r\n    'with `' + newName + '`. It will be **removed** in a future release');\r\n    return f.apply(self, args);\r\n  }\r\n  wrapper.prototype = f.prototype;\r\n  return wrapper;\r\n}\r\n\r\n/**\r\n * @internal Checks for obsolete grid options and migrates them to new names.\r\n * Automatically copies old option values to new option names and shows deprecation warnings.\r\n * \r\n * @param opts the options object to check and migrate\r\n * @param oldName the deprecated option name\r\n * @param newName the new option name to use instead\r\n * @param rev the version when the deprecation was introduced\r\n */\r\nexport function obsoleteOpts(opts: GridStackOptions, oldName: string, newName: string, rev: string): void {\r\n  if (opts[oldName] !== undefined) {\r\n    opts[newName] = opts[oldName];\r\n    console.warn('gridstack.js: Option `' + oldName + '` is deprecated in ' + rev + ' and has been replaced with `' +\r\n      newName + '`. It will be **removed** in a future release');\r\n  }\r\n}\r\n\r\n/**\r\n * @internal Checks for obsolete grid options that have been completely removed.\r\n * Shows deprecation warnings for options that are no longer supported.\r\n * \r\n * @param opts the options object to check\r\n * @param oldName the removed option name\r\n * @param rev the version when the option was removed\r\n * @param info additional information about the removal\r\n */\r\nexport function obsoleteOptsDel(opts: GridStackOptions, oldName: string, rev: string, info: string): void {\r\n  if (opts[oldName] !== undefined) {\r\n    console.warn('gridstack.js: Option `' + oldName + '` is deprecated in ' + rev + info);\r\n  }\r\n}\r\n\r\n/**\r\n * @internal Checks for obsolete HTML element attributes and migrates them.\r\n * Automatically copies old attribute values to new attribute names and shows deprecation warnings.\r\n * \r\n * @param el the HTML element to check and migrate\r\n * @param oldName the deprecated attribute name\r\n * @param newName the new attribute name to use instead\r\n * @param rev the version when the deprecation was introduced\r\n */\r\nexport function obsoleteAttr(el: HTMLElement, oldName: string, newName: string, rev: string): void {\r\n  const oldAttr = el.getAttribute(oldName);\r\n  if (oldAttr !== null) {\r\n    el.setAttribute(newName, oldAttr);\r\n    console.warn('gridstack.js: attribute `' + oldName + '`=' + oldAttr + ' is deprecated on this object in ' + rev + ' and has been replaced with `' +\r\n      newName + '`. It will be **removed** in a future release');\r\n  }\r\n}\r\n\r\n/**\r\n * Collection of utility methods used throughout GridStack.\r\n * These are general-purpose helper functions for DOM manipulation,\r\n * positioning calculations, object operations, and more.\r\n */\r\nexport class Utils {\r\n\r\n  /**\r\n   * Convert a potential selector into an actual list of HTML elements.\r\n   * Supports CSS selectors, element references, and special ID handling.\r\n   * \r\n   * @param els selector string, HTMLElement, or array of elements\r\n   * @param root optional root element to search within (defaults to document, useful for shadow DOM)\r\n   * @returns array of HTML elements matching the selector\r\n   * \r\n   * @example\r\n   * const elements = Utils.getElements('.grid-item');\r\n   * const byId = Utils.getElements('#myWidget');\r\n   * const fromShadow = Utils.getElements('.item', shadowRoot);\r\n   */\r\n  static getElements(els: GridStackElement, root: HTMLElement | Document = document): HTMLElement[] {\r\n    if (typeof els === 'string') {\r\n      const doc = ('getElementById' in root) ? root as Document : undefined;\r\n\r\n      // Note: very common for people use to id='1,2,3' which is only legal as HTML5 id, but not CSS selectors\r\n      // so if we start with a number, assume it's an id and just return that one item...\r\n      // see https://github.com/gridstack/gridstack.js/issues/2234#issuecomment-1523796562\r\n      if (doc && !isNaN(+els[0])) { // start with digit\r\n        const el = doc.getElementById(els);\r\n        return el ? [el] : [];\r\n      }\r\n\r\n      let list = root.querySelectorAll(els);\r\n      if (!list.length && els[0] !== '.' && els[0] !== '#') {\r\n        list = root.querySelectorAll('.' + els);\r\n        if (!list.length) { list = root.querySelectorAll('#' + els) }\r\n      }\r\n      return Array.from(list) as HTMLElement[];\r\n    }\r\n    return [els];\r\n  }\r\n\r\n  /**\r\n   * Convert a potential selector into a single HTML element.\r\n   * Similar to getElements() but returns only the first match.\r\n   * \r\n   * @param els selector string or HTMLElement\r\n   * @param root optional root element to search within (defaults to document)\r\n   * @returns the first HTML element matching the selector, or null if not found\r\n   * \r\n   * @example\r\n   * const element = Utils.getElement('#myWidget');\r\n   * const first = Utils.getElement('.grid-item');\r\n   */\r\n  static getElement(els: GridStackElement, root: HTMLElement | Document = document): HTMLElement {\r\n    if (typeof els === 'string') {\r\n      const doc = ('getElementById' in root) ? root as Document : undefined;\r\n      if (!els.length) return null;\r\n      if (doc && els[0] === '#') {\r\n        return doc.getElementById(els.substring(1));\r\n      }\r\n      if (els[0] === '#' || els[0] === '.' || els[0] === '[') {\r\n        return root.querySelector(els);\r\n      }\r\n\r\n      // if we start with a digit, assume it's an id (error calling querySelector('#1')) as class are not valid CSS\r\n      if (doc && !isNaN(+els[0])) { // start with digit\r\n        return doc.getElementById(els);\r\n      }\r\n\r\n      // finally try string, then id, then class\r\n      let el = root.querySelector(els);\r\n      if (doc && !el) { el = doc.getElementById(els) }\r\n      if (!el) { el = root.querySelector('.' + els) }\r\n      return el as HTMLElement;\r\n    }\r\n    return els;\r\n  }\r\n\r\n  /**\r\n   * Check if a widget should be lazy loaded based on node or grid settings.\r\n   * \r\n   * @param n the grid node to check\r\n   * @returns true if the item should be lazy loaded\r\n   * \r\n   * @example\r\n   * if (Utils.lazyLoad(node)) {\r\n   *   // Set up intersection observer for lazy loading\r\n   * }\r\n   */\r\n  static lazyLoad(n: GridStackNode): boolean {\r\n    return n.lazyLoad || n.grid?.opts?.lazyLoad && n.lazyLoad !== false;\r\n  }\r\n\r\n  /**\r\n   * Create a div element with the specified CSS classes.\r\n   * \r\n   * @param classes array of CSS class names to add\r\n   * @param parent optional parent element to append the div to\r\n   * @returns the created div element\r\n   * \r\n   * @example\r\n   * const div = Utils.createDiv(['grid-item', 'draggable']);\r\n   * const nested = Utils.createDiv(['content'], parentDiv);\r\n   */\r\n  static createDiv(classes: string[], parent?: HTMLElement): HTMLElement {\r\n    const el = document.createElement('div');\r\n    classes.forEach(c => {if (c) el.classList.add(c)});\r\n    parent?.appendChild(el);\r\n    return el;\r\n  }\r\n\r\n  /**\r\n   * Check if a widget should resize to fit its content.\r\n   * \r\n   * @param n the grid node to check (can be undefined)\r\n   * @param strict if true, only returns true for explicit sizeToContent:true (not numbers)\r\n   * @returns true if the widget should resize to content\r\n   * \r\n   * @example\r\n   * if (Utils.shouldSizeToContent(node)) {\r\n   *   // Trigger content-based resizing\r\n   * }\r\n   */\r\n  static shouldSizeToContent(n: GridStackNode | undefined, strict = false): boolean {\r\n    return n?.grid && (strict ?\r\n      (n.sizeToContent === true || (n.grid.opts.sizeToContent === true && n.sizeToContent === undefined)) :\r\n      (!!n.sizeToContent || (n.grid.opts.sizeToContent && n.sizeToContent !== false)));\r\n  }\r\n\r\n  /**\r\n   * Check if two grid positions overlap/intersect.\r\n   * \r\n   * @param a first position with x, y, w, h properties\r\n   * @param b second position with x, y, w, h properties\r\n   * @returns true if the positions overlap\r\n   * \r\n   * @example\r\n   * const overlaps = Utils.isIntercepted(\r\n   *   {x: 0, y: 0, w: 2, h: 1},\r\n   *   {x: 1, y: 0, w: 2, h: 1}\r\n   * ); // true - they overlap\r\n   */\r\n  static isIntercepted(a: GridStackPosition, b: GridStackPosition): boolean {\r\n    return !(a.y >= b.y + b.h || a.y + a.h <= b.y || a.x + a.w <= b.x || a.x >= b.x + b.w);\r\n  }\r\n\r\n  /**\r\n   * Check if two grid positions are touching (edges or corners).\r\n   * \r\n   * @param a first position\r\n   * @param b second position\r\n   * @returns true if the positions are touching\r\n   * \r\n   * @example\r\n   * const touching = Utils.isTouching(\r\n   *   {x: 0, y: 0, w: 2, h: 1},\r\n   *   {x: 2, y: 0, w: 1, h: 1}\r\n   * ); // true - they share an edge\r\n   */\r\n  static isTouching(a: GridStackPosition, b: GridStackPosition): boolean {\r\n    return Utils.isIntercepted(a, {x: b.x-0.5, y: b.y-0.5, w: b.w+1, h: b.h+1})\r\n  }\r\n\r\n  /**\r\n   * Calculate the overlapping area between two grid positions.\r\n   * \r\n   * @param a first position\r\n   * @param b second position\r\n   * @returns the area of overlap (0 if no overlap)\r\n   * \r\n   * @example\r\n   * const overlap = Utils.areaIntercept(\r\n   *   {x: 0, y: 0, w: 3, h: 2},\r\n   *   {x: 1, y: 0, w: 3, h: 2}\r\n   * ); // returns 4 (2x2 overlap)\r\n   */\r\n  static areaIntercept(a: GridStackPosition, b: GridStackPosition): number {\r\n    const x0 = (a.x > b.x) ? a.x : b.x;\r\n    const x1 = (a.x+a.w < b.x+b.w) ? a.x+a.w : b.x+b.w;\r\n    if (x1 <= x0) return 0; // no overlap\r\n    const y0 = (a.y > b.y) ? a.y : b.y;\r\n    const y1 = (a.y+a.h < b.y+b.h) ? a.y+a.h : b.y+b.h;\r\n    if (y1 <= y0) return 0; // no overlap\r\n    return (x1-x0) * (y1-y0);\r\n  }\r\n\r\n  /**\r\n   * Calculate the total area of a grid position.\r\n   * \r\n   * @param a position with width and height\r\n   * @returns the total area (width * height)\r\n   * \r\n   * @example\r\n   * const area = Utils.area({x: 0, y: 0, w: 3, h: 2}); // returns 6\r\n   */\r\n  static area(a: GridStackPosition): number {\r\n    return a.w * a.h;\r\n  }\r\n\r\n  /**\r\n   * Sort an array of grid nodes by position (y first, then x).\r\n   * \r\n   * @param nodes array of nodes to sort\r\n   * @param dir sort direction: 1 for ascending (top-left first), -1 for descending\r\n   * @returns the sorted array (modifies original)\r\n   * \r\n   * @example\r\n   * const sorted = Utils.sort(nodes); // Sort top-left to bottom-right\r\n   * const reverse = Utils.sort(nodes, -1); // Sort bottom-right to top-left\r\n   */\r\n  static sort(nodes: GridStackNode[], dir: 1 | -1 = 1): GridStackNode[] {\r\n    const und = 10000;\r\n    return nodes.sort((a, b) => {\r\n      const diffY = dir * ((a.y ?? und) - (b.y ?? und));\r\n      if (diffY === 0) return dir * ((a.x ?? und) - (b.x ?? und));\r\n      return diffY;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Find a grid node by its ID.\r\n   * \r\n   * @param nodes array of nodes to search\r\n   * @param id the ID to search for\r\n   * @returns the node with matching ID, or undefined if not found\r\n   * \r\n   * @example\r\n   * const node = Utils.find(nodes, 'widget-1');\r\n   * if (node) console.log('Found node at:', node.x, node.y);\r\n   */\r\n  static find(nodes: GridStackNode[], id: string): GridStackNode | undefined {\r\n    return id ? nodes.find(n => n.id === id) : undefined;\r\n  }\r\n\r\n  /**\r\n   * Convert various value types to boolean.\r\n   * Handles strings like 'false', 'no', '0' as false.\r\n   * \r\n   * @param v value to convert\r\n   * @returns boolean representation\r\n   * \r\n   * @example\r\n   * Utils.toBool('true');  // true\r\n   * Utils.toBool('false'); // false\r\n   * Utils.toBool('no');    // false\r\n   * Utils.toBool('1');     // true\r\n   */\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  static toBool(v: unknown): boolean {\r\n    if (typeof v === 'boolean') {\r\n      return v;\r\n    }\r\n    if (typeof v === 'string') {\r\n      v = v.toLowerCase();\r\n      return !(v === '' || v === 'no' || v === 'false' || v === '0');\r\n    }\r\n    return Boolean(v);\r\n  }\r\n\r\n  /**\r\n   * Convert a string value to a number, handling null and empty strings.\r\n   * \r\n   * @param value string or null value to convert\r\n   * @returns number value, or undefined for null/empty strings\r\n   * \r\n   * @example\r\n   * Utils.toNumber('42');  // 42\r\n   * Utils.toNumber('');    // undefined\r\n   * Utils.toNumber(null);  // undefined\r\n   */\r\n  static toNumber(value: null | string): number {\r\n    return (value === null || value.length === 0) ? undefined : Number(value);\r\n  }\r\n\r\n  /**\r\n   * Parse a height value with units into numeric value and unit string.\r\n   * Supports px, em, rem, vh, vw, %, cm, mm units.\r\n   * \r\n   * @param val height value as number or string with units\r\n   * @returns object with h (height) and unit properties\r\n   * \r\n   * @example\r\n   * Utils.parseHeight('100px');  // {h: 100, unit: 'px'}\r\n   * Utils.parseHeight('2rem');   // {h: 2, unit: 'rem'}\r\n   * Utils.parseHeight(50);       // {h: 50, unit: 'px'}\r\n   */\r\n  static parseHeight(val: numberOrString): HeightData {\r\n    let h: number;\r\n    let unit = 'px';\r\n    if (typeof val === 'string') {\r\n      if (val === 'auto' || val === '') h = 0;\r\n      else {\r\n        const match = val.match(/^(-[0-9]+\\.[0-9]+|[0-9]*\\.[0-9]+|-[0-9]+|[0-9]+)(px|em|rem|vh|vw|%|cm|mm)?$/);\r\n        if (!match) {\r\n          throw new Error(`Invalid height val = ${val}`);\r\n        }\r\n        unit = match[2] || 'px';\r\n        h = parseFloat(match[1]);\r\n      }\r\n    } else {\r\n      h = val;\r\n    }\r\n    return { h, unit };\r\n  }\r\n\r\n  /**\r\n   * Copy unset fields from source objects to target object (shallow merge with defaults).\r\n   * Similar to Object.assign but only sets undefined/null fields.\r\n   * \r\n   * @param target the object to copy defaults into\r\n   * @param sources one or more source objects to copy defaults from\r\n   * @returns the modified target object\r\n   * \r\n   * @example\r\n   * const config = { width: 100 };\r\n   * Utils.defaults(config, { width: 200, height: 50 });\r\n   * // config is now { width: 100, height: 50 }\r\n   */\r\n  // eslint-disable-next-line\r\n  static defaults(target, ...sources): {} {\r\n\r\n    sources.forEach(source => {\r\n      for (const key in source) {\r\n        if (!source.hasOwnProperty(key)) return;\r\n        if (target[key] === null || target[key] === undefined) {\r\n          target[key] = source[key];\r\n        } else if (typeof source[key] === 'object' && typeof target[key] === 'object') {\r\n          // property is an object, recursively add it's field over... #1373\r\n          Utils.defaults(target[key], source[key]);\r\n        }\r\n      }\r\n    });\r\n\r\n    return target;\r\n  }\r\n\r\n  /**\r\n   * Compare two objects for equality (shallow comparison).\r\n   * Checks if objects have the same fields and values at one level deep.\r\n   * \r\n   * @param a first object to compare\r\n   * @param b second object to compare\r\n   * @returns true if objects have the same values\r\n   * \r\n   * @example\r\n   * Utils.same({x: 1, y: 2}, {x: 1, y: 2}); // true\r\n   * Utils.same({x: 1}, {x: 1, y: 2}); // false\r\n   */\r\n  static same(a: unknown, b: unknown): boolean {\r\n    if (typeof a !== 'object')  return a == b;\r\n    if (typeof a !== typeof b) return false;\r\n    // else we have object, check just 1 level deep for being same things...\r\n    if (Object.keys(a).length !== Object.keys(b).length) return false;\r\n    for (const key in a) {\r\n      if (a[key] !== b[key]) return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Copy position and size properties from one widget to another.\r\n   * Copies x, y, w, h and optionally min/max constraints.\r\n   * \r\n   * @param a target widget to copy to\r\n   * @param b source widget to copy from\r\n   * @param doMinMax if true, also copy min/max width/height constraints\r\n   * @returns the target widget (a)\r\n   * \r\n   * @example\r\n   * Utils.copyPos(widget1, widget2); // Copy position/size\r\n   * Utils.copyPos(widget1, widget2, true); // Also copy constraints\r\n   */\r\n  static copyPos(a: GridStackWidget, b: GridStackWidget, doMinMax = false): GridStackWidget {\r\n    if (b.x !== undefined) a.x = b.x;\r\n    if (b.y !== undefined) a.y = b.y;\r\n    if (b.w !== undefined) a.w = b.w;\r\n    if (b.h !== undefined) a.h = b.h;\r\n    if (doMinMax) {\r\n      if (b.minW) a.minW = b.minW;\r\n      if (b.minH) a.minH = b.minH;\r\n      if (b.maxW) a.maxW = b.maxW;\r\n      if (b.maxH) a.maxH = b.maxH;\r\n    }\r\n    return a;\r\n  }\r\n\r\n  /** true if a and b has same size & position */\r\n  static samePos(a: GridStackPosition, b: GridStackPosition): boolean {\r\n    return a && b && a.x === b.x && a.y === b.y && (a.w || 1) === (b.w || 1) && (a.h || 1) === (b.h || 1);\r\n  }\r\n\r\n  /** given a node, makes sure it's min/max are valid */\r\n  static sanitizeMinMax(node: GridStackNode) {\r\n    // remove 0, undefine, null\r\n    if (!node.minW) { delete node.minW; }\r\n    if (!node.minH) { delete node.minH; }\r\n    if (!node.maxW) { delete node.maxW; }\r\n    if (!node.maxH) { delete node.maxH; }\r\n  }\r\n\r\n  /** removes field from the first object if same as the second objects (like diffing) and internal '_' for saving */\r\n  static removeInternalAndSame(a: unknown, b: unknown):void {\r\n    if (typeof a !== 'object' || typeof b !== 'object') return;\r\n    for (let key in a) {\r\n      const aVal = a[key];\r\n      const bVal = b[key];\r\n      if (key[0] === '_' || aVal === bVal) {\r\n        delete a[key]\r\n      } else if (aVal && typeof aVal === 'object' && bVal !== undefined) {\r\n        Utils.removeInternalAndSame(aVal, bVal);\r\n        if (!Object.keys(aVal).length) { delete a[key] }\r\n      }\r\n    }\r\n  }\r\n\r\n  /** removes internal fields '_' and default values for saving */\r\n  static removeInternalForSave(n: GridStackNode, removeEl = true): void {\r\n    for (let key in n) { if (key[0] === '_' || n[key] === null || n[key] === undefined ) delete n[key]; }\r\n    delete n.grid;\r\n    if (removeEl) delete n.el;\r\n    // delete default values (will be re-created on read)\r\n    if (!n.autoPosition) delete n.autoPosition;\r\n    if (!n.noResize) delete n.noResize;\r\n    if (!n.noMove) delete n.noMove;\r\n    if (!n.locked) delete n.locked;\r\n    if (n.w === 1 || n.w === n.minW) delete n.w;\r\n    if (n.h === 1 || n.h === n.minH) delete n.h;\r\n  }\r\n\r\n  /** return the closest parent (or itself) matching the given class */\r\n  // static closestUpByClass(el: HTMLElement, name: string): HTMLElement {\r\n  //   while (el) {\r\n  //     if (el.classList.contains(name)) return el;\r\n  //     el = el.parentElement\r\n  //   }\r\n  //   return null;\r\n  // }\r\n\r\n  /** delay calling the given function for given delay, preventing new calls from happening while waiting */\r\n  static throttle(func: () => void, delay: number): () => void {\r\n    let isWaiting = false;\r\n    return (...args) => {\r\n      if (!isWaiting) {\r\n        isWaiting = true;\r\n        setTimeout(() => { func(...args); isWaiting = false; }, delay);\r\n      }\r\n    }\r\n  }\r\n\r\n  static removePositioningStyles(el: HTMLElement): void {\r\n    const style = el.style;\r\n    if (style.position) {\r\n      style.removeProperty('position');\r\n    }\r\n    if (style.left) {\r\n      style.removeProperty('left');\r\n    }\r\n    if (style.top) {\r\n      style.removeProperty('top');\r\n    }\r\n    if (style.width) {\r\n      style.removeProperty('width');\r\n    }\r\n    if (style.height) {\r\n      style.removeProperty('height');\r\n    }\r\n  }\r\n\r\n  /** @internal returns the passed element if scrollable, else the closest parent that will, up to the entire document scrolling element */\r\n  static getScrollElement(el?: HTMLElement): HTMLElement {\r\n    if (!el) return document.scrollingElement as HTMLElement || document.documentElement; // IE support\r\n    const style = getComputedStyle(el);\r\n    const overflowRegex = /(auto|scroll)/;\r\n\r\n    if (overflowRegex.test(style.overflow + style.overflowY)) {\r\n      return el;\r\n    } else {\r\n      return Utils.getScrollElement(el.parentElement);\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  static updateScrollPosition(el: HTMLElement, position: {top: number}, distance: number): void {\r\n    const scrollEl = Utils.getScrollElement(el);\r\n    if (!scrollEl) return;\r\n\r\n    const elRect = el.getBoundingClientRect();\r\n    const scrollRect = scrollEl.getBoundingClientRect();\r\n    const innerHeightOrClientHeight = (window.innerHeight || document.documentElement.clientHeight);\r\n\r\n    const offsetDiffDown = elRect.bottom - Math.min(scrollRect.bottom, innerHeightOrClientHeight);\r\n    const offsetDiffUp = elRect.top - Math.max(scrollRect.top, 0);\r\n    const prevScroll = scrollEl.scrollTop;\r\n\r\n    if (offsetDiffUp < 0 && distance < 0) {\r\n      // scroll up\r\n      if (el.offsetHeight > scrollRect.height) {\r\n        scrollEl.scrollTop += distance;\r\n      } else {\r\n        scrollEl.scrollTop += Math.abs(offsetDiffUp) > Math.abs(distance) ? distance : offsetDiffUp;\r\n      }\r\n    } else if (offsetDiffDown > 0 && distance > 0) {\r\n      // scroll down\r\n      if (el.offsetHeight > scrollRect.height) {\r\n        scrollEl.scrollTop += distance;\r\n      } else {\r\n        scrollEl.scrollTop += offsetDiffDown > distance ? distance : offsetDiffDown;\r\n      }\r\n    }\r\n\r\n    position.top += scrollEl.scrollTop - prevScroll;\r\n  }\r\n\r\n  /**\r\n   * @internal Function used to scroll the page.\r\n   *\r\n   * @param event `MouseEvent` that triggers the resize\r\n   * @param el `HTMLElement` that's being resized\r\n   * @param distance Distance from the V edges to start scrolling\r\n   */\r\n  static updateScrollResize(event: MouseEvent, el: HTMLElement, distance: number): void {\r\n    const scrollEl = Utils.getScrollElement(el);\r\n    const height = scrollEl.clientHeight;\r\n    // #1727 event.clientY is relative to viewport, so must compare this against position of scrollEl getBoundingClientRect().top\r\n    // #1745 Special situation if scrollEl is document 'html': here browser spec states that\r\n    // clientHeight is height of viewport, but getBoundingClientRect() is rectangle of html element;\r\n    // this discrepancy arises because in reality scrollbar is attached to viewport, not html element itself.\r\n    const offsetTop = (scrollEl === Utils.getScrollElement()) ? 0 : scrollEl.getBoundingClientRect().top;\r\n    const pointerPosY = event.clientY - offsetTop;\r\n    const top = pointerPosY < distance;\r\n    const bottom = pointerPosY > height - distance;\r\n\r\n    if (top) {\r\n      // This also can be done with a timeout to keep scrolling while the mouse is\r\n      // in the scrolling zone. (will have smoother behavior)\r\n      scrollEl.scrollBy({ behavior: 'smooth', top: pointerPosY - distance});\r\n    } else if (bottom) {\r\n      scrollEl.scrollBy({ behavior: 'smooth', top: distance - (height - pointerPosY)});\r\n    }\r\n  }\r\n\r\n  /** single level clone, returning a new object with same top fields. This will share sub objects and arrays */\r\n  static clone<T>(obj: T): T {\r\n    if (obj === null || obj === undefined || typeof(obj) !== 'object') {\r\n      return obj;\r\n    }\r\n    // return Object.assign({}, obj);\r\n    if (obj instanceof Array) {\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      return [...obj] as any;\r\n    }\r\n    return {...obj};\r\n  }\r\n\r\n  /**\r\n   * Recursive clone version that returns a full copy, checking for nested objects and arrays ONLY.\r\n   * Note: this will use as-is any key starting with double __ (and not copy inside) some lib have circular dependencies.\r\n   */\r\n  static cloneDeep<T>(obj: T): T {\r\n    // list of fields we will skip during cloneDeep (nested objects, other internal)\r\n    const skipFields = ['parentGrid', 'el', 'grid', 'subGrid', 'engine'];\r\n    // return JSON.parse(JSON.stringify(obj)); // doesn't work with date format ?\r\n    const ret = Utils.clone(obj);\r\n    for (const key in ret) {\r\n      // NOTE: we don't support function/circular dependencies so skip those properties for now...\r\n      if (ret.hasOwnProperty(key) && typeof(ret[key]) === 'object' && key.substring(0, 2) !== '__' && !skipFields.find(k => k === key)) {\r\n        ret[key] = Utils.cloneDeep(obj[key]);\r\n      }\r\n    }\r\n    return ret;\r\n  }\r\n\r\n  /** deep clone the given HTML node, removing teh unique id field */\r\n  public static cloneNode(el: HTMLElement): HTMLElement {\r\n    const node = el.cloneNode(true) as HTMLElement;\r\n    node.removeAttribute('id');\r\n    return node;\r\n  }\r\n\r\n  public static appendTo(el: HTMLElement, parent: string | HTMLElement): void {\r\n    let parentNode: HTMLElement;\r\n    if (typeof parent === 'string') {\r\n      parentNode = Utils.getElement(parent);\r\n    } else {\r\n      parentNode = parent;\r\n    }\r\n    if (parentNode) {\r\n      parentNode.appendChild(el);\r\n    }\r\n  }\r\n\r\n  // public static setPositionRelative(el: HTMLElement): void {\r\n  //   if (!(/^(?:r|a|f)/).test(getComputedStyle(el).position)) {\r\n  //     el.style.position = \"relative\";\r\n  //   }\r\n  // }\r\n\r\n  public static addElStyles(el: HTMLElement, styles: { [prop: string]: string | string[] }): void {\r\n    if (styles instanceof Object) {\r\n      for (const s in styles) {\r\n        if (styles.hasOwnProperty(s)) {\r\n          if (Array.isArray(styles[s])) {\r\n            // support fallback value\r\n            (styles[s] as string[]).forEach(val => {\r\n              el.style[s] = val;\r\n            });\r\n          } else {\r\n            el.style[s] = styles[s];\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public static initEvent<T>(e: DragEvent | MouseEvent, info: { type: string; target?: EventTarget }): T {\r\n    const evt = { type: info.type };\r\n    const obj = {\r\n      button: 0,\r\n      which: 0,\r\n      buttons: 1,\r\n      bubbles: true,\r\n      cancelable: true,\r\n      target: info.target ? info.target : e.target\r\n    };\r\n    ['altKey','ctrlKey','metaKey','shiftKey'].forEach(p => evt[p] = e[p]); // keys\r\n    ['pageX','pageY','clientX','clientY','screenX','screenY'].forEach(p => evt[p] = e[p]); // point info\r\n    return {...evt, ...obj} as unknown as T;\r\n  }\r\n\r\n  /** copies the MouseEvent (or convert Touch) properties and sends it as another event to the given target */\r\n  public static simulateMouseEvent(e: MouseEvent | Touch, simulatedType: string, target?: EventTarget): void {\r\n    const me = e as MouseEvent;\r\n    const simulatedEvent = new MouseEvent(simulatedType, {\r\n      bubbles: true,\r\n      composed: true,\r\n      cancelable: true,\r\n      view: window,\r\n      detail: 1,\r\n      screenX: e.screenX,\r\n      screenY: e.screenY,\r\n      clientX: e.clientX,\r\n      clientY: e.clientY,\r\n      ctrlKey: me.ctrlKey??false,\r\n      altKey: me.altKey??false,\r\n      shiftKey: me.shiftKey??false,\r\n      metaKey: me.metaKey??false,\r\n      button: 0,\r\n      relatedTarget: e.target\r\n    });\r\n\r\n    (target || e.target).dispatchEvent(simulatedEvent);\r\n  }\r\n\r\n  /**\r\n   * defines an element that is used to get the offset and scale from grid transforms\r\n   * returns the scale and offsets from said element\r\n  */\r\n  public static getValuesFromTransformedElement(parent: HTMLElement): DragTransform {\r\n    const transformReference = document.createElement('div');\r\n    Utils.addElStyles(transformReference, {\r\n      opacity: '0',\r\n      position: 'fixed',\r\n      top: 0 + 'px',\r\n      left: 0 + 'px',\r\n      width: '1px',\r\n      height: '1px',\r\n      zIndex: '-999999',\r\n    });\r\n    parent.appendChild(transformReference);\r\n    const transformValues = transformReference.getBoundingClientRect();\r\n    parent.removeChild(transformReference);\r\n    transformReference.remove();\r\n    return {\r\n      xScale: 1 / transformValues.width,\r\n      yScale: 1 / transformValues.height,\r\n      xOffset: transformValues.left,\r\n      yOffset: transformValues.top,\r\n    }\r\n  }\r\n\r\n  /** swap the given object 2 field values */\r\n  public static swap(o: unknown, a: string, b: string): void {\r\n    if (!o) return;\r\n    const tmp = o[a]; o[a] = o[b]; o[b] = tmp;\r\n  }\r\n\r\n  /** returns true if event is inside the given element rectangle */\r\n  // Note: Safari Mac has null event.relatedTarget which causes #1684 so check if DragEvent is inside the coordinates instead\r\n  //    Utils.el.contains(event.relatedTarget as HTMLElement)\r\n  // public static inside(e: MouseEvent, el: HTMLElement): boolean {\r\n  //   // srcElement, toElement, target: all set to placeholder when leaving simple grid, so we can't use that (Chrome)\r\n  //   const target: HTMLElement = e.relatedTarget || (e as any).fromElement;\r\n  //   if (!target) {\r\n  //     const { bottom, left, right, top } = el.getBoundingClientRect();\r\n  //     return (e.x < right && e.x > left && e.y < bottom && e.y > top);\r\n  //   }\r\n  //   return el.contains(target);\r\n  // }\r\n\r\n  /** true if the item can be rotated (checking for prop, not space available) */\r\n  public static canBeRotated(n: GridStackNode): boolean {\r\n    return !(!n || n.w === n.h || n.locked || n.noResize || n.grid?.opts.disableResize || (n.minW && n.minW === n.maxW) || (n.minH && n.minH === n.maxH));\r\n  }\r\n}","/**\n * gridstack-engine.ts 12.3.0\n * Copyright (c) 2021-2025  Alain Dumesny - see GridStack root license\n */\n\nimport { Utils } from './utils';\nimport { GridStackNode, ColumnOptions, GridStackPosition, GridStackMoveOpts, SaveFcn, CompactOptions } from './types';\n\n/** callback to update the DOM attributes since this class is generic (no HTML or other info) for items that changed - see _notify() */\ntype OnChangeCB = (nodes: GridStackNode[]) => void;\n\n/** options used during creation - similar to GridStackOptions */\nexport interface GridStackEngineOptions {\n  column?: number;\n  maxRow?: number;\n  float?: boolean;\n  nodes?: GridStackNode[];\n  onChange?: OnChangeCB;\n}\n\n/**\n * Defines the GridStack engine that handles all grid layout calculations and node positioning.\n * This is the core engine that performs grid manipulation without any DOM operations.\n * \n * The engine manages:\n * - Node positioning and collision detection\n * - Layout algorithms (compact, float, etc.)\n * - Grid resizing and column changes\n * - Widget movement and resizing logic\n * \n * NOTE: Values should not be modified directly - use the main GridStack API instead\n * to ensure proper DOM updates and event triggers.\n */\nexport class GridStackEngine {\n  public column: number;\n  public maxRow: number;\n  public nodes: GridStackNode[];\n  public addedNodes: GridStackNode[] = [];\n  public removedNodes: GridStackNode[] = [];\n  public batchMode: boolean;\n  public defaultColumn = 12;\n  /** @internal callback to update the DOM attributes */\n  protected onChange: OnChangeCB;\n  /** @internal */\n  protected _float: boolean;\n  /** @internal */\n  protected _prevFloat: boolean;\n  /** @internal cached layouts of difference column count so we can restore back (eg 12 -> 1 -> 12) */\n  protected _layouts?: GridStackNode[][]; // maps column # to array of values nodes\n  /** @internal set during loading (which is sorted) so item gets added AFTER collision nodes */\n  public _loading?: boolean\n  /** @internal true while we are resizing widgets during column resize to skip certain parts */\n  protected _inColumnResize?: boolean;\n  /** true when grid.load() already cached the layout and can skip out of bound caching info */\n  public skipCacheUpdate?: boolean;\n  /** @internal true if we have some items locked */\n  protected _hasLocked: boolean;\n  /** @internal unique global internal _id counter */\n  public static _idSeq = 0;\n\n  public constructor(opts: GridStackEngineOptions = {}) {\n    this.column = opts.column || this.defaultColumn;\n    if (this.column > this.defaultColumn) this.defaultColumn = this.column;\n    this.maxRow = opts.maxRow;\n    this._float = opts.float;\n    this.nodes = opts.nodes || [];\n    this.onChange = opts.onChange;\n  }\n\n  /**\n   * Enable/disable batch mode for multiple operations to optimize performance.\n   * When enabled, layout updates are deferred until batch mode is disabled.\n   * \n   * @param flag true to enable batch mode, false to disable and apply changes\n   * @param doPack if true (default), pack/compact nodes when disabling batch mode\n   * @returns the engine instance for chaining\n   * \n   * @example\n   * // Start batch mode for multiple operations\n   * engine.batchUpdate(true);\n   * engine.addNode(node1);\n   * engine.addNode(node2);\n   * engine.batchUpdate(false); // Apply all changes at once\n   */\n  public batchUpdate(flag = true, doPack = true): GridStackEngine {\n    if (!!this.batchMode === flag) return this;\n    this.batchMode = flag;\n    if (flag) {\n      this._prevFloat = this._float;\n      this._float = true; // let things go anywhere for now... will restore and possibly reposition later\n      this.cleanNodes();\n      this.saveInitial(); // since begin update (which is called multiple times) won't do this\n    } else {\n      this._float = this._prevFloat;\n      delete this._prevFloat;\n      if (doPack) this._packNodes();\n      this._notify();\n    }\n    return this;\n  }\n\n  // use entire row for hitting area (will use bottom reverse sorted first) if we not actively moving DOWN and didn't already skip\n  protected _useEntireRowArea(node: GridStackNode, nn: GridStackPosition): boolean {\n    return (!this.float || this.batchMode && !this._prevFloat) && !this._hasLocked && (!node._moving || node._skipDown || nn.y <= node.y);\n  }\n\n  /** @internal fix collision on given 'node', going to given new location 'nn', with optional 'collide' node already found.\n   * return true if we moved. */\n  protected _fixCollisions(node: GridStackNode, nn = node, collide?: GridStackNode, opt: GridStackMoveOpts = {}): boolean {\n    this.sortNodes(-1); // from last to first, so recursive collision move items in the right order\n\n    collide = collide || this.collide(node, nn); // REAL area collide for swap and skip if none...\n    if (!collide) return false;\n\n    // swap check: if we're actively moving in gravity mode, see if we collide with an object the same size\n    if (node._moving && !opt.nested && !this.float) {\n      if (this.swap(node, collide)) return true;\n    }\n\n    // during while() collisions MAKE SURE to check entire row so larger items don't leap frog small ones (push them all down starting last in grid)\n    let area = nn;\n    if (!this._loading && this._useEntireRowArea(node, nn)) {\n      area = {x: 0, w: this.column, y: nn.y, h: nn.h};\n      collide = this.collide(node, area, opt.skip); // force new hit\n    }\n\n    let didMove = false;\n    const newOpt: GridStackMoveOpts = {nested: true, pack: false};\n    let counter = 0;\n    while (collide = collide || this.collide(node, area, opt.skip)) { // could collide with more than 1 item... so repeat for each\n      if (counter++ > this.nodes.length * 2) {\n        throw new Error(\"Infinite collide check\");\n      }\n      let moved: boolean;\n      // if colliding with a locked item OR loading (move after) OR moving down with top gravity (and collide could move up) -> skip past the collide,\n      // but remember that skip down so we only do this once (and push others otherwise).\n      if (collide.locked || this._loading || node._moving && !node._skipDown && nn.y > node.y && !this.float &&\n        // can take space we had, or before where we're going\n        (!this.collide(collide, {...collide, y: node.y}, node) || !this.collide(collide, {...collide, y: nn.y - collide.h}, node))) {\n\n        node._skipDown = (node._skipDown || nn.y > node.y);\n        const newNN = {...nn, y: collide.y + collide.h, ...newOpt};\n        // pretent we moved to where we are now so we can continue any collision checks #2492\n        moved = this._loading && Utils.samePos(node, newNN) ? true : this.moveNode(node, newNN);\n\n        if ((collide.locked || this._loading) && moved) {\n          Utils.copyPos(nn, node); // moving after lock become our new desired location\n        } else if (!collide.locked && moved && opt.pack) {\n          // we moved after and will pack: do it now and keep the original drop location, but past the old collide to see what else we might push way\n          this._packNodes();\n          nn.y = collide.y + collide.h;\n          Utils.copyPos(node, nn);\n        }\n        didMove = didMove || moved;\n      } else {\n        // move collide down *after* where we will be, ignoring where we are now (don't collide with us)\n        moved = this.moveNode(collide, {...collide, y: nn.y + nn.h, skip: node, ...newOpt});\n      }\n\n      if (!moved) return didMove; // break inf loop if we couldn't move after all (ex: maxRow, fixed)\n\n      collide = undefined;\n    }\n    return didMove;\n  }\n\n  /**\n   * Return the first node that intercepts/collides with the given node or area.\n   * Used for collision detection during drag and drop operations.\n   * \n   * @param skip the node to skip in collision detection (usually the node being moved)\n   * @param area the area to check for collisions (defaults to skip node's area)\n   * @param skip2 optional second node to skip in collision detection\n   * @returns the first colliding node, or undefined if no collision\n   * \n   * @example\n   * const colliding = engine.collide(draggedNode, {x: 2, y: 1, w: 2, h: 1});\n   * if (colliding) {\n   *   console.log('Would collide with:', colliding.id);\n   * }\n   */\n  public collide(skip: GridStackNode, area = skip, skip2?: GridStackNode): GridStackNode | undefined {\n    const skipId = skip._id;\n    const skip2Id = skip2?._id;\n    return this.nodes.find(n => n._id !== skipId && n._id !== skip2Id && Utils.isIntercepted(n, area));\n  }\n  /**\n   * Return all nodes that intercept/collide with the given node or area.\n   * Similar to collide() but returns all colliding nodes instead of just the first.\n   * \n   * @param skip the node to skip in collision detection\n   * @param area the area to check for collisions (defaults to skip node's area)\n   * @param skip2 optional second node to skip in collision detection\n   * @returns array of all colliding nodes\n   * \n   * @example\n   * const allCollisions = engine.collideAll(draggedNode);\n   * console.log('Colliding with', allCollisions.length, 'nodes');\n   */\n  public collideAll(skip: GridStackNode, area = skip, skip2?: GridStackNode): GridStackNode[] {\n    const skipId = skip._id;\n    const skip2Id = skip2?._id;\n    return this.nodes.filter(n => n._id !== skipId && n._id !== skip2Id && Utils.isIntercepted(n, area));\n  }\n\n  /** does a pixel coverage collision based on where we started, returning the node that has the most coverage that is >50% mid line */\n  protected directionCollideCoverage(node: GridStackNode, o: GridStackMoveOpts, collides: GridStackNode[]): GridStackNode | undefined {\n    if (!o.rect || !node._rect) return;\n    const r0 = node._rect; // where started\n    const r = {...o.rect}; // where we are\n\n    // update dragged rect to show where it's coming from (above or below, etc...)\n    if (r.y > r0.y) {\n      r.h += r.y - r0.y;\n      r.y = r0.y;\n    } else {\n      r.h += r0.y - r.y;\n    }\n    if (r.x > r0.x) {\n      r.w += r.x - r0.x;\n      r.x = r0.x;\n    } else {\n      r.w += r0.x - r.x;\n    }\n\n    let collide: GridStackNode;\n    let overMax = 0.5; // need >50%\n    for (let n of collides) {\n      if (n.locked || !n._rect) {\n        break;\n      }\n      const r2 = n._rect; // overlapping target\n      let yOver = Number.MAX_VALUE, xOver = Number.MAX_VALUE;\n      // depending on which side we started from, compute the overlap % of coverage\n      // (ex: from above/below we only compute the max horizontal line coverage)\n      if (r0.y < r2.y) { // from above\n        yOver = ((r.y + r.h) - r2.y) / r2.h;\n      } else if (r0.y + r0.h > r2.y + r2.h) { // from below\n        yOver = ((r2.y + r2.h) - r.y) / r2.h;\n      }\n      if (r0.x < r2.x) { // from the left\n        xOver = ((r.x + r.w) - r2.x) / r2.w;\n      } else if (r0.x + r0.w > r2.x + r2.w) { // from the right\n        xOver = ((r2.x + r2.w) - r.x) / r2.w;\n      }\n      const over = Math.min(xOver, yOver);\n      if (over > overMax) {\n        overMax = over;\n        collide = n;\n      }\n    }\n    o.collide = collide; // save it so we don't have to find it again\n    return collide;\n  }\n\n  /** does a pixel coverage returning the node that has the most coverage by area */\n  /*\n  protected collideCoverage(r: GridStackPosition, collides: GridStackNode[]): {collide: GridStackNode, over: number} {\n    const collide: GridStackNode;\n    const overMax = 0;\n    collides.forEach(n => {\n      if (n.locked || !n._rect) return;\n      const over = Utils.areaIntercept(r, n._rect);\n      if (over > overMax) {\n        overMax = over;\n        collide = n;\n      }\n    });\n    return {collide, over: overMax};\n  }\n  */\n\n  /**\n   * Cache the pixel rectangles for all nodes used for collision detection during drag operations.\n   * This optimization converts grid coordinates to pixel coordinates for faster collision detection.\n   * \n   * @param w width of a single grid cell in pixels\n   * @param h height of a single grid cell in pixels\n   * @param top top margin/padding in pixels\n   * @param right right margin/padding in pixels\n   * @param bottom bottom margin/padding in pixels\n   * @param left left margin/padding in pixels\n   * @returns the engine instance for chaining\n   * \n   * @internal This is typically called by GridStack during resize events\n   */\n  public cacheRects(w: number, h: number, top: number, right: number, bottom: number, left: number): GridStackEngine\n  {\n    this.nodes.forEach(n =>\n      n._rect = {\n        y: n.y * h + top,\n        x: n.x * w + left,\n        w: n.w * w - left - right,\n        h: n.h * h - top - bottom\n      }\n    );\n    return this;\n  }\n\n  /**\n   * Attempt to swap the positions of two nodes if they meet swapping criteria.\n   * Nodes can swap if they are the same size or in the same column/row, not locked, and touching.\n   * \n   * @param a first node to swap\n   * @param b second node to swap\n   * @returns true if swap was successful, false if not possible, undefined if not applicable\n   * \n   * @example\n   * const swapped = engine.swap(nodeA, nodeB);\n   * if (swapped) {\n   *   console.log('Nodes swapped successfully');\n   * }\n   */\n  public swap(a: GridStackNode, b: GridStackNode): boolean | undefined {\n    if (!b || b.locked || !a || a.locked) return false;\n\n    function _doSwap(): true { // assumes a is before b IFF they have different height (put after rather than exact swap)\n      const x = b.x, y = b.y;\n      b.x = a.x; b.y = a.y; // b -> a position\n      if (a.h != b.h) {\n        a.x = x; a.y = b.y + b.h; // a -> goes after b\n      } else if (a.w != b.w) {\n        a.x = b.x + b.w; a.y = y; // a -> goes after b\n      } else {\n        a.x = x; a.y = y; // a -> old b position\n      }\n      a._dirty = b._dirty = true;\n      return true;\n    }\n    let touching: boolean; // remember if we called it (vs undefined)\n\n    // same size and same row or column, and touching\n    if (a.w === b.w && a.h === b.h && (a.x === b.x || a.y === b.y) && (touching = Utils.isTouching(a, b)))\n      return _doSwap();\n    if (touching === false) return; // IFF ran test and fail, bail out\n\n    // check for taking same columns (but different height) and touching\n    if (a.w === b.w && a.x === b.x && (touching || (touching = Utils.isTouching(a, b)))) {\n      if (b.y < a.y) { const t = a; a = b; b = t; } // swap a <-> b vars so a is first\n      return _doSwap();\n    }\n    if (touching === false) return;\n\n    // check if taking same row (but different width) and touching\n    if (a.h === b.h && a.y === b.y && (touching || (touching = Utils.isTouching(a, b)))) {\n      if (b.x < a.x) { const t = a; a = b; b = t; } // swap a <-> b vars so a is first\n      return _doSwap();\n    }\n    return false;\n  }\n\n  /**\n   * Check if the specified rectangular area is empty (no nodes occupy any part of it).\n   * \n   * @param x the x coordinate (column) of the area to check\n   * @param y the y coordinate (row) of the area to check\n   * @param w the width in columns of the area to check\n   * @param h the height in rows of the area to check\n   * @returns true if the area is completely empty, false if any node overlaps\n   * \n   * @example\n   * if (engine.isAreaEmpty(2, 1, 3, 2)) {\n   *   console.log('Area is available for placement');\n   * }\n   */\n  public isAreaEmpty(x: number, y: number, w: number, h: number): boolean {\n    const nn: GridStackNode = {x: x || 0, y: y || 0, w: w || 1, h: h || 1};\n    return !this.collide(nn);\n  }\n\n  /**\n   * Re-layout grid items to reclaim any empty space.\n   * This optimizes the grid layout by moving items to fill gaps.\n   * \n   * @param layout layout algorithm to use:\n   *   - 'compact' (default): find truly empty spaces, may reorder items\n   *   - 'list': keep the sort order exactly the same, move items up sequentially\n   * @param doSort if true (default), sort nodes by position before compacting\n   * @returns the engine instance for chaining\n   * \n   * @example\n   * // Compact to fill empty spaces\n   * engine.compact();\n   * \n   * // Compact preserving item order\n   * engine.compact('list');\n   */\n  public compact(layout: CompactOptions = 'compact', doSort = true): GridStackEngine {\n    if (this.nodes.length === 0) return this;\n    if (doSort) this.sortNodes();\n    const wasBatch = this.batchMode;\n    if (!wasBatch) this.batchUpdate();\n    const wasColumnResize = this._inColumnResize;\n    if (!wasColumnResize) this._inColumnResize = true; // faster addNode()\n    const copyNodes = this.nodes;\n    this.nodes = []; // pretend we have no nodes to conflict layout to start with...\n    copyNodes.forEach((n, index, list) => {\n      let after: GridStackNode;\n      if (!n.locked) {\n        n.autoPosition = true;\n        if (layout === 'list' && index) after = list[index - 1];\n      }\n      this.addNode(n, false, after); // 'false' for add event trigger\n    });\n    if (!wasColumnResize) delete this._inColumnResize;\n    if (!wasBatch) this.batchUpdate(false);\n    return this;\n  }\n\n  /**\n   * Enable/disable floating widgets (default: `false`).\n   * When floating is enabled, widgets can move up to fill empty spaces.\n   * See [example](http://gridstackjs.com/demo/float.html)\n   * \n   * @param val true to enable floating, false to disable\n   * \n   * @example\n   * engine.float = true;  // Enable floating\n   * engine.float = false; // Disable floating (default)\n   */\n  public set float(val: boolean) {\n    if (this._float === val) return;\n    this._float = val || false;\n    if (!val) {\n      this._packNodes()._notify();\n    }\n  }\n\n  /**\n   * Get the current floating mode setting.\n   * \n   * @returns true if floating is enabled, false otherwise\n   * \n   * @example\n   * const isFloating = engine.float;\n   * console.log('Floating enabled:', isFloating);\n   */\n  public get float(): boolean { return this._float || false; }\n\n  /**\n   * Sort the nodes array from first to last, or reverse.\n   * This is called during collision/placement operations to enforce a specific order.\n   * \n   * @param dir sort direction: 1 for ascending (first to last), -1 for descending (last to first)\n   * @returns the engine instance for chaining\n   * \n   * @example\n   * engine.sortNodes();    // Sort ascending (default)\n   * engine.sortNodes(-1);  // Sort descending\n   */\n  public sortNodes(dir: 1 | -1 = 1): GridStackEngine {\n    this.nodes = Utils.sort(this.nodes, dir);\n    return this;\n  }\n\n  /** @internal called to top gravity pack the items back OR revert back to original Y positions when floating */\n  protected _packNodes(): GridStackEngine {\n    if (this.batchMode) { return this; }\n    this.sortNodes(); // first to last\n\n    if (this.float) {\n      // restore original Y pos\n      this.nodes.forEach(n => {\n        if (n._updating || n._orig === undefined || n.y === n._orig.y) return;\n        let newY = n.y;\n        while (newY > n._orig.y) {\n          --newY;\n          const collide = this.collide(n, {x: n.x, y: newY, w: n.w, h: n.h});\n          if (!collide) {\n            n._dirty = true;\n            n.y = newY;\n          }\n        }\n      });\n    } else {\n      // top gravity pack\n      this.nodes.forEach((n, i) => {\n        if (n.locked) return;\n        while (n.y > 0) {\n          const newY = i === 0 ? 0 : n.y - 1;\n          const canBeMoved = i === 0 || !this.collide(n, {x: n.x, y: newY, w: n.w, h: n.h});\n          if (!canBeMoved) break;\n          // Note: must be dirty (from last position) for GridStack::OnChange CB to update positions\n          // and move items back. The user 'change' CB should detect changes from the original\n          // starting position instead.\n          n._dirty = (n.y !== newY);\n          n.y = newY;\n        }\n      });\n    }\n    return this;\n  }\n\n  /**\n   * Prepare and validate a node's coordinates and values for the current grid.\n   * This ensures the node has valid position, size, and properties before being added to the grid.\n   * \n   * @param node the node to prepare and validate\n   * @param resizing if true, resize the node down if it's out of bounds; if false, move it to fit\n   * @returns the prepared node with valid coordinates\n   * \n   * @example\n   * const node = { w: 3, h: 2, content: 'Hello' };\n   * const prepared = engine.prepareNode(node);\n   * console.log('Node prepared at:', prepared.x, prepared.y);\n   */\n  public prepareNode(node: GridStackNode, resizing?: boolean): GridStackNode {\n    node._id = node._id ?? GridStackEngine._idSeq++;\n\n    // make sure USER supplied id are unique in our list, else assign a new one as it will create issues during load/update/etc...\n    const id = node.id;\n    if (id) {\n      let count = 1; // append nice _n rather than some random number\n      while (this.nodes.find(n => n.id === node.id && n !== node)) {\n        node.id = id + '_' + (count++);\n      }\n    }\n\n    // if we're missing position, have the grid position us automatically (before we set them to 0,0)\n    if (node.x === undefined || node.y === undefined || node.x === null || node.y === null) {\n      node.autoPosition = true;\n    }\n\n    // assign defaults for missing required fields\n    const defaults: GridStackNode = { x: 0, y: 0, w: 1, h: 1};\n    Utils.defaults(node, defaults);\n\n    if (!node.autoPosition) { delete node.autoPosition; }\n    if (!node.noResize) { delete node.noResize; }\n    if (!node.noMove) { delete node.noMove; }\n    Utils.sanitizeMinMax(node);\n\n    // check for NaN (in case messed up strings were passed. can't do parseInt() || defaults.x above as 0 is valid #)\n    if (typeof node.x == 'string') { node.x = Number(node.x); }\n    if (typeof node.y == 'string') { node.y = Number(node.y); }\n    if (typeof node.w == 'string') { node.w = Number(node.w); }\n    if (typeof node.h == 'string') { node.h = Number(node.h); }\n    if (isNaN(node.x)) { node.x = defaults.x; node.autoPosition = true; }\n    if (isNaN(node.y)) { node.y = defaults.y; node.autoPosition = true; }\n    if (isNaN(node.w)) { node.w = defaults.w; }\n    if (isNaN(node.h)) { node.h = defaults.h; }\n\n    this.nodeBoundFix(node, resizing);\n    return node;\n  }\n\n  /**\n   * Part 2 of preparing a node to fit inside the grid - validates and fixes coordinates and dimensions.\n   * This ensures the node fits within grid boundaries and respects min/max constraints.\n   * \n   * @param node the node to validate and fix\n   * @param resizing if true, resize the node to fit; if false, move the node to fit\n   * @returns the engine instance for chaining\n   * \n   * @example\n   * // Fix a node that might be out of bounds\n   * engine.nodeBoundFix(node, true); // Resize to fit\n   * engine.nodeBoundFix(node, false); // Move to fit\n   */\n  public nodeBoundFix(node: GridStackNode, resizing?: boolean): GridStackEngine {\n\n    const before = node._orig || Utils.copyPos({}, node);\n\n    if (node.maxW) { node.w = Math.min(node.w || 1, node.maxW); }\n    if (node.maxH) { node.h = Math.min(node.h || 1, node.maxH); }\n    if (node.minW) { node.w = Math.max(node.w || 1, node.minW); }\n    if (node.minH) { node.h = Math.max(node.h || 1, node.minH); }\n\n    // if user loaded a larger than allowed widget for current # of columns,\n    // remember it's position & width so we can restore back (1 -> 12 column) #1655 #1985\n    // IFF we're not in the middle of column resizing!\n    const saveOrig = (node.x || 0) + (node.w || 1) > this.column;\n    if (saveOrig && this.column < this.defaultColumn && !this._inColumnResize && !this.skipCacheUpdate && node._id != null  && this.findCacheLayout(node, this.defaultColumn) === -1) {\n      const copy = {...node}; // need _id + positions\n      if (copy.autoPosition || copy.x === undefined) { delete copy.x; delete copy.y; }\n      else copy.x = Math.min(this.defaultColumn - 1, copy.x);\n      copy.w = Math.min(this.defaultColumn, copy.w || 1);\n      this.cacheOneLayout(copy, this.defaultColumn);\n    }\n    \n    if (node.w > this.column) {\n      node.w = this.column;\n    } else if (node.w < 1) {\n      node.w = 1;\n    }\n\n    if (this.maxRow && node.h > this.maxRow) {\n      node.h = this.maxRow;\n    } else if (node.h < 1) {\n      node.h = 1;\n    }\n\n    if (node.x < 0) {\n      node.x = 0;\n    }\n    if (node.y < 0) {\n      node.y = 0;\n    }\n\n    if (node.x + node.w > this.column) {\n      if (resizing) {\n        node.w = this.column - node.x;\n      } else {\n        node.x = this.column - node.w;\n      }\n    }\n    if (this.maxRow && node.y + node.h > this.maxRow) {\n      if (resizing) {\n        node.h = this.maxRow - node.y;\n      } else {\n        node.y = this.maxRow - node.h;\n      }\n    }\n\n    if (!Utils.samePos(node, before)) {\n      node._dirty = true;\n    }\n\n    return this;\n  }\n\n  /**\n   * Returns a list of nodes that have been modified from their original values.\n   * This is used to track which nodes need DOM updates.\n   * \n   * @param verify if true, performs additional verification by comparing current vs original positions\n   * @returns array of nodes that have been modified\n   * \n   * @example\n   * const changed = engine.getDirtyNodes();\n   * console.log('Modified nodes:', changed.length);\n   * \n   * // Get verified dirty nodes\n   * const verified = engine.getDirtyNodes(true);\n   */\n  public getDirtyNodes(verify?: boolean): GridStackNode[] {\n    // compare original x,y,w,h instead as _dirty can be a temporary state\n    if (verify) {\n      return this.nodes.filter(n => n._dirty && !Utils.samePos(n, n._orig));\n    }\n    return this.nodes.filter(n => n._dirty);\n  }\n\n  /** @internal call this to call onChange callback with dirty nodes so DOM can be updated */\n  protected _notify(removedNodes?: GridStackNode[]): GridStackEngine {\n    if (this.batchMode || !this.onChange) return this;\n    const dirtyNodes = (removedNodes || []).concat(this.getDirtyNodes());\n    this.onChange(dirtyNodes);\n    return this;\n  }\n\n  /**\n   * Clean all dirty and last tried information from nodes.\n   * This resets the dirty state tracking for all nodes.\n   * \n   * @returns the engine instance for chaining\n   * \n   * @internal\n   */\n  public cleanNodes(): GridStackEngine {\n    if (this.batchMode) return this;\n    this.nodes.forEach(n => {\n      delete n._dirty;\n      delete n._lastTried;\n    });\n    return this;\n  }\n\n  /**\n   * Save the initial position/size of all nodes to track real dirty state.\n   * This creates a snapshot of current positions that can be restored later.\n   * \n   * Note: Should be called right after change events and before move/resize operations.\n   * \n   * @returns the engine instance for chaining\n   * \n   * @internal\n   */\n  public saveInitial(): GridStackEngine {\n    this.nodes.forEach(n => {\n      n._orig = Utils.copyPos({}, n);\n      delete n._dirty;\n    });\n    this._hasLocked = this.nodes.some(n => n.locked);\n    return this;\n  }\n\n  /**\n   * Restore all nodes back to their initial values.\n   * This is typically called when canceling an operation (e.g., Esc key during drag).\n   * \n   * @returns the engine instance for chaining\n   * \n   * @internal\n   */\n  public restoreInitial(): GridStackEngine {\n    this.nodes.forEach(n => {\n      if (!n._orig || Utils.samePos(n, n._orig)) return;\n      Utils.copyPos(n, n._orig);\n      n._dirty = true;\n    });\n    this._notify();\n    return this;\n  }\n\n  /**\n   * Find the first available empty spot for the given node dimensions.\n   * Updates the node's x,y attributes with the found position.\n   * \n   * @param node the node to find a position for (w,h must be set)\n   * @param nodeList optional list of nodes to check against (defaults to engine nodes)\n   * @param column optional column count (defaults to engine column count)\n   * @param after optional node to start search after (maintains order)\n   * @returns true if an empty position was found and node was updated\n   * \n   * @example\n   * const node = { w: 2, h: 1 };\n   * if (engine.findEmptyPosition(node)) {\n   *   console.log('Found position at:', node.x, node.y);\n   * }\n   */\n  public findEmptyPosition(node: GridStackNode, nodeList = this.nodes, column = this.column, after?: GridStackNode): boolean {\n    const start = after ? after.y * column + (after.x + after.w) : 0;\n    let found = false;\n    for (let i = start; !found; ++i) {\n      const x = i % column;\n      const y = Math.floor(i / column);\n      if (x + node.w > column) {\n        continue;\n      }\n      const box = {x, y, w: node.w, h: node.h};\n      if (!nodeList.find(n => Utils.isIntercepted(box, n))) {\n        if (node.x !== x || node.y !== y) node._dirty = true;\n        node.x = x;\n        node.y = y;\n        delete node.autoPosition;\n        found = true;\n      }\n    }\n    return found;\n  }\n\n  /**\n   * Add the given node to the grid, handling collision detection and re-packing.\n   * This is the main method for adding new widgets to the engine.\n   * \n   * @param node the node to add to the grid\n   * @param triggerAddEvent if true, adds node to addedNodes list for event triggering\n   * @param after optional node to place this node after (for ordering)\n   * @returns the added node (or existing node if duplicate)\n   * \n   * @example\n   * const node = { x: 0, y: 0, w: 2, h: 1, content: 'Hello' };\n   * const added = engine.addNode(node, true);\n   */\n  public addNode(node: GridStackNode, triggerAddEvent = false, after?: GridStackNode): GridStackNode {\n    const dup = this.nodes.find(n => n._id === node._id);\n    if (dup) return dup; // prevent inserting twice! return it instead.\n\n    // skip prepareNode if we're in middle of column resize (not new) but do check for bounds!\n    this._inColumnResize ? this.nodeBoundFix(node) : this.prepareNode(node);\n    delete node._temporaryRemoved;\n    delete node._removeDOM;\n\n    let skipCollision: boolean;\n    if (node.autoPosition && this.findEmptyPosition(node, this.nodes, this.column, after)) {\n      delete node.autoPosition; // found our slot\n      skipCollision = true;\n    }\n\n    this.nodes.push(node);\n    if (triggerAddEvent) { this.addedNodes.push(node); }\n\n    if (!skipCollision) this._fixCollisions(node);\n    if (!this.batchMode) { this._packNodes()._notify(); }\n    return node;\n  }\n\n  /**\n   * Remove the given node from the grid.\n   * \n   * @param node the node to remove\n   * @param removeDOM if true (default), marks node for DOM removal\n   * @param triggerEvent if true, adds node to removedNodes list for event triggering\n   * @returns the engine instance for chaining\n   * \n   * @example\n   * engine.removeNode(node, true, true);\n   */\n  public removeNode(node: GridStackNode, removeDOM = true, triggerEvent = false): GridStackEngine {\n    if (!this.nodes.find(n => n._id === node._id)) {\n      // TEST console.log(`Error: GridStackEngine.removeNode() node._id=${node._id} not found!`)\n      return this;\n    }\n    if (triggerEvent) { // we wait until final drop to manually track removed items (rather than during drag)\n      this.removedNodes.push(node);\n    }\n    if (removeDOM) node._removeDOM = true; // let CB remove actual HTML (used to set _id to null, but then we loose layout info)\n    // don't use 'faster' .splice(findIndex(),1) in case node isn't in our list, or in multiple times.\n    this.nodes = this.nodes.filter(n => n._id !== node._id);\n    if (!node._isAboutToRemove) this._packNodes(); // if dragged out, no need to relayout as already done...\n    this._notify([node]);\n    return this;\n  }\n\n  /**\n   * Remove all nodes from the grid.\n   * \n   * @param removeDOM if true (default), marks all nodes for DOM removal\n   * @param triggerEvent if true (default), triggers removal events\n   * @returns the engine instance for chaining\n   * \n   * @example\n   * engine.removeAll(); // Remove all nodes\n   */\n  public removeAll(removeDOM = true, triggerEvent = true): GridStackEngine {\n    delete this._layouts;\n    if (!this.nodes.length) return this;\n    removeDOM && this.nodes.forEach(n => n._removeDOM = true); // let CB remove actual HTML (used to set _id to null, but then we loose layout info)\n    const removedNodes = this.nodes;\n    this.removedNodes = triggerEvent ? removedNodes : [];\n    this.nodes = [];\n    return this._notify(removedNodes);\n  }\n\n  /**\n   * Check if a node can be moved to a new position, considering layout constraints.\n   * This is a safer version of moveNode() that validates the move first.\n   * \n   * For complex cases (like maxRow constraints), it simulates the move in a clone first,\n   * then applies the changes only if they meet all specifications.\n   * \n   * @param node the node to move\n   * @param o move options including target position\n   * @returns true if the node was successfully moved\n   * \n   * @example\n   * const canMove = engine.moveNodeCheck(node, { x: 2, y: 1 });\n   * if (canMove) {\n   *   console.log('Node moved successfully');\n   * }\n   */\n  public moveNodeCheck(node: GridStackNode, o: GridStackMoveOpts): boolean {\n    // if (node.locked) return false;\n    if (!this.changedPosConstrain(node, o)) return false;\n    o.pack = true;\n\n    // simpler case: move item directly...\n    if (!this.maxRow) {\n      return this.moveNode(node, o);\n    }\n\n    // complex case: create a clone with NO maxRow (will check for out of bounds at the end)\n    let clonedNode: GridStackNode;\n    const clone = new GridStackEngine({\n      column: this.column,\n      float: this.float,\n      nodes: this.nodes.map(n => {\n        if (n._id === node._id) {\n          clonedNode = {...n};\n          return clonedNode;\n        }\n        return {...n};\n      })\n    });\n    if (!clonedNode) return false;\n\n    // check if we're covering 50% collision and could move, while still being under maxRow or at least not making it worse\n    // (case where widget was somehow added past our max #2449)\n    const canMove = clone.moveNode(clonedNode, o) && clone.getRow() <= Math.max(this.getRow(), this.maxRow);\n    // else check if we can force a swap (float=true, or different shapes) on non-resize\n    if (!canMove && !o.resizing && o.collide) {\n      const collide = o.collide.el.gridstackNode; // find the source node the clone collided with at 50%\n      if (this.swap(node, collide)) { // swaps and mark dirty\n        this._notify();\n        return true;\n      }\n    }\n    if (!canMove) return false;\n\n    // if clone was able to move, copy those mods over to us now instead of caller trying to do this all over!\n    // Note: we can't use the list directly as elements and other parts point to actual node, so copy content\n    clone.nodes.filter(n => n._dirty).forEach(c => {\n      const n = this.nodes.find(a => a._id === c._id);\n      if (!n) return;\n      Utils.copyPos(n, c);\n      n._dirty = true;\n    });\n    this._notify();\n    return true;\n  }\n\n  /** return true if can fit in grid height constrain only (always true if no maxRow) */\n  public willItFit(node: GridStackNode): boolean {\n    delete node._willFitPos;\n    if (!this.maxRow) return true;\n    // create a clone with NO maxRow and check if still within size\n    const clone = new GridStackEngine({\n      column: this.column,\n      float: this.float,\n      nodes: this.nodes.map(n => {return {...n}})\n    });\n    const n = {...node}; // clone node so we don't mod any settings on it but have full autoPosition and min/max as well! #1687\n    this.cleanupNode(n);\n    delete n.el; delete n._id; delete n.content; delete n.grid;\n    clone.addNode(n);\n    if (clone.getRow() <= this.maxRow) {\n      node._willFitPos = Utils.copyPos({}, n);\n      return true;\n    }\n    return false;\n  }\n\n  /** true if x,y or w,h are different after clamping to min/max */\n  public changedPosConstrain(node: GridStackNode, p: GridStackPosition): boolean {\n    // first make sure w,h are set for caller\n    p.w = p.w || node.w;\n    p.h = p.h || node.h;\n    if (node.x !== p.x || node.y !== p.y) return true;\n    // check constrained w,h\n    if (node.maxW) { p.w = Math.min(p.w, node.maxW); }\n    if (node.maxH) { p.h = Math.min(p.h, node.maxH); }\n    if (node.minW) { p.w = Math.max(p.w, node.minW); }\n    if (node.minH) { p.h = Math.max(p.h, node.minH); }\n    return (node.w !== p.w || node.h !== p.h);\n  }\n\n  /** return true if the passed in node was actually moved (checks for no-op and locked) */\n  public moveNode(node: GridStackNode, o: GridStackMoveOpts): boolean {\n    if (!node || /*node.locked ||*/ !o) return false;\n    let wasUndefinedPack: boolean;\n    if (o.pack === undefined && !this.batchMode) {\n      wasUndefinedPack = o.pack = true;\n    }\n\n    // constrain the passed in values and check if we're still changing our node\n    if (typeof o.x !== 'number') { o.x = node.x; }\n    if (typeof o.y !== 'number') { o.y = node.y; }\n    if (typeof o.w !== 'number') { o.w = node.w; }\n    if (typeof o.h !== 'number') { o.h = node.h; }\n    const resizing = (node.w !== o.w || node.h !== o.h);\n    const nn: GridStackNode = Utils.copyPos({}, node, true); // get min/max out first, then opt positions next\n    Utils.copyPos(nn, o);\n    this.nodeBoundFix(nn, resizing);\n    Utils.copyPos(o, nn);\n\n    if (!o.forceCollide && Utils.samePos(node, o)) return false;\n    const prevPos: GridStackPosition = Utils.copyPos({}, node);\n\n    // check if we will need to fix collision at our new location\n    const collides = this.collideAll(node, nn, o.skip);\n    let needToMove = true;\n    if (collides.length) {\n      const activeDrag = node._moving && !o.nested;\n      // check to make sure we actually collided over 50% surface area while dragging\n      let collide = activeDrag ? this.directionCollideCoverage(node, o, collides) : collides[0];\n      // if we're enabling creation of sub-grids on the fly, see if we're covering 80% of either one, if we didn't already do that\n      if (activeDrag && collide && node.grid?.opts?.subGridDynamic && !node.grid._isTemp) {\n        const over = Utils.areaIntercept(o.rect, collide._rect);\n        const a1 = Utils.area(o.rect);\n        const a2 = Utils.area(collide._rect);\n        const perc = over / (a1 < a2 ? a1 : a2);\n        if (perc > .8) {\n          collide.grid.makeSubGrid(collide.el, undefined, node);\n          collide = undefined;\n        }\n      }\n\n      if (collide) {\n        needToMove = !this._fixCollisions(node, nn, collide, o); // check if already moved...\n      } else {\n        needToMove = false; // we didn't cover >50% for a move, skip...\n        if (wasUndefinedPack) delete o.pack;\n      }\n    }\n\n    // now move (to the original ask vs the collision version which might differ) and repack things\n    if (needToMove && !Utils.samePos(node, nn)) {\n      node._dirty = true;\n      Utils.copyPos(node, nn);\n    }\n    if (o.pack) {\n      this._packNodes()\n        ._notify();\n    }\n    return !Utils.samePos(node, prevPos); // pack might have moved things back\n  }\n\n  public getRow(): number {\n    return this.nodes.reduce((row, n) => Math.max(row, n.y + n.h), 0);\n  }\n\n  public beginUpdate(node: GridStackNode): GridStackEngine {\n    if (!node._updating) {\n      node._updating = true;\n      delete node._skipDown;\n      if (!this.batchMode) this.saveInitial();\n    }\n    return this;\n  }\n\n  public endUpdate(): GridStackEngine {\n    const n = this.nodes.find(n => n._updating);\n    if (n) {\n      delete n._updating;\n      delete n._skipDown;\n    }\n    return this;\n  }\n\n  /** saves a copy of the largest column layout (eg 12 even when rendering oneColumnMode) so we don't loose orig layout,\n   * returning a list of widgets for serialization */\n  public save(saveElement = true, saveCB?: SaveFcn): GridStackNode[] {\n    // use the highest layout for any saved info so we can have full detail on reload #1849\n    const len = this._layouts?.length;\n    const layout = len && this.column !== (len - 1) ? this._layouts[len - 1] : null;\n    const list: GridStackNode[] = [];\n    this.sortNodes();\n    this.nodes.forEach(n => {\n      const wl = layout?.find(l => l._id === n._id);\n      // use layout info fields instead if set\n      const w: GridStackNode = {...n, ...(wl || {})};\n      Utils.removeInternalForSave(w, !saveElement);\n      if (saveCB) saveCB(n, w);\n      list.push(w);\n    });\n    return list;\n  }\n\n  /** @internal called whenever a node is added or moved - updates the cached layouts */\n  public layoutsNodesChange(nodes: GridStackNode[]): GridStackEngine {\n    if (!this._layouts || this._inColumnResize) return this;\n    // remove smaller layouts - we will re-generate those on the fly... larger ones need to update\n    this._layouts.forEach((layout, column) => {\n      if (!layout || column === this.column) return this;\n      if (column < this.column) {\n        this._layouts[column] = undefined;\n      }\n      else {\n        // we save the original x,y,w (h isn't cached) to see what actually changed to propagate better.\n        // NOTE: we don't need to check against out of bound scaling/moving as that will be done when using those cache values. #1785\n        const ratio = column / this.column;\n        nodes.forEach(node => {\n          if (!node._orig) return; // didn't change (newly added ?)\n          const n = layout.find(l => l._id === node._id);\n          if (!n) return; // no cache for new nodes. Will use those values.\n          // Y changed, push down same amount\n          // TODO: detect doing item 'swaps' will help instead of move (especially in 1 column mode)\n          if (n.y >= 0 && node.y !== node._orig.y) {\n            n.y += (node.y - node._orig.y);\n          }\n          // X changed, scale from new position\n          if (node.x !== node._orig.x) {\n            n.x = Math.round(node.x * ratio);\n          }\n          // width changed, scale from new width\n          if (node.w !== node._orig.w) {\n            n.w = Math.round(node.w * ratio);\n          }\n          // ...height always carries over from cache\n        });\n      }\n    });\n    return this;\n  }\n\n  /**\n   * @internal Called to scale the widget width & position up/down based on the column change.\n   * Note we store previous layouts (especially original ones) to make it possible to go\n   * from say 12 -> 1 -> 12 and get back to where we were.\n   *\n   * @param prevColumn previous number of columns\n   * @param column  new column number\n   * @param layout specify the type of re-layout that will happen (position, size, etc...).\n   * Note: items will never be outside of the current column boundaries. default (moveScale). Ignored for 1 column\n   */\n  public columnChanged(prevColumn: number, column: number, layout: ColumnOptions = 'moveScale'): GridStackEngine {\n    if (!this.nodes.length || !column || prevColumn === column) return this;\n\n    // simpler shortcuts layouts\n    const doCompact = layout === 'compact' || layout === 'list';\n    if (doCompact) {\n      this.sortNodes(1); // sort with original layout once and only once (new column will affect order otherwise)\n    }\n\n    // cache the current layout in case they want to go back (like 12 -> 1 -> 12) as it requires original data IFF we're sizing down (see below)\n    if (column < prevColumn) this.cacheLayout(this.nodes, prevColumn);\n    this.batchUpdate(); // do this EARLY as it will call saveInitial() so we can detect where we started for _dirty and collision\n    let newNodes: GridStackNode[] = [];\n    let nodes = doCompact ? this.nodes : Utils.sort(this.nodes, -1); // current column reverse sorting so we can insert last to front (limit collision)\n\n    // see if we have cached previous layout IFF we are going up in size (restore) otherwise always\n    // generate next size down from where we are (looks more natural as you gradually size down).\n    if (column > prevColumn && this._layouts) {\n      const cacheNodes = this._layouts[column] || [];\n      // ...if not, start with the largest layout (if not already there) as down-scaling is more accurate\n      // by pretending we came from that larger column by assigning those values as starting point\n      const lastIndex = this._layouts.length - 1;\n      if (!cacheNodes.length && prevColumn !== lastIndex && this._layouts[lastIndex]?.length) {\n        prevColumn = lastIndex;\n        this._layouts[lastIndex].forEach(cacheNode => {\n          const n = nodes.find(n => n._id === cacheNode._id);\n          if (n) {\n            // still current, use cache info positions\n            if (!doCompact && !cacheNode.autoPosition) {\n              n.x = cacheNode.x ?? n.x;\n              n.y = cacheNode.y ?? n.y;\n            }\n            n.w = cacheNode.w ?? n.w;\n            if (cacheNode.x == undefined || cacheNode.y === undefined) n.autoPosition = true;\n          }\n        });\n      }\n\n      // if we found cache re-use those nodes that are still current\n      cacheNodes.forEach(cacheNode => {\n        const j = nodes.findIndex(n => n._id === cacheNode._id);\n        if (j !== -1) {\n          const n = nodes[j];\n          // still current, use cache info positions\n          if (doCompact) {\n            n.w = cacheNode.w; // only w is used, and don't trim the list\n            return;\n          }\n          if (cacheNode.autoPosition || isNaN(cacheNode.x) || isNaN(cacheNode.y)) {\n            this.findEmptyPosition(cacheNode, newNodes);\n          }\n          if (!cacheNode.autoPosition) {\n            n.x = cacheNode.x ?? n.x;\n            n.y = cacheNode.y ?? n.y;\n            n.w = cacheNode.w ?? n.w;\n            newNodes.push(n);\n          }\n          nodes.splice(j, 1);\n        }\n      });\n    }\n\n    // much simpler layout that just compacts\n    if (doCompact) {\n      this.compact(layout, false);\n    } else {\n      // ...and add any extra non-cached ones\n      if (nodes.length) {\n        if (typeof layout === 'function') {\n          layout(column, prevColumn, newNodes, nodes);\n        } else {\n          const ratio = (doCompact || layout === 'none') ? 1 : column / prevColumn;\n          const move = (layout === 'move' || layout === 'moveScale');\n          const scale = (layout === 'scale' || layout === 'moveScale');\n          nodes.forEach(node => {\n            // NOTE: x + w could be outside of the grid, but addNode() below will handle that\n            node.x = (column === 1 ? 0 : (move ? Math.round(node.x * ratio) : Math.min(node.x, column - 1)));\n            node.w = ((column === 1 || prevColumn === 1) ? 1 : scale ? (Math.round(node.w * ratio) || 1) : (Math.min(node.w, column)));\n            newNodes.push(node);\n          });\n          nodes = [];\n        }\n      }\n\n      // finally re-layout them in reverse order (to get correct placement)\n      newNodes = Utils.sort(newNodes, -1);\n      this._inColumnResize = true; // prevent cache update\n      this.nodes = []; // pretend we have no nodes to start with (add() will use same structures) to simplify layout\n      newNodes.forEach(node => {\n        this.addNode(node, false); // 'false' for add event trigger\n        delete node._orig; // make sure the commit doesn't try to restore things back to original\n      });\n    }\n\n    this.nodes.forEach(n => delete n._orig); // clear _orig before batch=false so it doesn't handle float=true restore\n    this.batchUpdate(false, !doCompact);\n    delete this._inColumnResize;\n    return this;\n  }\n\n  /**\n   * call to cache the given layout internally to the given location so we can restore back when column changes size\n   * @param nodes list of nodes\n   * @param column corresponding column index to save it under\n   * @param clear if true, will force other caches to be removed (default false)\n   */\n  public cacheLayout(nodes: GridStackNode[], column: number, clear = false): GridStackEngine {\n    const copy: GridStackNode[] = [];\n    nodes.forEach((n, i) => {\n      // make sure we have an id in case this is new layout, else re-use id already set\n      if (n._id === undefined) {\n        const existing = n.id ? this.nodes.find(n2 => n2.id === n.id) : undefined; // find existing node using users id\n        n._id = existing?._id ?? GridStackEngine._idSeq++;\n      }\n      copy[i] = {x: n.x, y: n.y, w: n.w, _id: n._id} // only thing we change is x,y,w and id to find it back\n    });\n    this._layouts = clear ? [] : this._layouts || []; // use array to find larger quick\n    this._layouts[column] = copy;\n    return this;\n  }\n\n  /**\n   * call to cache the given node layout internally to the given location so we can restore back when column changes size\n   * @param node single node to cache\n   * @param column corresponding column index to save it under\n   */\n  public cacheOneLayout(n: GridStackNode, column: number): GridStackEngine {\n    n._id = n._id ?? GridStackEngine._idSeq++;\n    const l: GridStackNode = {x: n.x, y: n.y, w: n.w, _id: n._id}\n    if (n.autoPosition || n.x === undefined) { delete l.x; delete l.y; if (n.autoPosition) l.autoPosition = true; }\n    this._layouts = this._layouts || [];\n    this._layouts[column] = this._layouts[column] || [];\n    const index = this.findCacheLayout(n, column);\n    if (index === -1)\n      this._layouts[column].push(l);\n    else\n      this._layouts[column][index] = l;\n    return this;\n  }\n\n  protected findCacheLayout(n: GridStackNode, column: number): number | undefined {\n    return this._layouts?.[column]?.findIndex(l => l._id === n._id) ?? -1;\n  }\n\n  public removeNodeFromLayoutCache(n: GridStackNode) {\n    if (!this._layouts) {\n      return;\n    }\n    for (let i = 0; i < this._layouts.length; i++) {\n      const index = this.findCacheLayout(n, i);\n      if (index !== -1) {\n        this._layouts[i].splice(index, 1);\n      }\n    }\n  }\n\n  /** called to remove all internal values but the _id */\n  public cleanupNode(node: GridStackNode): GridStackEngine {\n    for (const prop in node) {\n      if (prop[0] === '_' && prop !== '_id') delete node[prop];\n    }\n    return this;\n  }\n}\n","/**\r\n * types.ts 12.3.0\r\n * Copyright (c) 2021-2025 Alain Dumesny - see GridStack root license\r\n */\r\n\r\nimport { GridStack } from './gridstack';\r\nimport { GridStackEngine } from './gridstack-engine';\r\n\r\n/**\r\n * Default values for grid options - used during initialization and when saving out grid configuration.\r\n * These values are applied when options are not explicitly provided.\r\n */\r\nexport const gridDefaults: GridStackOptions = {\r\n  alwaysShowResizeHandle: 'mobile',\r\n  animate: true,\r\n  auto: true,\r\n  cellHeight: 'auto',\r\n  cellHeightThrottle: 100,\r\n  cellHeightUnit: 'px',\r\n  column: 12,\r\n  draggable: { handle: '.grid-stack-item-content', appendTo: 'body', scroll: true },\r\n  handle: '.grid-stack-item-content',\r\n  itemClass: 'grid-stack-item',\r\n  margin: 10,\r\n  marginUnit: 'px',\r\n  maxRow: 0,\r\n  minRow: 0,\r\n  placeholderClass: 'grid-stack-placeholder',\r\n  placeholderText: '',\r\n  removableOptions: { accept: 'grid-stack-item', decline: 'grid-stack-non-removable'},\r\n  resizable: { handles: 'se' },\r\n  rtl: 'auto',\r\n\r\n  // **** same as not being set ****\r\n  // disableDrag: false,\r\n  // disableResize: false,\r\n  // float: false,\r\n  // handleClass: null,\r\n  // removable: false,\r\n  // staticGrid: false,\r\n  //removable\r\n};\r\n\r\n/**\r\n * Different layout options when changing the number of columns.\r\n * \r\n * These options control how widgets are repositioned when the grid column count changes.\r\n * Note: The new list may be partially filled if there's a cached layout for that size.\r\n * \r\n * Options:\r\n * - `'list'`: Treat items as a sorted list, keeping them sequentially without resizing (unless too big)\r\n * - `'compact'`: Similar to list, but uses compact() method to fill empty slots by reordering\r\n * - `'moveScale'`: Scale and move items by the ratio of newColumnCount / oldColumnCount\r\n * - `'move'`: Only move items, keep their sizes\r\n * - `'scale'`: Only scale items, keep their positions\r\n * - `'none'`: Leave items unchanged unless they don't fit in the new column count\r\n * - Custom function: Provide your own layout logic\r\n */\r\nexport type ColumnOptions = 'list' | 'compact' | 'moveScale' | 'move' | 'scale' | 'none' |\r\n  ((column: number, oldColumn: number, nodes: GridStackNode[], oldNodes: GridStackNode[]) => void);\r\n/**\r\n * Options for the compact() method to reclaim empty space.\r\n * - `'list'`: Keep items in order, move them up sequentially\r\n * - `'compact'`: Find truly empty spaces, may reorder items for optimal fit\r\n */\r\nexport type CompactOptions = 'list' | 'compact';\r\n/**\r\n * Type representing values that can be either numbers or strings (e.g., dimensions with units).\r\n * Used for properties like width, height, margins that accept both numeric and string values.\r\n */\r\nexport type numberOrString = number | string;\r\n/**\r\n * Extended HTMLElement interface for grid items.\r\n * All grid item DOM elements implement this interface to provide access to their grid data.\r\n */\r\nexport interface GridItemHTMLElement extends HTMLElement {\r\n  /** Pointer to the associated grid node instance containing position, size, and other widget data */\r\n  gridstackNode?: GridStackNode;\r\n  /** @internal Original node data (used for restoring during drag operations) */\r\n  _gridstackNodeOrig?: GridStackNode;\r\n}\r\n\r\n/**\r\n * Type representing various ways to specify grid elements.\r\n * Can be a CSS selector string, HTMLElement, or GridItemHTMLElement.\r\n */\r\nexport type GridStackElement = string | HTMLElement | GridItemHTMLElement;\r\n\r\n/**\r\n * Event handler function types for the .on() method.\r\n * Different handlers receive different parameters based on the event type.\r\n */\r\n\r\n/** General event handler that receives only the event */\r\nexport type GridStackEventHandler = (event: Event) => void;\r\n\r\n/** Element-specific event handler that receives event and affected element */\r\nexport type GridStackElementHandler = (event: Event, el: GridItemHTMLElement) => void;\r\n\r\n/** Node-based event handler that receives event and array of affected nodes */\r\nexport type GridStackNodesHandler = (event: Event, nodes: GridStackNode[]) => void;\r\n\r\n/** Drop event handler that receives previous and new node states */\r\nexport type GridStackDroppedHandler = (event: Event, previousNode: GridStackNode, newNode: GridStackNode) => void;\r\n\r\n/** Union type of all possible event handler types */\r\nexport type GridStackEventHandlerCallback = GridStackEventHandler | GridStackElementHandler | GridStackNodesHandler | GridStackDroppedHandler;\r\n\r\n/**\r\n * Optional callback function called during load() operations.\r\n * Allows custom handling of widget addition/removal for framework integration.\r\n * \r\n * @param parent - The parent HTML element\r\n * @param w - The widget definition\r\n * @param add - True if adding, false if removing\r\n * @param grid - True if this is a grid operation\r\n * @returns The created/modified HTML element, or undefined\r\n */\r\nexport type AddRemoveFcn = (parent: HTMLElement, w: GridStackWidget, add: boolean, grid: boolean) => HTMLElement | undefined;\r\n\r\n/**\r\n * Optional callback function called during save() operations.\r\n * Allows adding custom data to the saved widget structure.\r\n * \r\n * @param node - The internal grid node\r\n * @param w - The widget structure being saved (can be modified)\r\n */\r\nexport type SaveFcn = (node: GridStackNode, w: GridStackWidget) => void;\r\n\r\n/**\r\n * Optional callback function for custom widget content rendering.\r\n * Called during load()/addWidget() to create custom content beyond plain text.\r\n * \r\n * @param el - The widget's content container element\r\n * @param w - The widget definition with content and other properties\r\n */\r\nexport type RenderFcn = (el: HTMLElement, w: GridStackWidget) => void;\r\n\r\n/**\r\n * Optional callback function for custom resize-to-content behavior.\r\n * Called when a widget needs to resize to fit its content.\r\n * \r\n * @param el - The grid item element to resize\r\n */\r\nexport type ResizeToContentFcn = (el: GridItemHTMLElement) => void;\r\n\r\n/**\r\n * Configuration for responsive grid behavior.\r\n * \r\n * Defines how the grid responds to different screen sizes by changing column counts.\r\n * NOTE: Make sure to include the appropriate CSS (gridstack-extra.css) to support responsive behavior.\r\n */\r\nexport interface Responsive {\r\n  /** wanted width to maintain (+-50%) to dynamically pick a column count. NOTE: make sure to have correct extra CSS to support this. */\r\n  columnWidth?: number;\r\n  /** maximum number of columns allowed (default: 12). NOTE: make sure to have correct extra CSS to support this. */\r\n  columnMax?: number;\r\n  /** explicit width:column breakpoints instead of automatic 'columnWidth'. NOTE: make sure to have correct extra CSS to support this. */\r\n  breakpoints?: Breakpoint[];\r\n  /** specify if breakpoints are for window size or grid size (default:false = grid) */\r\n  breakpointForWindow?: boolean;\r\n  /** global re-layout mode when changing columns */\r\n  layout?: ColumnOptions;\r\n}\r\n\r\n/**\r\n * Defines a responsive breakpoint for automatic column count changes.\r\n * Used with the responsive.breakpoints option.\r\n */\r\nexport interface Breakpoint {\r\n  /** Maximum width (in pixels) for this breakpoint to be active */\r\n  w?: number;\r\n  /** Number of columns to use when this breakpoint is active */\r\n  c: number;\r\n  /** Layout mode for this specific breakpoint (overrides global responsive.layout) */\r\n  layout?: ColumnOptions;\r\n  /** TODO: Future feature - specific children layout for this breakpoint */\r\n  // children?: GridStackWidget[];\r\n}\r\n\r\n/**\r\n * Defines the options for a Grid\r\n */\r\nexport interface GridStackOptions {\r\n  /**\r\n   * Accept widgets dragged from other grids or from outside (default: `false`). Can be:\r\n   * - `true`: will accept HTML elements having 'grid-stack-item' as class attribute\r\n   * - `false`: will not accept any external widgets\r\n   * - string: explicit class name to accept instead of default\r\n   * - function: callback called before an item will be accepted when entering a grid\r\n   * \r\n   * @example\r\n   * // Accept all grid items\r\n   * acceptWidgets: true\r\n   * \r\n   * // Accept only items with specific class\r\n   * acceptWidgets: 'my-draggable-item'\r\n   * \r\n   * // Custom validation function\r\n   * acceptWidgets: (el) => {\r\n   *   return el.getAttribute('data-accept') === 'true';\r\n   * }\r\n   * \r\n   * @see {@link http://gridstack.github.io/gridstack.js/demo/two.html} for complete example\r\n   */\r\n  acceptWidgets?: boolean | string | ((element: Element) => boolean);\r\n\r\n  /** possible values (default: `mobile`) - does not apply to non-resizable widgets\r\n    * `false` the resizing handles are only shown while hovering over a widget\r\n    * `true` the resizing handles are always shown\r\n    * 'mobile' if running on a mobile device, default to `true` (since there is no hovering per say), else `false`.\r\n    See [example](http://gridstack.github.io/gridstack.js/demo/mobile.html) */\r\n  alwaysShowResizeHandle?: true | false | 'mobile';\r\n\r\n  /** turns animation on (default?: true) */\r\n  animate?: boolean;\r\n\r\n  /** if false gridstack will not initialize existing items (default?: true) */\r\n  auto?: boolean;\r\n\r\n  /**\r\n   * One cell height (default: 'auto'). Can be:\r\n   * - an integer (px): fixed pixel height\r\n   * - a string (ex: '100px', '10em', '10rem'): CSS length value\r\n   * - 0: library will not generate styles for rows (define your own CSS)\r\n   * - 'auto': height calculated for square cells (width / column) and updated live on window resize\r\n   * - 'initial': similar to 'auto' but stays fixed size during window resizing\r\n   * \r\n   * Note: % values don't work correctly - see demo/cell-height.html\r\n   * \r\n   * @example\r\n   * // Fixed 100px height\r\n   * cellHeight: 100\r\n   * \r\n   * // CSS units\r\n   * cellHeight: '5rem'\r\n   * cellHeight: '100px'\r\n   * \r\n   * // Auto-sizing for square cells\r\n   * cellHeight: 'auto'\r\n   * \r\n   * // No CSS generation (custom styles)\r\n   * cellHeight: 0\r\n   */\r\n  cellHeight?: numberOrString;\r\n\r\n  /** throttle time delay (in ms) used when cellHeight='auto' to improve performance vs usability (default?: 100).\r\n   * A value of 0 will make it instant at a cost of re-creating the CSS file at ever window resize event!\r\n   * */\r\n  cellHeightThrottle?: number;\r\n\r\n  /** (internal) unit for cellHeight (default? 'px') which is set when a string cellHeight with a unit is passed (ex: '10rem') */\r\n  cellHeightUnit?: string;\r\n\r\n  /** list of children item to create when calling load() or addGrid() */\r\n  children?: GridStackWidget[];\r\n\r\n  /** number of columns (default?: 12). Note: IF you change this, CSS also have to change. See https://github.com/gridstack/gridstack.js#change-grid-columns.\r\n   * Note: for nested grids, it is recommended to use 'auto' which will always match the container grid-item current width (in column) to keep inside and outside\r\n   * items always the same. flag is NOT supported for regular non-nested grids.\r\n   */\r\n  column?: number | 'auto';\r\n\r\n  /** responsive column layout for width:column behavior */\r\n  columnOpts?: Responsive;\r\n\r\n  /** additional class on top of '.grid-stack' (which is required for our CSS) to differentiate this instance.\r\n  Note: only used by addGrid(), else your element should have the needed class */\r\n  class?: string;\r\n\r\n  /** disallows dragging of widgets (default?: false) */\r\n  disableDrag?: boolean;\r\n\r\n  /** disallows resizing of widgets (default?: false). */\r\n  disableResize?: boolean;\r\n\r\n  /** allows to override UI draggable options. (default?: { handle?: '.grid-stack-item-content', appendTo?: 'body' }) */\r\n  draggable?: DDDragOpt;\r\n\r\n  /** let user drag nested grid items out of a parent or not (default true - not supported yet) */\r\n  //dragOut?: boolean;\r\n\r\n  /** the type of engine to create (so you can subclass) default to GridStackEngine */\r\n  engineClass?: typeof GridStackEngine;\r\n\r\n  /** enable floating widgets (default?: false) See example (http://gridstack.github.io/gridstack.js/demo/float.html) */\r\n  float?: boolean;\r\n\r\n  /** draggable handle selector (default?: '.grid-stack-item-content') */\r\n  handle?: string;\r\n\r\n  /** draggable handle class (e.g. 'grid-stack-item-content'). If set 'handle' is ignored (default?: null) */\r\n  handleClass?: string;\r\n\r\n  /** additional widget class (default?: 'grid-stack-item') */\r\n  itemClass?: string;\r\n\r\n  /** re-layout mode when we're a subgrid and we are being resized. default to 'list' */\r\n  layout?: ColumnOptions;\r\n\r\n  /** true when widgets are only created when they scroll into view (visible) */\r\n  lazyLoad?: boolean;\r\n\r\n  /**\r\n   * gap between grid item and content (default?: 10). This will set all 4 sides and support the CSS formats below\r\n   *  an integer (px)\r\n   *  a string with possible units (ex: '2em', '20px', '2rem')\r\n   *  string with space separated values (ex: '5px 10px 0 20px' for all 4 sides, or '5em 10em' for top/bottom and left/right pairs like CSS).\r\n   * Note: all sides must have same units (last one wins, default px)\r\n   */\r\n  margin?: numberOrString;\r\n\r\n  /** OLD way to optionally set each side - use margin: '5px 10px 0 20px' instead. Used internally to store each side. */\r\n  marginTop?: numberOrString;\r\n  marginRight?: numberOrString;\r\n  marginBottom?: numberOrString;\r\n  marginLeft?: numberOrString;\r\n\r\n  /** (internal) unit for margin (default? 'px') set when `margin` is set as string with unit (ex: 2rem') */\r\n  marginUnit?: string;\r\n\r\n  /** maximum rows amount. Default? is 0 which means no maximum rows */\r\n  maxRow?: number;\r\n\r\n  /** minimum rows amount which is handy to prevent grid from collapsing when empty. Default is `0`.\r\n   * When no set the `min-height` CSS attribute on the grid div (in pixels) can be used, which will round to the closest row.\r\n   */\r\n  minRow?: number;\r\n\r\n  /** If you are using a nonce-based Content Security Policy, pass your nonce here and\r\n   * GridStack will add it to the <style> elements it creates. */\r\n  nonce?: string;\r\n\r\n  /** class for placeholder (default?: 'grid-stack-placeholder') */\r\n  placeholderClass?: string;\r\n\r\n  /** placeholder default content (default?: '') */\r\n  placeholderText?: string;\r\n\r\n  /** allows to override UI resizable options. (default?: { handles: 'se' }) */\r\n  resizable?: DDResizeOpt;\r\n\r\n  /**\r\n   * if true widgets could be removed by dragging outside of the grid. It could also be a selector string (ex: \".trash\"),\r\n   * in this case widgets will be removed by dropping them there (default?: false)\r\n   * See example (http://gridstack.github.io/gridstack.js/demo/two.html)\r\n   */\r\n  removable?: boolean | string;\r\n\r\n  /** allows to override UI removable options. (default?: { accept: '.grid-stack-item' }) */\r\n  removableOptions?: DDRemoveOpt;\r\n\r\n  /** fix grid number of rows. This is a shortcut of writing `minRow:N, maxRow:N`. (default `0` no constrain) */\r\n  row?: number;\r\n\r\n  /**\r\n   * if true turns grid to RTL. Possible values are true, false, 'auto' (default?: 'auto')\r\n   * See [example](http://gridstack.github.io/gridstack.js/demo/right-to-left(rtl).html)\r\n   */\r\n  rtl?: boolean | 'auto';\r\n\r\n  /** set to true if all grid items (by default, but item can also override) height should be based on content size instead of WidgetItem.h to avoid v-scrollbars.\r\n   * Note: this is still row based, not pixels, so it will use ceil(getBoundingClientRect().height / getCellHeight())\r\n   */\r\n  sizeToContent?: boolean;\r\n\r\n  /**\r\n   * makes grid static (default?: false). If `true` widgets are not movable/resizable.\r\n   * You don't even need draggable/resizable. A CSS class\r\n   * 'grid-stack-static' is also added to the element.\r\n   */\r\n  staticGrid?: boolean;\r\n\r\n  /**\r\n   * @deprecated Not used anymore, styles are now implemented with local CSS variables\r\n   */\r\n  styleInHead?: boolean;\r\n\r\n  /** list of differences in options for automatically created sub-grids under us (inside our grid-items) */\r\n  subGridOpts?: GridStackOptions;\r\n\r\n  /** enable/disable the creation of sub-grids on the fly by dragging items completely\r\n   * over others (nest) vs partially (push). Forces `DDDragOpt.pause=true` to accomplish that. */\r\n  subGridDynamic?: boolean;\r\n}\r\n\r\n/** options used during GridStackEngine.moveNode() */\r\nexport interface GridStackMoveOpts extends GridStackPosition {\r\n  /** node to skip collision */\r\n  skip?: GridStackNode;\r\n  /** do we pack (default true) */\r\n  pack?: boolean;\r\n  /** true if we are calling this recursively to prevent simple swap or coverage collision - default false*/\r\n  nested?: boolean;\r\n  /** vars to calculate other cells coordinates */\r\n  cellWidth?: number;\r\n  cellHeight?: number;\r\n  marginTop?: number;\r\n  marginBottom?: number;\r\n  marginLeft?: number;\r\n  marginRight?: number;\r\n  /** position in pixels of the currently dragged items (for overlap check) */\r\n  rect?: GridStackPosition;\r\n  /** true if we're live resizing */\r\n  resizing?: boolean;\r\n  /** best node (most coverage) we collied with */\r\n  collide?: GridStackNode;\r\n  /** for collision check even if we don't move */\r\n  forceCollide?: boolean;\r\n}\r\n\r\nexport interface GridStackPosition {\r\n  /** widget position x (default?: 0) */\r\n  x?: number;\r\n  /** widget position y (default?: 0) */\r\n  y?: number;\r\n  /** widget dimension width (default?: 1) */\r\n  w?: number;\r\n  /** widget dimension height (default?: 1) */\r\n  h?: number;\r\n}\r\n\r\n/**\r\n * GridStack Widget creation options\r\n */\r\nexport interface GridStackWidget extends GridStackPosition {\r\n  /** if true then x, y parameters will be ignored and widget will be places on the first available position (default?: false) */\r\n  autoPosition?: boolean;\r\n  /** minimum width allowed during resize/creation (default?: undefined = un-constrained) */\r\n  minW?: number;\r\n  /** maximum width allowed during resize/creation (default?: undefined = un-constrained) */\r\n  maxW?: number;\r\n  /** minimum height allowed during resize/creation (default?: undefined = un-constrained) */\r\n  minH?: number;\r\n  /** maximum height allowed during resize/creation (default?: undefined = un-constrained) */\r\n  maxH?: number;\r\n  /** prevent direct resizing by the user (default?: undefined = un-constrained) */\r\n  noResize?: boolean;\r\n  /** prevents direct moving by the user (default?: undefined = un-constrained) */\r\n  noMove?: boolean;\r\n  /** prevents being pushed by other widgets or api (default?: undefined = un-constrained), which is different from `noMove` (user action only) */\r\n  locked?: boolean;\r\n  /** value for `gs-id` stored on the widget (default?: undefined) */\r\n  id?: string;\r\n  /** html to append inside as content */\r\n  content?: string;\r\n  /** true when widgets are only created when they scroll into view (visible) */\r\n  lazyLoad?: boolean;\r\n  /** local (vs grid) override - see GridStackOptions.\r\n   * Note: This also allow you to set a maximum h value (but user changeable during normal resizing) to prevent unlimited content from taking too much space (get scrollbar) */\r\n  sizeToContent?: boolean | number;\r\n  /** local override of GridStack.resizeToContentParent that specify the class to use for the parent (actual) vs child (wanted) height */\r\n  resizeToContentParent?: string;\r\n  /** optional nested grid options and list of children, which then turns into actual instance at runtime to get options from */\r\n  subGridOpts?: GridStackOptions;\r\n}\r\n\r\n/** Drag&Drop resize options */\r\nexport interface DDResizeOpt {\r\n  /** do resize handle hide by default until mouse over ? - default: true on desktop, false on mobile*/\r\n  autoHide?: boolean;\r\n  /**\r\n   * sides where you can resize from (ex: 'e, se, s, sw, w') - default 'se' (south-east)\r\n   * Note: it is not recommended to resize from the top sides as weird side effect may occur.\r\n  */\r\n  handles?: string;\r\n}\r\n\r\n/** Drag&Drop remove options */\r\nexport interface DDRemoveOpt {\r\n  /** class that can be removed (default?: opts.itemClass) */\r\n  accept?: string;\r\n  /** class that cannot be removed (default: 'grid-stack-non-removable') */\r\n  decline?: string;\r\n}\r\n\r\n/** Drag&Drop dragging options */\r\nexport interface DDDragOpt {\r\n  /** class selector of items that can be dragged. default to '.grid-stack-item-content' */\r\n  handle?: string;\r\n  /** default to 'body' */\r\n  appendTo?: string;\r\n  /** if set (true | msec), dragging placement (collision) will only happen after a pause by the user. Note: this is Global */\r\n  pause?: boolean | number;\r\n  /** default to `true` */\r\n  scroll?: boolean;\r\n  /** prevents dragging from starting on specified elements, listed as comma separated selectors (eg: '.no-drag'). default built in is 'input,textarea,button,select,option' */\r\n  cancel?: string;\r\n  /** helper function when dropping: 'clone' or your own method */\r\n  helper?: 'clone' | ((el: HTMLElement) => HTMLElement);\r\n  /** callbacks */\r\n  start?: (event: Event, ui: DDUIData) => void;\r\n  stop?: (event: Event) => void;\r\n  drag?: (event: Event, ui: DDUIData) => void;\r\n}\r\nexport interface Size {\r\n  width: number;\r\n  height: number;\r\n}\r\nexport interface Position {\r\n  top: number;\r\n  left: number;\r\n}\r\nexport interface Rect extends Size, Position {}\r\n\r\n/** data that is passed during drag and resizing callbacks */\r\nexport interface DDUIData {\r\n  position?: Position;\r\n  size?: Size;\r\n  draggable?: HTMLElement;\r\n  /* fields not used by GridStack but sent by jq ? leave in case we go back to them...\r\n  originalPosition? : Position;\r\n  offset?: Position;\r\n  originalSize?: Size;\r\n  element?: HTMLElement[];\r\n  helper?: HTMLElement[];\r\n  originalElement?: HTMLElement[];\r\n  */\r\n}\r\n\r\n/**\r\n * internal runtime descriptions describing the widgets in the grid\r\n */\r\nexport interface GridStackNode extends GridStackWidget {\r\n  /** pointer back to HTML element */\r\n  el?: GridItemHTMLElement;\r\n  /** pointer back to parent Grid instance */\r\n  grid?: GridStack;\r\n  /** actual sub-grid instance */\r\n  subGrid?: GridStack;\r\n  /** allow delay creation when visible */\r\n  visibleObservable?: IntersectionObserver;\r\n  /** @internal internal id used to match when cloning engines or saving column layouts */\r\n  _id?: number;\r\n  /** @internal does the node attr ned to be updated due to changed x,y,w,h values */\r\n  _dirty?: boolean;\r\n  /** @internal */\r\n  _updating?: boolean;\r\n  /** @internal true when over trash/another grid so we don't bother removing drag CSS style that would animate back to old position */\r\n  _isAboutToRemove?: boolean;\r\n  /** @internal true if item came from outside of the grid -> actual item need to be moved over */\r\n  _isExternal?: boolean;\r\n  /** @internal Mouse event that's causing moving|resizing */\r\n  _event?: MouseEvent;\r\n  /** @internal moving vs resizing */\r\n  _moving?: boolean;\r\n  /** @internal is resizing? */\r\n  _resizing?: boolean;\r\n  /** @internal true if we jumped down past item below (one time jump so we don't have to totally pass it) */\r\n  _skipDown?: boolean;\r\n  /** @internal original values before a drag/size */\r\n  _orig?: GridStackPosition;\r\n  /** @internal position in pixels used during collision check  */\r\n  _rect?: GridStackPosition;\r\n  /** @internal top/left pixel location before a drag so we can detect direction of move from last position*/\r\n  _lastUiPosition?: Position;\r\n  /** @internal set on the item being dragged/resized remember the last positions we've tried (but failed) so we don't try again during drag/resize */\r\n  _lastTried?: GridStackPosition;\r\n  /** @internal position willItFit() will use to position the item */\r\n  _willFitPos?: GridStackPosition;\r\n  /** @internal last drag Y pixel position used to incrementally update V scroll bar */\r\n  _prevYPix?: number;\r\n  /** @internal true if we've remove the item from ourself (dragging out) but might revert it back (release on nothing -> goes back) */\r\n  _temporaryRemoved?: boolean;\r\n  /** @internal true if we should remove DOM element on _notify() rather than clearing _id (old way) */\r\n  _removeDOM?: boolean;\r\n  /** @internal original position/size of item if dragged from sidebar */\r\n  _sidebarOrig?: GridStackPosition;\r\n  /** @internal had drag&drop been initialized */\r\n  _initDD?: boolean;\r\n}\r\n","/**\n * dd-manager.ts 12.3.0\n * Copyright (c) 2021-2025 Alain Dumesny - see GridStack root license\n */\n\nimport { DDDraggable } from './dd-draggable';\nimport { DDDroppable } from './dd-droppable';\nimport { DDResizable } from './dd-resizable';\n\n/**\n * Global state manager for all Drag & Drop instances.\n * \n * This class maintains shared state across all drag & drop operations,\n * ensuring proper coordination between multiple grids and drag/drop elements.\n * All properties are static to provide global access throughout the DD system.\n */\nexport class DDManager {\n  /**\n   * Controls drag operation pausing behavior.\n   * If set to true or a number (milliseconds), dragging placement and collision\n   * detection will only happen after the user pauses movement.\n   * This improves performance during rapid mouse movements.\n   */\n  public static pauseDrag: boolean | number;\n\n  /**\n   * Flag indicating if a mouse down event was already handled.\n   * Prevents multiple handlers from processing the same mouse event.\n   */\n  public static mouseHandled: boolean;\n\n  /**\n   * Reference to the element currently being dragged.\n   * Used to track the active drag operation across the system.\n   */\n  public static dragElement: DDDraggable;\n\n  /**\n   * Reference to the drop target element currently under the cursor.\n   * Used to handle drop operations and hover effects.\n   */\n  public static dropElement: DDDroppable;\n\n  /**\n   * Reference to the element currently being resized.\n   * Helps ignore nested grid resize handles during resize operations.\n   */\n  public static overResizeElement: DDResizable;\n\n}\n","/**\n * touch.ts 12.3.0\n * Copyright (c) 2021-2025 Alain Dumesny - see GridStack root license\n */\n\nimport { DDManager } from './dd-manager';\nimport { Utils } from './utils';\n\n/**\n * Detect touch support - Windows Surface devices and other touch devices\n * should we use this instead ? (what we had for always showing resize handles)\n * /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)\n */\nexport const isTouch: boolean = typeof window !== 'undefined' && typeof document !== 'undefined' &&\n  ( 'ontouchstart' in document\n    || 'ontouchstart' in window\n    // || !!window.TouchEvent // true on Windows 10 Chrome desktop so don't use this\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    || ((window as any).DocumentTouch && document instanceof (window as any).DocumentTouch)\n    || navigator.maxTouchPoints > 0\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    || (navigator as any).msMaxTouchPoints > 0\n  );\n\n// interface TouchCoord {x: number, y: number};\n\nclass DDTouch {\n  public static touchHandled: boolean;\n  public static pointerLeaveTimeout: number;\n}\n\n/**\n* Get the x,y position of a touch event\n*/\n// function getTouchCoords(e: TouchEvent): TouchCoord {\n//   return {\n//     x: e.changedTouches[0].pageX,\n//     y: e.changedTouches[0].pageY\n//   };\n// }\n\n/**\n * Simulate a mouse event based on a corresponding touch event\n * @param {Object} e A touch event\n * @param {String} simulatedType The corresponding mouse event\n */\nfunction simulateMouseEvent(e: TouchEvent, simulatedType: string) {\n\n  // Ignore multi-touch events\n  if (e.touches.length > 1) return;\n\n  // Prevent \"Ignored attempt to cancel a touchmove event with cancelable=false\" errors\n  if (e.cancelable) e.preventDefault();\n\n  // Dispatch the simulated event to the target element\n  Utils.simulateMouseEvent(e.changedTouches[0], simulatedType);\n}\n\n/**\n * Simulate a mouse event based on a corresponding Pointer event\n * @param {Object} e A pointer event\n * @param {String} simulatedType The corresponding mouse event\n */\nfunction simulatePointerMouseEvent(e: PointerEvent, simulatedType: string) {\n\n  // Prevent \"Ignored attempt to cancel a touchmove event with cancelable=false\" errors\n  if (e.cancelable) e.preventDefault();\n\n  // Dispatch the simulated event to the target element\n  Utils.simulateMouseEvent(e, simulatedType);\n}\n\n\n/**\n * Handle the touchstart events\n * @param {Object} e The widget element's touchstart event\n */\nexport function touchstart(e: TouchEvent): void {\n  // Ignore the event if another widget is already being handled\n  if (DDTouch.touchHandled) return;\n  DDTouch.touchHandled = true;\n\n  // Simulate the mouse events\n  // simulateMouseEvent(e, 'mouseover');\n  // simulateMouseEvent(e, 'mousemove');\n  simulateMouseEvent(e, 'mousedown');\n}\n\n/**\n * Handle the touchmove events\n * @param {Object} e The document's touchmove event\n */\nexport function touchmove(e: TouchEvent): void {\n  // Ignore event if not handled by us\n  if (!DDTouch.touchHandled) return;\n\n  simulateMouseEvent(e, 'mousemove');\n}\n\n/**\n * Handle the touchend events\n * @param {Object} e The document's touchend event\n */\nexport function touchend(e: TouchEvent): void {\n\n  // Ignore event if not handled\n  if (!DDTouch.touchHandled) return;\n\n  // cancel delayed leave event when we release on ourself which happens BEFORE we get this!\n  if (DDTouch.pointerLeaveTimeout) {\n    window.clearTimeout(DDTouch.pointerLeaveTimeout);\n    delete DDTouch.pointerLeaveTimeout;\n  }\n\n  const wasDragging = !!DDManager.dragElement;\n\n  // Simulate the mouseup event\n  simulateMouseEvent(e, 'mouseup');\n  // simulateMouseEvent(event, 'mouseout');\n\n  // If the touch interaction did not move, it should trigger a click\n  if (!wasDragging) {\n    simulateMouseEvent(e, 'click');\n  }\n\n  // Unset the flag to allow other widgets to inherit the touch event\n  DDTouch.touchHandled = false;\n}\n\n/**\n * Note we don't get touchenter/touchleave (which are deprecated)\n * see https://stackoverflow.com/questions/27908339/js-touch-equivalent-for-mouseenter\n * so instead of PointerEvent to still get enter/leave and send the matching mouse event.\n */\nexport function pointerdown(e: PointerEvent): void {\n  // console.log(\"pointer down\")\n  if (e.pointerType === 'mouse') return;\n  (e.target as HTMLElement).releasePointerCapture(e.pointerId) // <- Important!\n}\n\nexport function pointerenter(e: PointerEvent): void {\n  // ignore the initial one we get on pointerdown on ourself\n  if (!DDManager.dragElement) {\n    // console.log('pointerenter ignored');\n    return;\n  }\n  // console.log('pointerenter');\n  if (e.pointerType === 'mouse') return;\n  simulatePointerMouseEvent(e, 'mouseenter');\n}\n\nexport function pointerleave(e: PointerEvent): void {\n  // ignore the leave on ourself we get before releasing the mouse over ourself\n  // by delaying sending the event and having the up event cancel us\n  if (!DDManager.dragElement) {\n    // console.log('pointerleave ignored');\n    return;\n  }\n  if (e.pointerType === 'mouse') return;\n  DDTouch.pointerLeaveTimeout = window.setTimeout(() => {\n    delete DDTouch.pointerLeaveTimeout;\n    // console.log('pointerleave delayed');\n    simulatePointerMouseEvent(e, 'mouseleave');\n  }, 10);\n}\n\n","/**\n * dd-resizable-handle.ts 12.3.0\n * Copyright (c) 2021-2025  Alain Dumesny - see GridStack root license\n */\n\nimport { isTouch, pointerdown, touchend, touchmove, touchstart } from './dd-touch';\nimport { GridItemHTMLElement } from './gridstack';\n\nexport interface DDResizableHandleOpt {\n  start?: (event) => void;\n  move?: (event) => void;\n  stop?: (event) => void;\n}\n\nexport class DDResizableHandle {\n  /** @internal */\n  protected el: HTMLElement;\n  /** @internal true after we've moved enough pixels to start a resize */\n  protected moving = false;\n  /** @internal */\n  protected mouseDownEvent: MouseEvent;\n  /** @internal */\n  protected static prefix = 'ui-resizable-';\n\n  constructor(protected host: GridItemHTMLElement, protected dir: string, protected option: DDResizableHandleOpt) {\n    // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n    this._mouseDown = this._mouseDown.bind(this);\n    this._mouseMove = this._mouseMove.bind(this);\n    this._mouseUp = this._mouseUp.bind(this);\n    this._keyEvent = this._keyEvent.bind(this);\n\n    this._init();\n  }\n\n  /** @internal */\n  protected _init(): DDResizableHandle {\n    const el = this.el = document.createElement('div');\n    el.classList.add('ui-resizable-handle');\n    el.classList.add(`${DDResizableHandle.prefix}${this.dir}`);\n    el.style.zIndex = '100';\n    el.style.userSelect = 'none';\n    this.host.appendChild(this.el);\n    this.el.addEventListener('mousedown', this._mouseDown);\n    if (isTouch) {\n      this.el.addEventListener('touchstart', touchstart);\n      this.el.addEventListener('pointerdown', pointerdown);\n      // this.el.style.touchAction = 'none'; // not needed unlike pointerdown doc comment\n    }\n    return this;\n  }\n\n  /** call this when resize handle needs to be removed and cleaned up */\n  public destroy(): DDResizableHandle {\n    if (this.moving) this._mouseUp(this.mouseDownEvent);\n    this.el.removeEventListener('mousedown', this._mouseDown);\n    if (isTouch) {\n      this.el.removeEventListener('touchstart', touchstart);\n      this.el.removeEventListener('pointerdown', pointerdown);\n    }\n    this.host.removeChild(this.el);\n    delete this.el;\n    delete this.host;\n    return this;\n  }\n\n  /** @internal called on mouse down on us: capture move on the entire document (mouse might not stay on us) until we release the mouse */\n  protected _mouseDown(e: MouseEvent): void {\n    this.mouseDownEvent = e;\n    document.addEventListener('mousemove', this._mouseMove, { capture: true, passive: true}); // capture, not bubble\n    document.addEventListener('mouseup', this._mouseUp, true);\n    if (isTouch) {\n      this.el.addEventListener('touchmove', touchmove);\n      this.el.addEventListener('touchend', touchend);\n    }\n    e.stopPropagation();\n    e.preventDefault();\n  }\n\n  /** @internal */\n  protected _mouseMove(e: MouseEvent): void {\n    const s = this.mouseDownEvent;\n    if (this.moving) {\n      this._triggerEvent('move', e);\n    } else if (Math.abs(e.x - s.x) + Math.abs(e.y - s.y) > 2) {\n      // don't start unless we've moved at least 3 pixels\n      this.moving = true;\n      this._triggerEvent('start', this.mouseDownEvent);\n      this._triggerEvent('move', e);\n      // now track keyboard events to cancel\n      document.addEventListener('keydown', this._keyEvent);\n    }\n    e.stopPropagation();\n    // e.preventDefault(); passive = true\n  }\n\n  /** @internal */\n  protected _mouseUp(e: MouseEvent): void {\n    if (this.moving) {\n      this._triggerEvent('stop', e);\n      document.removeEventListener('keydown', this._keyEvent);\n    }\n    document.removeEventListener('mousemove', this._mouseMove, true);\n    document.removeEventListener('mouseup', this._mouseUp, true);\n    if (isTouch) {\n      this.el.removeEventListener('touchmove', touchmove);\n      this.el.removeEventListener('touchend', touchend);\n    }\n    delete this.moving;\n    delete this.mouseDownEvent;\n    e.stopPropagation();\n    e.preventDefault();\n  }\n\n  /** @internal call when keys are being pressed - use Esc to cancel */\n  protected _keyEvent(e: KeyboardEvent): void {\n    if (e.key === 'Escape') {\n      this.host.gridstackNode?.grid?.engine.restoreInitial();\n      this._mouseUp(this.mouseDownEvent);\n    }\n  }\n\n\n\n  /** @internal */\n  protected _triggerEvent(name: string, event: MouseEvent): DDResizableHandle {\n    if (this.option[name]) this.option[name](event);\n    return this;\n  }\n}\n","/**\n * dd-base-impl.ts 12.3.0\n * Copyright (c) 2021-2025  Alain Dumesny - see GridStack root license\n */\n\n/**\n * Type for event callback functions used in drag & drop operations.\n * Can return boolean to indicate if the event should continue propagation.\n */\nexport type EventCallback = (event: Event) => boolean|void;\n\n/**\n * Abstract base class for all drag & drop implementations.\n * Provides common functionality for event handling, enable/disable state,\n * and lifecycle management used by draggable, droppable, and resizable implementations.\n */\nexport abstract class DDBaseImplement {\n  /**\n   * Returns the current disabled state.\n   * Note: Use enable()/disable() methods to change state as other operations need to happen.\n   */\n  public get disabled(): boolean   { return this._disabled; }\n\n  /** @internal */\n  protected _disabled: boolean; // initial state to differentiate from false\n  /** @internal */\n  protected _eventRegister: {\n    [eventName: string]: EventCallback;\n  } = {};\n\n  /**\n   * Register an event callback for the specified event.\n   * \n   * @param event - Event name to listen for\n   * @param callback - Function to call when event occurs\n   */\n  public on(event: string, callback: EventCallback): void {\n    this._eventRegister[event] = callback;\n  }\n\n  /**\n   * Unregister an event callback for the specified event.\n   * \n   * @param event - Event name to stop listening for\n   */\n  public off(event: string): void {\n    delete this._eventRegister[event];\n  }\n\n  /**\n   * Enable this drag & drop implementation.\n   * Subclasses should override to perform additional setup.\n   */\n  public enable(): void {\n    this._disabled = false;\n  }\n\n  /**\n   * Disable this drag & drop implementation.\n   * Subclasses should override to perform additional cleanup.\n   */\n  public disable(): void {\n    this._disabled = true;\n  }\n\n  /**\n   * Destroy this drag & drop implementation and clean up resources.\n   * Removes all event handlers and clears internal state.\n   */\n  public destroy(): void {\n    delete this._eventRegister;\n  }\n\n  /**\n   * Trigger a registered event callback if one exists and the implementation is enabled.\n   * \n   * @param eventName - Name of the event to trigger\n   * @param event - DOM event object to pass to the callback\n   * @returns Result from the callback function, if any\n   */\n  public triggerEvent(eventName: string, event: Event): boolean|void {\n    if (!this.disabled && this._eventRegister && this._eventRegister[eventName])\n      return this._eventRegister[eventName](event);\n  }\n}\n\n/**\n * Interface for HTML elements extended with drag & drop options.\n * Used to associate DD configuration with DOM elements.\n */\nexport interface HTMLElementExtendOpt<T> {\n  /** The HTML element being extended */\n  el: HTMLElement;\n  /** The drag & drop options/configuration */\n  option: T;\n  /** Method to update the options and return the DD implementation */\n  updateOption(T): DDBaseImplement;\n}\n","/**\n * dd-resizable.ts 12.3.0\n * Copyright (c) 2021-2025  Alain Dumesny - see GridStack root license\n */\n\nimport { DDResizableHandle } from './dd-resizable-handle';\nimport { DDBaseImplement, HTMLElementExtendOpt } from './dd-base-impl';\nimport { Utils } from './utils';\nimport { DDUIData, GridItemHTMLElement, Rect, Size } from './types';\nimport { DDManager } from './dd-manager';\n\n// import { GridItemHTMLElement } from './types'; let count = 0; // TEST\n\n// TODO: merge with DDDragOpt\nexport interface DDResizableOpt {\n  autoHide?: boolean;\n  handles?: string;\n  maxHeight?: number;\n  maxHeightMoveUp?: number;\n  maxWidth?: number;\n  maxWidthMoveLeft?: number;\n  minHeight?: number;\n  minWidth?: number;\n  start?: (event: Event, ui: DDUIData) => void;\n  stop?: (event: Event) => void;\n  resize?: (event: Event, ui: DDUIData) => void;\n}\n\ninterface RectScaleReciprocal {\n  x: number;\n  y: number;\n}\n\nexport class DDResizable extends DDBaseImplement implements HTMLElementExtendOpt<DDResizableOpt> {\n  /** @internal */\n  protected handlers: DDResizableHandle[];\n  /** @internal */\n  protected originalRect: Rect;\n  /** @internal */\n  protected rectScale: RectScaleReciprocal = { x: 1, y: 1 };\n  /** @internal */\n  protected temporalRect: Rect;\n  /** @internal */\n  protected scrollY: number;\n  /** @internal */\n  protected scrolled: number;\n  /** @internal */\n  protected scrollEl: HTMLElement;\n  /** @internal */\n  protected startEvent: MouseEvent;\n  /** @internal value saved in the same order as _originStyleProp[] */\n  protected elOriginStyleVal: string[];\n  /** @internal */\n  protected parentOriginStylePosition: string;\n  /** @internal */\n  protected static _originStyleProp = ['width', 'height', 'position', 'left', 'top', 'opacity', 'zIndex'];\n  /** @internal */\n  protected sizeToContent: boolean;\n\n  // have to be public else complains for HTMLElementExtendOpt ?\n  constructor(public el: GridItemHTMLElement, public option: DDResizableOpt = {}) {\n    super();\n    // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n    this._mouseOver = this._mouseOver.bind(this);\n    this._mouseOut = this._mouseOut.bind(this);\n    this.enable();\n    this._setupAutoHide(this.option.autoHide);\n    this._setupHandlers();\n  }\n\n  public on(event: 'resizestart' | 'resize' | 'resizestop', callback: (event: DragEvent) => void): void {\n    super.on(event, callback);\n  }\n\n  public off(event: 'resizestart' | 'resize' | 'resizestop'): void {\n    super.off(event);\n  }\n\n  public enable(): void {\n    super.enable();\n    this.el.classList.remove('ui-resizable-disabled');\n    this._setupAutoHide(this.option.autoHide);\n  }\n\n  public disable(): void {\n    super.disable();\n    this.el.classList.add('ui-resizable-disabled');\n    this._setupAutoHide(false);\n  }\n\n  public destroy(): void {\n    this._removeHandlers();\n    this._setupAutoHide(false);\n    delete this.el;\n    super.destroy();\n  }\n\n  public updateOption(opts: DDResizableOpt): DDResizable {\n    const updateHandles = (opts.handles && opts.handles !== this.option.handles);\n    const updateAutoHide = (opts.autoHide && opts.autoHide !== this.option.autoHide);\n    Object.keys(opts).forEach(key => this.option[key] = opts[key]);\n    if (updateHandles) {\n      this._removeHandlers();\n      this._setupHandlers();\n    }\n    if (updateAutoHide) {\n      this._setupAutoHide(this.option.autoHide);\n    }\n    return this;\n  }\n\n  /** @internal turns auto hide on/off */\n  protected _setupAutoHide(auto: boolean): DDResizable {\n    if (auto) {\n      this.el.classList.add('ui-resizable-autohide');\n      // use mouseover and not mouseenter to get better performance and track for nested cases\n      this.el.addEventListener('mouseover', this._mouseOver);\n      this.el.addEventListener('mouseout', this._mouseOut);\n    } else {\n      this.el.classList.remove('ui-resizable-autohide');\n      this.el.removeEventListener('mouseover', this._mouseOver);\n      this.el.removeEventListener('mouseout', this._mouseOut);\n      if (DDManager.overResizeElement === this) {\n        delete DDManager.overResizeElement;\n      }\n    }\n    return this;\n  }\n\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected _mouseOver(e: Event): void {\n    // console.log(`${count++} pre-enter ${(this.el as GridItemHTMLElement).gridstackNode._id}`)\n    // already over a child, ignore. Ideally we just call e.stopPropagation() but see https://github.com/gridstack/gridstack.js/issues/2018\n    if (DDManager.overResizeElement || DDManager.dragElement) return;\n    DDManager.overResizeElement = this;\n    // console.log(`${count++} enter ${(this.el as GridItemHTMLElement).gridstackNode._id}`)\n    this.el.classList.remove('ui-resizable-autohide');\n  }\n\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected _mouseOut(e: Event): void {\n    // console.log(`${count++} pre-leave ${(this.el as GridItemHTMLElement).gridstackNode._id}`)\n    if (DDManager.overResizeElement !== this) return;\n    delete DDManager.overResizeElement;\n    // console.log(`${count++} leave ${(this.el as GridItemHTMLElement).gridstackNode._id}`)\n    this.el.classList.add('ui-resizable-autohide');\n  }\n\n  /** @internal */\n  protected _setupHandlers(): DDResizable {\n    this.handlers = this.option.handles.split(',')\n      .map(dir => dir.trim())\n      .map(dir => new DDResizableHandle(this.el, dir, {\n        start: (event: MouseEvent) => {\n          this._resizeStart(event);\n        },\n        stop: (event: MouseEvent) => {\n          this._resizeStop(event);\n        },\n        move: (event: MouseEvent) => {\n          this._resizing(event, dir);\n        }\n      }));\n    return this;\n  }\n\n  /** @internal */\n  protected _resizeStart(event: MouseEvent): DDResizable {\n    this.sizeToContent = Utils.shouldSizeToContent(this.el.gridstackNode, true); // strick true only and not number\n    this.originalRect = this.el.getBoundingClientRect();\n    this.scrollEl = Utils.getScrollElement(this.el);\n    this.scrollY = this.scrollEl.scrollTop;\n    this.scrolled = 0;\n    this.startEvent = event;\n    this._setupHelper();\n    this._applyChange();\n    const ev = Utils.initEvent<MouseEvent>(event, { type: 'resizestart', target: this.el });\n    if (this.option.start) {\n      this.option.start(ev, this._ui());\n    }\n    this.el.classList.add('ui-resizable-resizing');\n    this.triggerEvent('resizestart', ev);\n    return this;\n  }\n\n  /** @internal */\n  protected _resizing(event: MouseEvent, dir: string): DDResizable {\n    this.scrolled = this.scrollEl.scrollTop - this.scrollY;\n    this.temporalRect = this._getChange(event, dir);\n    this._applyChange();\n    const ev = Utils.initEvent<MouseEvent>(event, { type: 'resize', target: this.el });\n    if (this.option.resize) {\n      this.option.resize(ev, this._ui());\n    }\n    this.triggerEvent('resize', ev);\n    return this;\n  }\n\n  /** @internal */\n  protected _resizeStop(event: MouseEvent): DDResizable {\n    const ev = Utils.initEvent<MouseEvent>(event, { type: 'resizestop', target: this.el });\n    // Remove style attr now, so the stop handler can rebuild style attrs\n    this._cleanHelper();\n    if (this.option.stop) {\n      this.option.stop(ev); // Note: ui() not used by gridstack so don't pass\n    }\n    this.el.classList.remove('ui-resizable-resizing');\n    this.triggerEvent('resizestop', ev);\n    delete this.startEvent;\n    delete this.originalRect;\n    delete this.temporalRect;\n    delete this.scrollY;\n    delete this.scrolled;\n    return this;\n  }\n\n  /** @internal */\n  protected _setupHelper(): DDResizable {\n    this.elOriginStyleVal = DDResizable._originStyleProp.map(prop => this.el.style[prop]);\n    this.parentOriginStylePosition = this.el.parentElement.style.position;\n\n    const parent = this.el.parentElement;\n    const dragTransform = Utils.getValuesFromTransformedElement(parent);\n    this.rectScale = {\n      x: dragTransform.xScale,\n      y: dragTransform.yScale\n    };\n\n    if (getComputedStyle(this.el.parentElement).position.match(/static/)) {\n      this.el.parentElement.style.position = 'relative';\n    }\n    this.el.style.position = 'absolute';\n    this.el.style.opacity = '0.8';\n    return this;\n  }\n\n  /** @internal */\n  protected _cleanHelper(): DDResizable {\n    DDResizable._originStyleProp.forEach((prop, i) => {\n      this.el.style[prop] = this.elOriginStyleVal[i] || null;\n    });\n    this.el.parentElement.style.position = this.parentOriginStylePosition || null;\n    return this;\n  }\n\n  /** @internal */\n  protected _getChange(event: MouseEvent, dir: string): Rect {\n    const oEvent = this.startEvent;\n    const newRect = { // Note: originalRect is a complex object, not a simple Rect, so copy out.\n      width: this.originalRect.width,\n      height: this.originalRect.height + this.scrolled,\n      left: this.originalRect.left,\n      top: this.originalRect.top - this.scrolled\n    };\n\n    const offsetX = event.clientX - oEvent.clientX;\n    const offsetY = this.sizeToContent ? 0 : event.clientY - oEvent.clientY; // prevent vert resize\n    let moveLeft: boolean;\n    let moveUp: boolean;\n\n    if (dir.indexOf('e') > -1) {\n      newRect.width += offsetX;\n    } else if (dir.indexOf('w') > -1) {\n      newRect.width -= offsetX;\n      newRect.left += offsetX;\n      moveLeft = true;\n    }\n    if (dir.indexOf('s') > -1) {\n      newRect.height += offsetY;\n    } else if (dir.indexOf('n') > -1) {\n      newRect.height -= offsetY;\n      newRect.top += offsetY\n      moveUp = true;\n    }\n    const constrain = this._constrainSize(newRect.width, newRect.height, moveLeft, moveUp);\n    if (Math.round(newRect.width) !== Math.round(constrain.width)) { // round to ignore slight round-off errors\n      if (dir.indexOf('w') > -1) {\n        newRect.left += newRect.width - constrain.width;\n      }\n      newRect.width = constrain.width;\n    }\n    if (Math.round(newRect.height) !== Math.round(constrain.height)) {\n      if (dir.indexOf('n') > -1) {\n        newRect.top += newRect.height - constrain.height;\n      }\n      newRect.height = constrain.height;\n    }\n    return newRect;\n  }\n\n  /** @internal constrain the size to the set min/max values */\n  protected _constrainSize(oWidth: number, oHeight: number, moveLeft: boolean, moveUp: boolean): Size {\n    const o = this.option;\n    const maxWidth = (moveLeft ? o.maxWidthMoveLeft : o.maxWidth) || Number.MAX_SAFE_INTEGER;\n    const minWidth = o.minWidth / this.rectScale.x || oWidth;\n    const maxHeight = (moveUp ? o.maxHeightMoveUp : o.maxHeight) || Number.MAX_SAFE_INTEGER;\n    const minHeight = o.minHeight / this.rectScale.y || oHeight;\n    const width = Math.min(maxWidth, Math.max(minWidth, oWidth));\n    const height = Math.min(maxHeight, Math.max(minHeight, oHeight));\n    return { width, height };\n  }\n\n  /** @internal */\n  protected _applyChange(): DDResizable {\n    let containmentRect = { left: 0, top: 0, width: 0, height: 0 };\n    if (this.el.style.position === 'absolute') {\n      const containmentEl = this.el.parentElement;\n      const { left, top } = containmentEl.getBoundingClientRect();\n      containmentRect = { left, top, width: 0, height: 0 };\n    }\n    if (!this.temporalRect) return this;\n    Object.keys(this.temporalRect).forEach(key => {\n      const value = this.temporalRect[key];\n      const scaleReciprocal = key === 'width' || key === 'left' ? this.rectScale.x : key === 'height' || key === 'top' ? this.rectScale.y : 1;\n      this.el.style[key] = (value - containmentRect[key]) * scaleReciprocal + 'px';\n    });\n    return this;\n  }\n\n  /** @internal */\n  protected _removeHandlers(): DDResizable {\n    this.handlers.forEach(handle => handle.destroy());\n    delete this.handlers;\n    return this;\n  }\n\n  /** @internal */\n  protected _ui = (): DDUIData => {\n    const containmentEl = this.el.parentElement;\n    const containmentRect = containmentEl.getBoundingClientRect();\n    const newRect = { // Note: originalRect is a complex object, not a simple Rect, so copy out.\n      width: this.originalRect.width,\n      height: this.originalRect.height + this.scrolled,\n      left: this.originalRect.left,\n      top: this.originalRect.top - this.scrolled\n    };\n    const rect = this.temporalRect || newRect;\n    return {\n      position: {\n        left: (rect.left - containmentRect.left) * this.rectScale.x,\n        top: (rect.top - containmentRect.top) * this.rectScale.y\n      },\n      size: {\n        width: rect.width * this.rectScale.x,\n        height: rect.height * this.rectScale.y\n      }\n      /* Gridstack ONLY needs position set above... keep around in case.\n      element: [this.el], // The object representing the element to be resized\n      helper: [], // TODO: not support yet - The object representing the helper that's being resized\n      originalElement: [this.el],// we don't wrap here, so simplify as this.el //The object representing the original element before it is wrapped\n      originalPosition: { // The position represented as { left, top } before the resizable is resized\n        left: this.originalRect.left - containmentRect.left,\n        top: this.originalRect.top - containmentRect.top\n      },\n      originalSize: { // The size represented as { width, height } before the resizable is resized\n        width: this.originalRect.width,\n        height: this.originalRect.height\n      }\n      */\n    };\n  }\n}\n","/**\n * dd-draggable.ts 12.3.0\n * Copyright (c) 2021-2025  Alain Dumesny - see GridStack root license\n */\n\nimport { DDManager } from './dd-manager';\nimport { DragTransform, Utils } from './utils';\nimport { DDBaseImplement, HTMLElementExtendOpt } from './dd-base-impl';\nimport { GridItemHTMLElement, DDUIData, GridStackNode, GridStackPosition, DDDragOpt } from './types';\nimport { DDElementHost } from './dd-element';\nimport { isTouch, touchend, touchmove, touchstart, pointerdown } from './dd-touch';\nimport { GridHTMLElement } from './gridstack';\n\ninterface DragOffset {\n  left: number;\n  top: number;\n  width: number;\n  height: number;\n  offsetLeft: number;\n  offsetTop: number;\n}\n\ninterface GridStackNodeRotate extends GridStackNode {\n  _origRotate?: GridStackPosition;\n}\n\ntype DDDragEvent = 'drag' | 'dragstart' | 'dragstop';\n\n// make sure we are not clicking on known object that handles mouseDown\nconst skipMouseDown = 'input,textarea,button,select,option,[contenteditable=\"true\"],.ui-resizable-handle';\n\n// let count = 0; // TEST\n\nexport class DDDraggable extends DDBaseImplement implements HTMLElementExtendOpt<DDDragOpt> {\n  public helper: HTMLElement; // used by GridStackDDNative\n\n  /** @internal */\n  protected mouseDownEvent: MouseEvent;\n  /** @internal */\n  protected dragOffset: DragOffset;\n  /** @internal */\n  protected dragElementOriginStyle: Array<string>;\n  /** @internal */\n  protected dragEls: HTMLElement[];\n  /** @internal true while we are dragging an item around */\n  protected dragging: boolean;\n  /** @internal last drag event */\n  protected lastDrag: DragEvent;\n  /** @internal */\n  protected parentOriginStylePosition: string;\n  /** @internal */\n  protected helperContainment: HTMLElement;\n  /** @internal properties we change during dragging, and restore back */\n  protected static originStyleProp = ['width', 'height', 'transform', 'transform-origin', 'transition', 'pointerEvents', 'position', 'left', 'top', 'minWidth', 'willChange'];\n  /** @internal pause before we call the actual drag hit collision code */\n  protected dragTimeout: number;\n  /** @internal */\n  protected dragTransform: DragTransform = {\n    xScale: 1,\n    yScale: 1,\n    xOffset: 0,\n    yOffset: 0\n  };\n\n  constructor(public el: GridItemHTMLElement, public option: DDDragOpt = {}) {\n    super();\n\n    // get the element that is actually supposed to be dragged by\n    const handleName = option?.handle?.substring(1);\n    const n = el.gridstackNode;\n    this.dragEls = !handleName || el.classList.contains(handleName) ? [el] : (n?.subGrid ? [el.querySelector(option.handle) || el] : Array.from(el.querySelectorAll(option.handle)));\n    if (this.dragEls.length === 0) {\n      this.dragEls = [el];\n    }\n    // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n    this._mouseDown = this._mouseDown.bind(this);\n    this._mouseMove = this._mouseMove.bind(this);\n    this._mouseUp = this._mouseUp.bind(this);\n    this._keyEvent = this._keyEvent.bind(this);\n    this.enable();\n  }\n\n  public on(event: DDDragEvent, callback: (event: DragEvent) => void): void {\n    super.on(event, callback);\n  }\n\n  public off(event: DDDragEvent): void {\n    super.off(event);\n  }\n\n  public enable(): void {\n    if (this.disabled === false) return;\n    super.enable();\n    this.dragEls.forEach(dragEl => {\n      dragEl.addEventListener('mousedown', this._mouseDown);\n      if (isTouch) {\n        dragEl.addEventListener('touchstart', touchstart);\n        dragEl.addEventListener('pointerdown', pointerdown);\n        // dragEl.style.touchAction = 'none'; // not needed unlike pointerdown doc comment\n      }\n    });\n    this.el.classList.remove('ui-draggable-disabled');\n  }\n\n  public disable(forDestroy = false): void {\n    if (this.disabled === true) return;\n    super.disable();\n    this.dragEls.forEach(dragEl => {\n      dragEl.removeEventListener('mousedown', this._mouseDown);\n      if (isTouch) {\n        dragEl.removeEventListener('touchstart', touchstart);\n        dragEl.removeEventListener('pointerdown', pointerdown);\n      }\n    });\n    if (!forDestroy) this.el.classList.add('ui-draggable-disabled');\n  }\n\n  public destroy(): void {\n    if (this.dragTimeout) window.clearTimeout(this.dragTimeout);\n    delete this.dragTimeout;\n    if (this.mouseDownEvent) this._mouseUp(this.mouseDownEvent);\n    this.disable(true);\n    delete this.el;\n    delete this.helper;\n    delete this.option;\n    super.destroy();\n  }\n\n  public updateOption(opts: DDDragOpt): DDDraggable {\n    Object.keys(opts).forEach(key => this.option[key] = opts[key]);\n    return this;\n  }\n\n  /** @internal call when mouse goes down before a dragstart happens */\n  protected _mouseDown(e: MouseEvent): boolean {\n    // don't let more than one widget handle mouseStart\n    if (DDManager.mouseHandled) return;\n    if (e.button !== 0) return true; // only left click\n\n    // make sure we are not clicking on known object that handles mouseDown, or ones supplied by the user\n    if (!this.dragEls.find(el => el === e.target) && (e.target as HTMLElement).closest(skipMouseDown)) return true;\n    if (this.option.cancel) {\n      if ((e.target as HTMLElement).closest(this.option.cancel)) return true;\n    }\n\n    this.mouseDownEvent = e;\n    delete this.dragging;\n    delete DDManager.dragElement;\n    delete DDManager.dropElement;\n    // document handler so we can continue receiving moves as the item is 'fixed' position, and capture=true so WE get a first crack\n    document.addEventListener('mousemove', this._mouseMove, { capture: true, passive: true }); // true=capture, not bubble\n    document.addEventListener('mouseup', this._mouseUp, true);\n    if (isTouch) {\n      e.currentTarget.addEventListener('touchmove', touchmove);\n      e.currentTarget.addEventListener('touchend', touchend);\n    }\n\n    e.preventDefault();\n    // preventDefault() prevents blur event which occurs just after mousedown event.\n    // if an editable content has focus, then blur must be call\n    if (document.activeElement) (document.activeElement as HTMLElement).blur();\n\n    DDManager.mouseHandled = true;\n    return true;\n  }\n\n  /** @internal method to call actual drag event */\n  protected _callDrag(e: DragEvent): void {\n    if (!this.dragging) return;\n    const ev = Utils.initEvent<DragEvent>(e, { target: this.el, type: 'drag' });\n    if (this.option.drag) {\n      this.option.drag(ev, this.ui());\n    }\n    this.triggerEvent('drag', ev);\n  }\n\n  /** @internal called when the main page (after successful mousedown) receives a move event to drag the item around the screen */\n  protected _mouseMove(e: DragEvent): boolean {\n    // console.log(`${count++} move ${e.x},${e.y}`)\n    const s = this.mouseDownEvent;\n    this.lastDrag = e;\n\n    if (this.dragging) {\n      this._dragFollow(e);\n      // delay actual grid handling drag until we pause for a while if set\n      if (DDManager.pauseDrag) {\n        const pause = Number.isInteger(DDManager.pauseDrag) ? DDManager.pauseDrag as number : 100;\n        if (this.dragTimeout) window.clearTimeout(this.dragTimeout);\n        this.dragTimeout = window.setTimeout(() => this._callDrag(e), pause);\n      } else {\n        this._callDrag(e);\n      }\n    } else if (Math.abs(e.x - s.x) + Math.abs(e.y - s.y) > 3) {\n      /**\n       * don't start unless we've moved at least 3 pixels\n       */\n      this.dragging = true;\n      DDManager.dragElement = this;\n      // if we're dragging an actual grid item, set the current drop as the grid (to detect enter/leave)\n      const grid = this.el.gridstackNode?.grid;\n      if (grid) {\n        DDManager.dropElement = (grid.el as DDElementHost).ddElement.ddDroppable;\n      } else {\n        delete DDManager.dropElement;\n      }\n      this.helper = this._createHelper();\n      this._setupHelperContainmentStyle();\n      this.dragTransform = Utils.getValuesFromTransformedElement(this.helperContainment);\n      this.dragOffset = this._getDragOffset(e, this.el, this.helperContainment);\n      this._setupHelperStyle(e);\n\n      const ev = Utils.initEvent<DragEvent>(e, { target: this.el, type: 'dragstart' });\n      if (this.option.start) {\n        this.option.start(ev, this.ui());\n      }\n      this.triggerEvent('dragstart', ev);\n      // now track keyboard events to cancel or rotate\n      document.addEventListener('keydown', this._keyEvent);\n    }\n    // e.preventDefault(); // passive = true. OLD: was needed otherwise we get text sweep text selection as we drag around\n    return true;\n  }\n\n  /** @internal call when the mouse gets released to drop the item at current location */\n  protected _mouseUp(e: MouseEvent): void {\n    document.removeEventListener('mousemove', this._mouseMove, true);\n    document.removeEventListener('mouseup', this._mouseUp, true);\n    if (isTouch && e.currentTarget) { // destroy() during nested grid call us again wit fake _mouseUp\n      e.currentTarget.removeEventListener('touchmove', touchmove, true);\n      e.currentTarget.removeEventListener('touchend', touchend, true);\n    }\n    if (this.dragging) {\n      delete this.dragging;\n      delete (this.el.gridstackNode as GridStackNodeRotate)?._origRotate;\n      document.removeEventListener('keydown', this._keyEvent);\n\n      // reset the drop target if dragging over ourself (already parented, just moving during stop callback below)\n      if (DDManager.dropElement?.el === this.el.parentElement) {\n        delete DDManager.dropElement;\n      }\n\n      this.helperContainment.style.position = this.parentOriginStylePosition || null;\n      if (this.helper !== this.el) this.helper.remove(); // hide now\n      this._removeHelperStyle();\n\n      const ev = Utils.initEvent<DragEvent>(e, { target: this.el, type: 'dragstop' });\n      if (this.option.stop) {\n        this.option.stop(ev); // NOTE: destroy() will be called when removing item, so expect NULL ptr after!\n      }\n      this.triggerEvent('dragstop', ev);\n\n      // call the droppable method to receive the item\n      if (DDManager.dropElement) {\n        DDManager.dropElement.drop(e);\n      }\n    }\n    delete this.helper;\n    delete this.mouseDownEvent;\n    delete DDManager.dragElement;\n    delete DDManager.dropElement;\n    delete DDManager.mouseHandled;\n    e.preventDefault();\n  }\n\n  /** @internal call when keys are being pressed - use Esc to cancel, R to rotate */\n  protected _keyEvent(e: KeyboardEvent): void {\n    const n = this.el.gridstackNode as GridStackNodeRotate;\n    const grid = n?.grid || (DDManager.dropElement?.el as GridHTMLElement)?.gridstack;\n\n    if (e.key === 'Escape') {\n      if (n && n._origRotate) {\n        n._orig = n._origRotate;\n        delete n._origRotate;\n      }\n      grid?.cancelDrag();\n      this._mouseUp(this.mouseDownEvent);\n    } else if (n && grid && (e.key === 'r' || e.key === 'R')) {\n      if (!Utils.canBeRotated(n)) return;\n      n._origRotate = n._origRotate || { ...n._orig }; // store the real orig size in case we Esc after doing rotation\n      delete n._moving; // force rotate to happen (move waits for >50% coverage otherwise)\n      grid.setAnimation(false) // immediate rotate so _getDragOffset() gets the right dom size below\n        .rotate(n.el, { top: -this.dragOffset.offsetTop, left: -this.dragOffset.offsetLeft })\n        .setAnimation();\n      n._moving = true;\n      this.dragOffset = this._getDragOffset(this.lastDrag, n.el, this.helperContainment);\n      this.helper.style.width = this.dragOffset.width + 'px';\n      this.helper.style.height = this.dragOffset.height + 'px';\n      Utils.swap(n._orig, 'w', 'h');\n      delete n._rect;\n      this._mouseMove(this.lastDrag);\n    }\n  }\n\n  /** @internal create a clone copy (or user defined method) of the original drag item if set */\n  protected _createHelper(): HTMLElement {\n    let helper = this.el;\n    if (typeof this.option.helper === 'function') {\n      helper = this.option.helper(this.el);\n    } else if (this.option.helper === 'clone') {\n      helper = Utils.cloneNode(this.el);\n    }\n    if (!helper.parentElement) {\n      Utils.appendTo(helper, this.option.appendTo === 'parent' ? this.el.parentElement : this.option.appendTo);\n    }\n    this.dragElementOriginStyle = DDDraggable.originStyleProp.map(prop => this.el.style[prop]);\n    return helper;\n  }\n\n  /** @internal set the fix position of the dragged item */\n  protected _setupHelperStyle(e: DragEvent): DDDraggable {\n    this.helper.classList.add('ui-draggable-dragging');\n    this.el.gridstackNode?.grid?.el.classList.add('grid-stack-dragging');\n    // TODO: set all at once with style.cssText += ... ? https://stackoverflow.com/questions/3968593\n    const style = this.helper.style;\n    style.pointerEvents = 'none'; // needed for over items to get enter/leave\n    // style.cursor = 'move'; //  TODO: can't set with pointerEvents=none ! (no longer in CSS either as no-op)\n    style.width = this.dragOffset.width + 'px';\n    style.height = this.dragOffset.height + 'px';\n    style.willChange = 'left, top';\n    style.position = 'fixed'; // let us drag between grids by not clipping as parent .grid-stack is position: 'relative'\n    this._dragFollow(e); // now position it\n    style.transition = 'none'; // show up instantly\n    setTimeout(() => {\n      if (this.helper) {\n        style.transition = null; // recover animation\n      }\n    }, 0);\n    return this;\n  }\n\n  /** @internal restore back the original style before dragging */\n  protected _removeHelperStyle(): DDDraggable {\n    this.helper.classList.remove('ui-draggable-dragging');\n    this.el.gridstackNode?.grid?.el.classList.remove('grid-stack-dragging');\n    const node = (this.helper as GridItemHTMLElement)?.gridstackNode;\n    // don't bother restoring styles if we're gonna remove anyway...\n    if (!node?._isAboutToRemove && this.dragElementOriginStyle) {\n      const helper = this.helper;\n      // don't animate, otherwise we animate offseted when switching back to 'absolute' from 'fixed'.\n      // TODO: this also removes resizing animation which doesn't have this issue, but others.\n      // Ideally both would animate ('move' would immediately restore 'absolute' and adjust coordinate to match,\n      // then trigger a delay (repaint) to restore to final dest with animate) but then we need to make sure 'resizestop'\n      // is called AFTER 'transitionend' event is received (see https://github.com/gridstack/gridstack.js/issues/2033)\n      const transition = this.dragElementOriginStyle['transition'] || null;\n      helper.style.transition = this.dragElementOriginStyle['transition'] = 'none'; // can't be NULL #1973\n      DDDraggable.originStyleProp.forEach(prop => helper.style[prop] = this.dragElementOriginStyle[prop] || null);\n      setTimeout(() => helper.style.transition = transition, 50); // recover animation from saved vars after a pause (0 isn't enough #1973)\n    }\n    delete this.dragElementOriginStyle;\n    return this;\n  }\n\n  /** @internal updates the top/left position to follow the mouse */\n  protected _dragFollow(e: DragEvent): void {\n    const containmentRect = { left: 0, top: 0 };\n    // if (this.helper.style.position === 'absolute') { // we use 'fixed'\n    //   const { left, top } = this.helperContainment.getBoundingClientRect();\n    //   containmentRect = { left, top };\n    // }\n    const style = this.helper.style;\n    const offset = this.dragOffset;\n    style.left = (e.clientX + offset.offsetLeft - containmentRect.left) * this.dragTransform.xScale + 'px';\n    style.top = (e.clientY + offset.offsetTop - containmentRect.top) * this.dragTransform.yScale + 'px';\n  }\n\n  /** @internal */\n  protected _setupHelperContainmentStyle(): DDDraggable {\n    this.helperContainment = this.helper.parentElement;\n    if (this.helper.style.position !== 'fixed') {\n      this.parentOriginStylePosition = this.helperContainment.style.position;\n      if (getComputedStyle(this.helperContainment).position.match(/static/)) {\n        this.helperContainment.style.position = 'relative';\n      }\n    }\n    return this;\n  }\n\n  /** @internal */\n  protected _getDragOffset(event: DragEvent, el: HTMLElement, parent: HTMLElement): DragOffset {\n\n    // in case ancestor has transform/perspective css properties that change the viewpoint\n    let xformOffsetX = 0;\n    let xformOffsetY = 0;\n    if (parent) {\n      xformOffsetX = this.dragTransform.xOffset;\n      xformOffsetY = this.dragTransform.yOffset;\n    }\n\n    const targetOffset = el.getBoundingClientRect();\n    return {\n      left: targetOffset.left,\n      top: targetOffset.top,\n      offsetLeft: - event.clientX + targetOffset.left - xformOffsetX,\n      offsetTop: - event.clientY + targetOffset.top - xformOffsetY,\n      width: targetOffset.width * this.dragTransform.xScale,\n      height: targetOffset.height * this.dragTransform.yScale\n    };\n  }\n\n  /** @internal TODO: set to public as called by DDDroppable! */\n  public ui(): DDUIData {\n    const containmentEl = this.el.parentElement;\n    const containmentRect = containmentEl.getBoundingClientRect();\n    const offset = this.helper.getBoundingClientRect();\n    return {\n      position: { //Current CSS position of the helper as { top, left } object\n        top: (offset.top - containmentRect.top) * this.dragTransform.yScale,\n        left: (offset.left - containmentRect.left) * this.dragTransform.xScale\n      }\n      /* not used by GridStack for now...\n      helper: [this.helper], //The object arr representing the helper that's being dragged.\n      offset: { top: offset.top, left: offset.left } // Current offset position of the helper as { top, left } object.\n      */\n    };\n  }\n}\n","/**\n * dd-droppable.ts 12.3.0\n * Copyright (c) 2021-2025  Alain Dumesny - see GridStack root license\n */\n\nimport { DDDraggable } from './dd-draggable';\nimport { DDManager } from './dd-manager';\nimport { DDBaseImplement, HTMLElementExtendOpt } from './dd-base-impl';\nimport { Utils } from './utils';\nimport { DDElementHost } from './dd-element';\nimport { isTouch, pointerenter, pointerleave } from './dd-touch';\nimport { DDUIData } from './types';\n\nexport interface DDDroppableOpt {\n  accept?: string | ((el: HTMLElement) => boolean);\n  drop?: (event: DragEvent, ui: DDUIData) => void;\n  over?: (event: DragEvent, ui: DDUIData) => void;\n  out?: (event: DragEvent, ui: DDUIData) => void;\n}\n\n// let count = 0; // TEST\n\nexport class DDDroppable extends DDBaseImplement implements HTMLElementExtendOpt<DDDroppableOpt> {\n\n  public accept: (el: HTMLElement) => boolean;\n\n  constructor(public el: HTMLElement, public option: DDDroppableOpt = {}) {\n    super();\n    // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n    this._mouseEnter = this._mouseEnter.bind(this);\n    this._mouseLeave = this._mouseLeave.bind(this);\n    this.enable();\n    this._setupAccept();\n  }\n\n  public on(event: 'drop' | 'dropover' | 'dropout', callback: (event: DragEvent) => void): void {\n    super.on(event, callback);\n  }\n\n  public off(event: 'drop' | 'dropover' | 'dropout'): void {\n    super.off(event);\n  }\n\n  public enable(): void {\n    if (this.disabled === false) return;\n    super.enable();\n    this.el.classList.add('ui-droppable');\n    this.el.classList.remove('ui-droppable-disabled');\n    this.el.addEventListener('mouseenter', this._mouseEnter);\n    this.el.addEventListener('mouseleave', this._mouseLeave);\n    if (isTouch) {\n      this.el.addEventListener('pointerenter', pointerenter);\n      this.el.addEventListener('pointerleave', pointerleave);\n    }\n  }\n\n  public disable(forDestroy = false): void {\n    if (this.disabled === true) return;\n    super.disable();\n    this.el.classList.remove('ui-droppable');\n    if (!forDestroy) this.el.classList.add('ui-droppable-disabled');\n    this.el.removeEventListener('mouseenter', this._mouseEnter);\n    this.el.removeEventListener('mouseleave', this._mouseLeave);\n    if (isTouch) {\n      this.el.removeEventListener('pointerenter', pointerenter);\n      this.el.removeEventListener('pointerleave', pointerleave);\n    }\n  }\n\n  public destroy(): void {\n    this.disable(true);\n    this.el.classList.remove('ui-droppable');\n    this.el.classList.remove('ui-droppable-disabled');\n    super.destroy();\n  }\n\n  public updateOption(opts: DDDroppableOpt): DDDroppable {\n    Object.keys(opts).forEach(key => this.option[key] = opts[key]);\n    this._setupAccept();\n    return this;\n  }\n\n  /** @internal called when the cursor enters our area - prepare for a possible drop and track leaving */\n  protected _mouseEnter(e: MouseEvent): void {\n    // console.log(`${count++} Enter ${this.el.id || (this.el as GridHTMLElement).gridstack.opts.id}`); // TEST\n    if (!DDManager.dragElement) return;\n    if (!this._canDrop(DDManager.dragElement.el)) return;\n    e.preventDefault();\n    e.stopPropagation();\n\n    // make sure when we enter this, that the last one gets a leave FIRST to correctly cleanup as we don't always do\n    if (DDManager.dropElement && DDManager.dropElement !== this) {\n      DDManager.dropElement._mouseLeave(e as DragEvent, true); // calledByEnter = true\n    }\n    DDManager.dropElement = this;\n\n    const ev = Utils.initEvent<DragEvent>(e, { target: this.el, type: 'dropover' });\n    if (this.option.over) {\n      this.option.over(ev, this._ui(DDManager.dragElement))\n    }\n    this.triggerEvent('dropover', ev);\n    this.el.classList.add('ui-droppable-over');\n    // console.log('tracking'); // TEST\n  }\n\n  /** @internal called when the item is leaving our area, stop tracking if we had moving item */\n  protected _mouseLeave(e: MouseEvent, calledByEnter = false): void {\n    // console.log(`${count++} Leave ${this.el.id || (this.el as GridHTMLElement).gridstack.opts.id}`); // TEST\n    if (!DDManager.dragElement || DDManager.dropElement !== this) return;\n    e.preventDefault();\n    e.stopPropagation();\n\n    const ev = Utils.initEvent<DragEvent>(e, { target: this.el, type: 'dropout' });\n    if (this.option.out) {\n      this.option.out(ev, this._ui(DDManager.dragElement))\n    }\n    this.triggerEvent('dropout', ev);\n\n    if (DDManager.dropElement === this) {\n      delete DDManager.dropElement;\n      // console.log('not tracking'); // TEST\n\n      // if we're still over a parent droppable, send it an enter as we don't get one from leaving nested children\n      if (!calledByEnter) {\n        let parentDrop: DDDroppable;\n        let parent: DDElementHost = this.el.parentElement;\n        while (!parentDrop && parent) {\n          parentDrop = parent.ddElement?.ddDroppable;\n          parent = parent.parentElement;\n        }\n        if (parentDrop) {\n          parentDrop._mouseEnter(e);\n        }\n      }\n    }\n  }\n\n  /** item is being dropped on us - called by the drag mouseup handler - this calls the client drop event */\n  public drop(e: MouseEvent): void {\n    e.preventDefault();\n    const ev = Utils.initEvent<DragEvent>(e, { target: this.el, type: 'drop' });\n    if (this.option.drop) {\n      this.option.drop(ev, this._ui(DDManager.dragElement))\n    }\n    this.triggerEvent('drop', ev);\n  }\n\n  /** @internal true if element matches the string/method accept option */\n  protected _canDrop(el: HTMLElement): boolean {\n    return el && (!this.accept || this.accept(el));\n  }\n\n  /** @internal */\n  protected _setupAccept(): DDDroppable {\n    if (!this.option.accept) return this;\n    if (typeof this.option.accept === 'string') {\n      this.accept = (el: HTMLElement) => el.classList.contains(this.option.accept as string) || el.matches(this.option.accept as string);\n    } else {\n      this.accept = this.option.accept;\n    }\n    return this;\n  }\n\n  /** @internal */\n  protected _ui(drag: DDDraggable): DDUIData {\n    return {\n      draggable: drag.el,\n      ...drag.ui()\n    };\n  }\n}\n\n","/**\n * dd-elements.ts 12.3.0\n * Copyright (c) 2021-2025 Alain Dumesny - see GridStack root license\n */\n\nimport { DDResizable, DDResizableOpt } from './dd-resizable';\nimport { DDDragOpt, GridItemHTMLElement } from './types';\nimport { DDDraggable } from './dd-draggable';\nimport { DDDroppable, DDDroppableOpt } from './dd-droppable';\n\nexport interface DDElementHost extends GridItemHTMLElement {\n  ddElement?: DDElement;\n}\n\nexport class DDElement {\n\n  static init(el: DDElementHost): DDElement {\n    if (!el.ddElement) { el.ddElement = new DDElement(el); }\n    return el.ddElement;\n  }\n\n  public ddDraggable?: DDDraggable;\n  public ddDroppable?: DDDroppable;\n  public ddResizable?: DDResizable;\n\n  constructor(public el: DDElementHost) {}\n\n  public on(eventName: string, callback: (event: MouseEvent) => void): DDElement {\n    if (this.ddDraggable && ['drag', 'dragstart', 'dragstop'].indexOf(eventName) > -1) {\n      this.ddDraggable.on(eventName as 'drag' | 'dragstart' | 'dragstop', callback);\n    } else if (this.ddDroppable && ['drop', 'dropover', 'dropout'].indexOf(eventName) > -1) {\n      this.ddDroppable.on(eventName as 'drop' | 'dropover' | 'dropout', callback);\n    } else if (this.ddResizable && ['resizestart', 'resize', 'resizestop'].indexOf(eventName) > -1) {\n      this.ddResizable.on(eventName as 'resizestart' | 'resize' | 'resizestop', callback);\n    }\n    return this;\n  }\n\n  public off(eventName: string): DDElement {\n    if (this.ddDraggable && ['drag', 'dragstart', 'dragstop'].indexOf(eventName) > -1) {\n      this.ddDraggable.off(eventName as 'drag' | 'dragstart' | 'dragstop');\n    } else if (this.ddDroppable && ['drop', 'dropover', 'dropout'].indexOf(eventName) > -1) {\n      this.ddDroppable.off(eventName as 'drop' | 'dropover' | 'dropout');\n    } else if (this.ddResizable && ['resizestart', 'resize', 'resizestop'].indexOf(eventName) > -1) {\n      this.ddResizable.off(eventName as 'resizestart' | 'resize' | 'resizestop');\n    }\n    return this;\n  }\n\n  public setupDraggable(opts: DDDragOpt): DDElement {\n    if (!this.ddDraggable) {\n      this.ddDraggable = new DDDraggable(this.el, opts);\n    } else {\n      this.ddDraggable.updateOption(opts);\n    }\n    return this;\n  }\n\n  public cleanDraggable(): DDElement {\n    if (this.ddDraggable) {\n      this.ddDraggable.destroy();\n      delete this.ddDraggable;\n    }\n    return this;\n  }\n\n  public setupResizable(opts: DDResizableOpt): DDElement {\n    if (!this.ddResizable) {\n      this.ddResizable = new DDResizable(this.el, opts);\n    } else {\n      this.ddResizable.updateOption(opts);\n    }\n    return this;\n  }\n\n  public cleanResizable(): DDElement {\n    if (this.ddResizable) {\n      this.ddResizable.destroy();\n      delete this.ddResizable;\n    }\n    return this;\n  }\n\n  public setupDroppable(opts: DDDroppableOpt): DDElement {\n    if (!this.ddDroppable) {\n      this.ddDroppable = new DDDroppable(this.el, opts);\n    } else {\n      this.ddDroppable.updateOption(opts);\n    }\n    return this;\n  }\n\n  public cleanDroppable(): DDElement {\n    if (this.ddDroppable) {\n      this.ddDroppable.destroy();\n      delete this.ddDroppable;\n    }\n    return this;\n  }\n}\n","/*!\r\n * GridStack 12.3.0\r\n * https://gridstackjs.com/\r\n *\r\n * Copyright (c) 2021-2025  Alain Dumesny\r\n * see root license https://github.com/gridstack/gridstack.js/tree/master/LICENSE\r\n */\r\nimport { GridStackEngine } from './gridstack-engine';\r\nimport { Utils, HeightData, obsolete, DragTransform } from './utils';\r\nimport {\r\n  gridDefaults, ColumnOptions, GridItemHTMLElement, GridStackElement, GridStackEventHandlerCallback,\r\n  GridStackNode, GridStackWidget, numberOrString, DDUIData, DDDragOpt, GridStackPosition, GridStackOptions,\r\n  GridStackEventHandler, GridStackNodesHandler, AddRemoveFcn, SaveFcn, CompactOptions, GridStackMoveOpts, ResizeToContentFcn, GridStackDroppedHandler, GridStackElementHandler,\r\n  Position, RenderFcn\r\n} from './types';\r\n\r\n/*\r\n * and include D&D by default\r\n * TODO: while we could generate a gridstack-static.js at smaller size - saves about 31k (41k -> 72k)\r\n * I don't know how to generate the DD only code at the remaining 31k to delay load as code depends on Gridstack.ts\r\n * also it caused loading issues in prod - see https://github.com/gridstack/gridstack.js/issues/2039\r\n */\r\nimport { DDGridStack } from './dd-gridstack';\r\nimport { isTouch } from './dd-touch';\r\nimport { DDManager } from './dd-manager';\r\nimport { DDElementHost } from './dd-element'; /** global instance */\r\nconst dd = new DDGridStack;\r\n\r\n// export all dependent file as well to make it easier for users to just import the main file\r\nexport * from './types';\r\nexport * from './utils';\r\nexport * from './gridstack-engine';\r\nexport * from './dd-gridstack';\r\nexport * from './dd-manager';\r\nexport * from './dd-element';\r\nexport * from './dd-draggable';\r\nexport * from './dd-droppable';\r\nexport * from './dd-resizable';\r\nexport * from './dd-resizable-handle';\r\nexport * from './dd-base-impl';\r\n\r\nexport interface GridHTMLElement extends HTMLElement {\r\n  gridstack?: GridStack; // grid's parent DOM element points back to grid class\r\n}\r\n/** list of possible events, or space separated list of them */\r\nexport type GridStackEvent = 'added' | 'change' | 'disable' | 'drag' | 'dragstart' | 'dragstop' | 'dropped' |\r\n  'enable' | 'removed' | 'resize' | 'resizestart' | 'resizestop' | 'resizecontent';\r\n\r\n/** Defines the coordinates of an object */\r\nexport interface MousePosition {\r\n  top: number;\r\n  left: number;\r\n}\r\n\r\n/** Defines the position of a cell inside the grid*/\r\nexport interface CellPosition {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\n// extend with internal fields we need - TODO: move other items in here\r\ninterface InternalGridStackOptions extends GridStackOptions {\r\n  _alwaysShowResizeHandle?: true | false | 'mobile'; // so we can restore for save\r\n}\r\n\r\n/**\r\n * Main gridstack class - you will need to call `GridStack.init()` first to initialize your grid.\r\n * Note: your grid elements MUST have the following classes for the CSS layout to work:\r\n * @example\r\n * <div class=\"grid-stack\">\r\n *   <div class=\"grid-stack-item\">\r\n *     <div class=\"grid-stack-item-content\">Item 1</div>\r\n *   </div>\r\n * </div>\r\n */\r\nexport class GridStack {\r\n\r\n  /**\r\n   * initializing the HTML element, or selector string, into a grid will return the grid. Calling it again will\r\n   * simply return the existing instance (ignore any passed options). There is also an initAll() version that support\r\n   * multiple grids initialization at once. Or you can use addGrid() to create the entire grid from JSON.\r\n   * @param options grid options (optional)\r\n   * @param elOrString element or CSS selector (first one used) to convert to a grid (default to '.grid-stack' class selector)\r\n   *\r\n   * @example\r\n   * const grid = GridStack.init();\r\n   *\r\n   * Note: the HTMLElement (of type GridHTMLElement) will store a `gridstack: GridStack` value that can be retrieve later\r\n   * const grid = document.querySelector('.grid-stack').gridstack;\r\n   */\r\n  public static init(options: GridStackOptions = {}, elOrString: GridStackElement = '.grid-stack'): GridStack {\r\n    if (typeof document === 'undefined') return null; // temp workaround SSR\r\n    const el = GridStack.getGridElement(elOrString);\r\n    if (!el) {\r\n      if (typeof elOrString === 'string') {\r\n        console.error('GridStack.initAll() no grid was found with selector \"' + elOrString + '\" - element missing or wrong selector ?' +\r\n          '\\nNote: \".grid-stack\" is required for proper CSS styling and drag/drop, and is the default selector.');\r\n      } else {\r\n        console.error('GridStack.init() no grid element was passed.');\r\n      }\r\n      return null;\r\n    }\r\n    if (!el.gridstack) {\r\n      el.gridstack = new GridStack(el, Utils.cloneDeep(options));\r\n    }\r\n    return el.gridstack\r\n  }\r\n\r\n  /**\r\n   * Will initialize a list of elements (given a selector) and return an array of grids.\r\n   * @param options grid options (optional)\r\n   * @param selector elements selector to convert to grids (default to '.grid-stack' class selector)\r\n   *\r\n   * @example\r\n   * const grids = GridStack.initAll();\r\n   * grids.forEach(...)\r\n   */\r\n  public static initAll(options: GridStackOptions = {}, selector = '.grid-stack'): GridStack[] {\r\n    const grids: GridStack[] = [];\r\n    if (typeof document === 'undefined') return grids; // temp workaround SSR\r\n    GridStack.getGridElements(selector).forEach(el => {\r\n      if (!el.gridstack) {\r\n        el.gridstack = new GridStack(el, Utils.cloneDeep(options));\r\n      }\r\n      grids.push(el.gridstack);\r\n    });\r\n    if (grids.length === 0) {\r\n      console.error('GridStack.initAll() no grid was found with selector \"' + selector + '\" - element missing or wrong selector ?' +\r\n        '\\nNote: \".grid-stack\" is required for proper CSS styling and drag/drop, and is the default selector.');\r\n    }\r\n    return grids;\r\n  }\r\n\r\n  /**\r\n   * call to create a grid with the given options, including loading any children from JSON structure. This will call GridStack.init(), then\r\n   * grid.load() on any passed children (recursively). Great alternative to calling init() if you want entire grid to come from\r\n   * JSON serialized data, including options.\r\n   * @param parent HTML element parent to the grid\r\n   * @param opt grids options used to initialize the grid, and list of children\r\n   */\r\n  public static addGrid(parent: HTMLElement, opt: GridStackOptions = {}): GridStack {\r\n    if (!parent) return null;\r\n\r\n    let el = parent as GridHTMLElement;\r\n    if (el.gridstack) {\r\n      // already a grid - set option and load data\r\n      const grid = el.gridstack;\r\n      if (opt) grid.opts = { ...grid.opts, ...opt };\r\n      if (opt.children !== undefined) grid.load(opt.children);\r\n      return grid;\r\n    }\r\n\r\n    // create the grid element, but check if the passed 'parent' already has grid styling and should be used instead\r\n    const parentIsGrid = parent.classList.contains('grid-stack');\r\n    if (!parentIsGrid || GridStack.addRemoveCB) {\r\n      if (GridStack.addRemoveCB) {\r\n        el = GridStack.addRemoveCB(parent, opt, true, true);\r\n      } else {\r\n        el = Utils.createDiv(['grid-stack', opt.class], parent);\r\n      }\r\n    }\r\n\r\n    // create grid class and load any children\r\n    const grid = GridStack.init(opt, el);\r\n    return grid;\r\n  }\r\n\r\n  /** call this method to register your engine instead of the default one.\r\n   * See instead `GridStackOptions.engineClass` if you only need to\r\n   * replace just one instance.\r\n   */\r\n  static registerEngine(engineClass: typeof GridStackEngine): void {\r\n    GridStack.engineClass = engineClass;\r\n  }\r\n\r\n  /**\r\n   * callback method use when new items|grids needs to be created or deleted, instead of the default\r\n   * item: <div class=\"grid-stack-item\"><div class=\"grid-stack-item-content\">w.content</div></div>\r\n   * grid: <div class=\"grid-stack\">grid content...</div>\r\n   * add = true: the returned DOM element will then be converted to a GridItemHTMLElement using makeWidget()|GridStack:init().\r\n   * add = false: the item will be removed from DOM (if not already done)\r\n   * grid = true|false for grid vs grid-items\r\n   */\r\n  public static addRemoveCB?: AddRemoveFcn;\r\n\r\n  /**\r\n   * callback during saving to application can inject extra data for each widget, on top of the grid layout properties\r\n   */\r\n  public static saveCB?: SaveFcn;\r\n\r\n  /**\r\n   * callback to create the content of widgets so the app can control how to store and restore it\r\n   * By default this lib will do 'el.textContent = w.content' forcing text only support for avoiding potential XSS issues.\r\n   */\r\n  public static renderCB?: RenderFcn = (el: HTMLElement, w: GridStackNode) => { if (el && w?.content) el.textContent = w.content; };\r\n\r\n  /** called after a widget has been updated (eg: load() into an existing list of children) so application can do extra work */\r\n  public static updateCB?: (w: GridStackNode) => void;\r\n\r\n  /** callback to use for resizeToContent instead of the built in one */\r\n  public static resizeToContentCB?: ResizeToContentFcn;\r\n  /** parent class for sizing content. defaults to '.grid-stack-item-content' */\r\n  public static resizeToContentParent = '.grid-stack-item-content';\r\n\r\n  /** scoping so users can call GridStack.Utils.sort() for example */\r\n  public static Utils = Utils;\r\n\r\n  /** scoping so users can call new GridStack.Engine(12) for example */\r\n  public static Engine = GridStackEngine;\r\n\r\n  /** engine used to implement non DOM grid functionality */\r\n  public engine: GridStackEngine;\r\n\r\n  /** point to a parent grid item if we're nested (inside a grid-item in between 2 Grids) */\r\n  public parentGridNode?: GridStackNode;\r\n\r\n  /** time to wait for animation (if enabled) to be done so content sizing can happen */\r\n  public animationDelay = 300 + 10;\r\n\r\n  protected static engineClass: typeof GridStackEngine;\r\n  protected resizeObserver: ResizeObserver;\r\n\r\n  /** @internal true if we got created by drag over gesture, so we can removed on drag out (temporary) */\r\n  public _isTemp?: boolean;\r\n\r\n  /**\r\n   * @internal create placeholder DIV as needed\r\n   * @returns the placeholder element for indicating drop zones during drag operations\r\n   */\r\n  public get placeholder(): GridItemHTMLElement {\r\n    if (!this._placeholder) {\r\n      this._placeholder = Utils.createDiv([this.opts.placeholderClass, gridDefaults.itemClass, this.opts.itemClass]);\r\n      const placeholderChild = Utils.createDiv(['placeholder-content'], this._placeholder);\r\n      if (this.opts.placeholderText) {\r\n        placeholderChild.textContent = this.opts.placeholderText;\r\n      }\r\n    }\r\n    return this._placeholder;\r\n  }\r\n  /** @internal */\r\n  protected _placeholder: GridItemHTMLElement;\r\n  /** @internal prevent cached layouts from being updated when loading into small column layouts */\r\n  protected _ignoreLayoutsNodeChange: boolean;\r\n  /** @internal */\r\n  public _gsEventHandler = {};\r\n  /** @internal flag to keep cells square during resize */\r\n  protected _isAutoCellHeight: boolean;\r\n  /** @internal limit auto cell resizing method */\r\n  protected _sizeThrottle: () => void;\r\n  /** @internal limit auto cell resizing method */\r\n  protected prevWidth: number;\r\n  /** @internal extra row added when dragging at the bottom of the grid */\r\n  protected _extraDragRow = 0;\r\n  /** @internal true if nested grid should get column count from our width */\r\n  protected _autoColumn?: boolean;\r\n  /** @internal meant to store the scale of the active grid */\r\n  protected dragTransform: DragTransform = { xScale: 1, yScale: 1, xOffset: 0, yOffset: 0 };\r\n  protected responseLayout: ColumnOptions;\r\n  private _skipInitialResize: boolean;\r\n\r\n  /**\r\n   * Construct a grid item from the given element and options\r\n   * @param el the HTML element tied to this grid after it's been initialized\r\n   * @param opts grid options - public for classes to access, but use methods to modify!\r\n   */\r\n  public constructor(public el: GridHTMLElement, public opts: GridStackOptions = {}) {\r\n    el.gridstack = this;\r\n    this.opts = opts = opts || {}; // handles null/undefined/0\r\n\r\n    if (!el.classList.contains('grid-stack')) {\r\n      this.el.classList.add('grid-stack');\r\n    }\r\n\r\n    // if row property exists, replace minRow and maxRow instead\r\n    if (opts.row) {\r\n      opts.minRow = opts.maxRow = opts.row;\r\n      delete opts.row;\r\n    }\r\n    const rowAttr = Utils.toNumber(el.getAttribute('gs-row'));\r\n\r\n    // flag only valid in sub-grids (handled by parent, not here)\r\n    if (opts.column === 'auto') {\r\n      delete opts.column;\r\n    }\r\n    // save original setting so we can restore on save\r\n    if (opts.alwaysShowResizeHandle !== undefined) {\r\n      (opts as InternalGridStackOptions)._alwaysShowResizeHandle = opts.alwaysShowResizeHandle;\r\n    }\r\n\r\n    // cleanup responsive opts (must have columnWidth | breakpoints) then sort breakpoints by size (so we can match during resize)\r\n    const resp = opts.columnOpts;\r\n    if (resp) {\r\n      const bk = resp.breakpoints;\r\n      if (!resp.columnWidth && !bk?.length) {\r\n        delete opts.columnOpts;\r\n      } else {\r\n        resp.columnMax = resp.columnMax || 12;\r\n        if (bk?.length > 1) bk.sort((a, b) => (b.w || 0) - (a.w || 0));\r\n      }\r\n    }\r\n\r\n    // elements DOM attributes override any passed options (like CSS style) - merge the two together\r\n    const defaults: GridStackOptions = {\r\n      ...Utils.cloneDeep(gridDefaults),\r\n      column: Utils.toNumber(el.getAttribute('gs-column')) || gridDefaults.column,\r\n      minRow: rowAttr ? rowAttr : Utils.toNumber(el.getAttribute('gs-min-row')) || gridDefaults.minRow,\r\n      maxRow: rowAttr ? rowAttr : Utils.toNumber(el.getAttribute('gs-max-row')) || gridDefaults.maxRow,\r\n      staticGrid: Utils.toBool(el.getAttribute('gs-static')) || gridDefaults.staticGrid,\r\n      sizeToContent: Utils.toBool(el.getAttribute('gs-size-to-content')) || undefined,\r\n      draggable: {\r\n        handle: (opts.handleClass ? '.' + opts.handleClass : (opts.handle ? opts.handle : '')) || gridDefaults.draggable.handle,\r\n      },\r\n      removableOptions: {\r\n        accept: opts.itemClass || gridDefaults.removableOptions.accept,\r\n        decline: gridDefaults.removableOptions.decline\r\n      },\r\n    };\r\n    if (el.getAttribute('gs-animate')) { // default to true, but if set to false use that instead\r\n      defaults.animate = Utils.toBool(el.getAttribute('gs-animate'))\r\n    }\r\n\r\n    opts = Utils.defaults(opts, defaults);\r\n    this._initMargin(); // part of settings defaults...\r\n\r\n    // Now check if we're loading into !12 column mode FIRST so we don't do un-necessary work (like cellHeight = width / 12 then go 1 column)\r\n    this.checkDynamicColumn();\r\n    this._updateColumnVar(opts);\r\n\r\n    if (opts.rtl === 'auto') {\r\n      opts.rtl = (el.style.direction === 'rtl');\r\n    }\r\n    if (opts.rtl) {\r\n      this.el.classList.add('grid-stack-rtl');\r\n    }\r\n\r\n    // check if we're been nested, and if so update our style and keep pointer around (used during save)\r\n    const parentGridItem: GridItemHTMLElement = this.el.closest('.' + gridDefaults.itemClass);\r\n    const parentNode = parentGridItem?.gridstackNode;\r\n    if (parentNode) {\r\n      parentNode.subGrid = this;\r\n      this.parentGridNode = parentNode;\r\n      this.el.classList.add('grid-stack-nested');\r\n      parentNode.el.classList.add('grid-stack-sub-grid');\r\n    }\r\n\r\n    this._isAutoCellHeight = (opts.cellHeight === 'auto');\r\n    if (this._isAutoCellHeight || opts.cellHeight === 'initial') {\r\n      // make the cell content square initially (will use resize/column event to keep it square)\r\n      this.cellHeight(undefined);\r\n    } else {\r\n      // append unit if any are set\r\n      if (typeof opts.cellHeight == 'number' && opts.cellHeightUnit && opts.cellHeightUnit !== gridDefaults.cellHeightUnit) {\r\n        opts.cellHeight = opts.cellHeight + opts.cellHeightUnit;\r\n        delete opts.cellHeightUnit;\r\n      }\r\n      const val = opts.cellHeight;\r\n      delete opts.cellHeight; // force initial cellHeight() call to set the value\r\n      this.cellHeight(val);\r\n    }\r\n\r\n    // see if we need to adjust auto-hide\r\n    if (opts.alwaysShowResizeHandle === 'mobile') {\r\n      opts.alwaysShowResizeHandle = isTouch;\r\n    }\r\n\r\n    this._setStaticClass();\r\n\r\n    const engineClass = opts.engineClass || GridStack.engineClass || GridStackEngine;\r\n    this.engine = new engineClass({\r\n      column: this.getColumn(),\r\n      float: opts.float,\r\n      maxRow: opts.maxRow,\r\n      onChange: (cbNodes) => {\r\n        cbNodes.forEach(n => {\r\n          const el = n.el;\r\n          if (!el) return;\r\n          if (n._removeDOM) {\r\n            if (el) el.remove();\r\n            delete n._removeDOM;\r\n          } else {\r\n            this._writePosAttr(el, n);\r\n          }\r\n        });\r\n        this._updateContainerHeight();\r\n      }\r\n    });\r\n\r\n    if (opts.auto) {\r\n      this.batchUpdate(); // prevent in between re-layout #1535 TODO: this only set float=true, need to prevent collision check...\r\n      this.engine._loading = true; // loading collision check\r\n      this.getGridItems().forEach(el => this._prepareElement(el));\r\n      delete this.engine._loading;\r\n      this.batchUpdate(false);\r\n    }\r\n\r\n    // load any passed in children as well, which overrides any DOM layout done above\r\n    if (opts.children) {\r\n      const children = opts.children;\r\n      delete opts.children;\r\n      if (children.length) this.load(children); // don't load empty\r\n    }\r\n\r\n    this.setAnimation();\r\n\r\n    // dynamic grids require pausing during drag to detect over to nest vs push\r\n    if (opts.subGridDynamic && !DDManager.pauseDrag) DDManager.pauseDrag = true;\r\n    if (opts.draggable?.pause !== undefined) DDManager.pauseDrag = opts.draggable.pause;\r\n\r\n    this._setupRemoveDrop();\r\n    this._setupAcceptWidget();\r\n    this._updateResizeEvent();\r\n  }\r\n\r\n  private _updateColumnVar(opts: GridStackOptions = this.opts): void {\r\n    this.el.classList.add('gs-' + opts.column);\r\n    if (typeof opts.column === 'number') this.el.style.setProperty('--gs-column-width', `${100/opts.column}%`);\r\n  }\r\n\r\n  /**\r\n   * add a new widget and returns it.\r\n   *\r\n   * Widget will be always placed even if result height is more than actual grid height.\r\n   * You need to use `willItFit()` before calling addWidget for additional check.\r\n   * See also `makeWidget(el)` for DOM element.\r\n   *\r\n   * @example\r\n   * const grid = GridStack.init();\r\n   * grid.addWidget({w: 3, content: 'hello'});\r\n   *\r\n   * @param w GridStackWidget definition. used MakeWidget(el) if you have dom element instead.\r\n   */\r\n  public addWidget(w: GridStackWidget): GridItemHTMLElement {\r\n    if (!w) return;\r\n    if (typeof w === 'string') { console.error('V11: GridStack.addWidget() does not support string anymore. see #2736'); return; }\r\n    if ((w as HTMLElement).ELEMENT_NODE) { console.error('V11: GridStack.addWidget() does not support HTMLElement anymore. use makeWidget()'); return this.makeWidget(w as HTMLElement); }\r\n\r\n    let el: GridItemHTMLElement;\r\n    let node: GridStackNode = w;\r\n    node.grid = this;\r\n    if (node.el) {\r\n      el = node.el; // re-use element stored in the node\r\n    } else if (GridStack.addRemoveCB) {\r\n      el = GridStack.addRemoveCB(this.el, w, true, false);\r\n    } else {\r\n      el = this.createWidgetDivs(node);\r\n    }\r\n\r\n    if (!el) return;\r\n\r\n    // if the caller ended up initializing the widget in addRemoveCB, or we stared with one already, skip the rest\r\n    node = el.gridstackNode;\r\n    if (node && el.parentElement === this.el && this.engine.nodes.find(n => n._id === node._id)) return el;\r\n\r\n    // Tempting to initialize the passed in opt with default and valid values, but this break knockout demos\r\n    // as the actual value are filled in when _prepareElement() calls el.getAttribute('gs-xyz') before adding the node.\r\n    // So make sure we load any DOM attributes that are not specified in passed in options (which override)\r\n    const domAttr = this._readAttr(el);\r\n    Utils.defaults(w, domAttr);\r\n    this.engine.prepareNode(w);\r\n    // this._writeAttr(el, w); why write possibly incorrect values back when makeWidget() will ?\r\n\r\n    this.el.appendChild(el);\r\n\r\n    this.makeWidget(el, w);\r\n\r\n    return el;\r\n  }\r\n\r\n  /**\r\n   * Create the default grid item divs and content (possibly lazy loaded) by using GridStack.renderCB().\r\n   * \r\n   * @param n GridStackNode definition containing widget configuration\r\n   * @returns the created HTML element with proper grid item structure\r\n   * \r\n   * @example\r\n   * const element = grid.createWidgetDivs({ w: 2, h: 1, content: 'Hello World' });\r\n   */\r\n  public createWidgetDivs(n: GridStackNode): HTMLElement {\r\n    const el = Utils.createDiv(['grid-stack-item', this.opts.itemClass]);\r\n    const cont = Utils.createDiv(['grid-stack-item-content'], el);\r\n\r\n    if (Utils.lazyLoad(n)) {\r\n      if (!n.visibleObservable) {\r\n        n.visibleObservable = new IntersectionObserver(([entry]) => { if (entry.isIntersecting) {\r\n          n.visibleObservable?.disconnect();\r\n          delete n.visibleObservable;\r\n          GridStack.renderCB(cont, n);\r\n          n.grid?.prepareDragDrop(n.el);\r\n        }});\r\n        window.setTimeout(() => n.visibleObservable?.observe(el)); // wait until callee sets position attributes\r\n      }\r\n    } else GridStack.renderCB(cont, n);\r\n\r\n    return el;\r\n  }\r\n\r\n  /**\r\n   * Convert an existing gridItem element into a sub-grid with the given (optional) options, else inherit them\r\n   * from the parent's subGrid options.\r\n   * @param el gridItem element to convert\r\n   * @param ops (optional) sub-grid options, else default to node, then parent settings, else defaults\r\n   * @param nodeToAdd (optional) node to add to the newly created sub grid (used when dragging over existing regular item)\r\n   * @param saveContent if true (default) the html inside .grid-stack-content will be saved to child widget\r\n   * @returns newly created grid\r\n   */\r\n  public makeSubGrid(el: GridItemHTMLElement, ops?: GridStackOptions, nodeToAdd?: GridStackNode, saveContent = true): GridStack {\r\n    let node = el.gridstackNode;\r\n    if (!node) {\r\n      node = this.makeWidget(el).gridstackNode;\r\n    }\r\n    if (node.subGrid?.el) return node.subGrid; // already done\r\n\r\n    // find the template subGrid stored on a parent as fallback...\r\n    let subGridTemplate: GridStackOptions; // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    let grid: GridStack = this;\r\n    while (grid && !subGridTemplate) {\r\n      subGridTemplate = grid.opts?.subGridOpts;\r\n      grid = grid.parentGridNode?.grid;\r\n    }\r\n    //... and set the create options\r\n    ops = Utils.cloneDeep({\r\n      // by default sub-grid inherit from us | parent, other than id, children, etc...\r\n      ...this.opts, id: undefined, children: undefined, column: 'auto', columnOpts: undefined, layout: 'list', subGridOpts: undefined,\r\n      ...(subGridTemplate || {}),\r\n      ...(ops || node.subGridOpts || {})\r\n    });\r\n    node.subGridOpts = ops;\r\n\r\n    // if column special case it set, remember that flag and set default\r\n    let autoColumn: boolean;\r\n    if (ops.column === 'auto') {\r\n      autoColumn = true;\r\n      ops.column = Math.max(node.w || 1, nodeToAdd?.w || 1);\r\n      delete ops.columnOpts; // driven by parent\r\n    }\r\n\r\n    // if we're converting an existing full item, move over the content to be the first sub item in the new grid\r\n    let content = node.el.querySelector('.grid-stack-item-content') as HTMLElement;\r\n    let newItem: HTMLElement;\r\n    let newItemOpt: GridStackNode;\r\n    if (saveContent) {\r\n      this._removeDD(node.el); // remove D&D since it's set on content div\r\n      newItemOpt = { ...node, x: 0, y: 0 };\r\n      Utils.removeInternalForSave(newItemOpt);\r\n      delete newItemOpt.subGridOpts;\r\n      if (node.content) {\r\n        newItemOpt.content = node.content;\r\n        delete node.content;\r\n      }\r\n      if (GridStack.addRemoveCB) {\r\n        newItem = GridStack.addRemoveCB(this.el, newItemOpt, true, false);\r\n      } else {\r\n        newItem = Utils.createDiv(['grid-stack-item']);\r\n        newItem.appendChild(content);\r\n        content = Utils.createDiv(['grid-stack-item-content'], node.el);\r\n      }\r\n      this.prepareDragDrop(node.el); // ... and restore original D&D\r\n    }\r\n\r\n    // if we're adding an additional item, make the container large enough to have them both\r\n    if (nodeToAdd) {\r\n      const w = autoColumn ? ops.column : node.w;\r\n      const h = node.h + nodeToAdd.h;\r\n      const style = node.el.style;\r\n      style.transition = 'none'; // show up instantly so we don't see scrollbar with nodeToAdd\r\n      this.update(node.el, { w, h });\r\n      setTimeout(() => style.transition = null); // recover animation\r\n    }\r\n\r\n    const subGrid = node.subGrid = GridStack.addGrid(content, ops);\r\n    if (nodeToAdd?._moving) subGrid._isTemp = true; // prevent re-nesting as we add over\r\n    if (autoColumn) subGrid._autoColumn = true;\r\n\r\n    // add the original content back as a child of the newly created grid\r\n    if (saveContent) {\r\n      subGrid.makeWidget(newItem, newItemOpt);\r\n    }\r\n\r\n    // now add any additional node\r\n    if (nodeToAdd) {\r\n      if (nodeToAdd._moving) {\r\n        // create an artificial event even for the just created grid to receive this item\r\n        window.setTimeout(() => Utils.simulateMouseEvent(nodeToAdd._event, 'mouseenter', subGrid.el), 0);\r\n      } else {\r\n        subGrid.makeWidget(node.el, node);\r\n      }\r\n    }\r\n\r\n    // if sizedToContent, we need to re-calc the size of ourself\r\n    this.resizeToContentCheck(false, node);\r\n\r\n    return subGrid;\r\n  }\r\n\r\n  /**\r\n   * called when an item was converted into a nested grid to accommodate a dragged over item, but then item leaves - return back\r\n   * to the original grid-item. Also called to remove empty sub-grids when last item is dragged out (since re-creating is simple)\r\n   */\r\n  public removeAsSubGrid(nodeThatRemoved?: GridStackNode): void {\r\n    const pGrid = this.parentGridNode?.grid;\r\n    if (!pGrid) return;\r\n\r\n    pGrid.batchUpdate();\r\n    pGrid.removeWidget(this.parentGridNode.el, true, true);\r\n    this.engine.nodes.forEach(n => {\r\n      // migrate any children over and offsetting by our location\r\n      n.x += this.parentGridNode.x;\r\n      n.y += this.parentGridNode.y;\r\n      pGrid.makeWidget(n.el, n);\r\n    });\r\n    pGrid.batchUpdate(false);\r\n    if (this.parentGridNode) delete this.parentGridNode.subGrid;\r\n    delete this.parentGridNode;\r\n\r\n    // create an artificial event for the original grid now that this one is gone (got a leave, but won't get enter)\r\n    if (nodeThatRemoved) {\r\n      window.setTimeout(() => Utils.simulateMouseEvent(nodeThatRemoved._event, 'mouseenter', pGrid.el), 0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * saves the current layout returning a list of widgets for serialization which might include any nested grids.\r\n   * @param saveContent if true (default) the latest html inside .grid-stack-content will be saved to GridStackWidget.content field, else it will\r\n   * be removed.\r\n   * @param saveGridOpt if true (default false), save the grid options itself, so you can call the new GridStack.addGrid()\r\n   * to recreate everything from scratch. GridStackOptions.children would then contain the widget list instead.\r\n   * @param saveCB callback for each node -> widget, so application can insert additional data to be saved into the widget data structure.\r\n   * @returns list of widgets or full grid option, including .children list of widgets\r\n   */\r\n  public save(saveContent = true, saveGridOpt = false, saveCB = GridStack.saveCB): GridStackWidget[] | GridStackOptions {\r\n    // return copied GridStackWidget (with optionally .el) we can modify at will...\r\n    const list = this.engine.save(saveContent, saveCB);\r\n\r\n    // check for HTML content and nested grids\r\n    list.forEach(n => {\r\n      if (saveContent && n.el && !n.subGrid && !saveCB) { // sub-grid are saved differently, not plain content\r\n        const itemContent = n.el.querySelector('.grid-stack-item-content');\r\n        n.content = itemContent?.innerHTML;\r\n        if (!n.content) delete n.content;\r\n      } else {\r\n        if (!saveContent && !saveCB) { delete n.content; }\r\n        // check for nested grid\r\n        if (n.subGrid?.el) {\r\n          const listOrOpt = n.subGrid.save(saveContent, saveGridOpt, saveCB);\r\n          n.subGridOpts = (saveGridOpt ? listOrOpt : { children: listOrOpt }) as GridStackOptions;\r\n          delete n.subGrid;\r\n        }\r\n      }\r\n      delete n.el;\r\n    });\r\n\r\n    // check if save entire grid options (needed for recursive) + children...\r\n    if (saveGridOpt) {\r\n      const o: InternalGridStackOptions = Utils.cloneDeep(this.opts);\r\n      // delete default values that will be recreated on launch\r\n      if (o.marginBottom === o.marginTop && o.marginRight === o.marginLeft && o.marginTop === o.marginRight) {\r\n        o.margin = o.marginTop;\r\n        delete o.marginTop; delete o.marginRight; delete o.marginBottom; delete o.marginLeft;\r\n      }\r\n      if (o.rtl === (this.el.style.direction === 'rtl')) { o.rtl = 'auto' }\r\n      if (this._isAutoCellHeight) {\r\n        o.cellHeight = 'auto'\r\n      }\r\n      if (this._autoColumn) {\r\n        o.column = 'auto';\r\n      }\r\n      const origShow = o._alwaysShowResizeHandle;\r\n      delete o._alwaysShowResizeHandle;\r\n      if (origShow !== undefined) {\r\n        o.alwaysShowResizeHandle = origShow;\r\n      } else {\r\n        delete o.alwaysShowResizeHandle;\r\n      }\r\n      Utils.removeInternalAndSame(o, gridDefaults);\r\n      o.children = list;\r\n      return o;\r\n    }\r\n\r\n    return list;\r\n  }\r\n\r\n  /**\r\n   * Load widgets from a list. This will call update() on each (matching by id) or add/remove widgets that are not there.\r\n   * Used to restore a grid layout for a saved layout list (see `save()`).\r\n   *\r\n   * @param items list of widgets definition to update/create\r\n   * @param addRemove boolean (default true) or callback method can be passed to control if and how missing widgets can be added/removed, giving\r\n   * the user control of insertion.\r\n   * @returns the grid instance for chaining\r\n   *\r\n   * @example\r\n   * // Basic usage with saved layout\r\n   * const savedLayout = grid.save(); // Save current layout\r\n   * // ... later restore it\r\n   * grid.load(savedLayout);\r\n   * \r\n   * // Load with custom add/remove callback\r\n   * grid.load(layout, (items, grid, add) => {\r\n   *   if (add) {\r\n   *     // Custom logic for adding new widgets\r\n   *     items.forEach(item => {\r\n   *       const el = document.createElement('div');\r\n   *       el.innerHTML = item.content || '';\r\n   *       grid.addWidget(el, item);\r\n   *     });\r\n   *   } else {\r\n   *     // Custom logic for removing widgets\r\n   *     items.forEach(item => grid.removeWidget(item.el));\r\n   *   }\r\n   * });\r\n   * \r\n   * // Load without adding/removing missing widgets\r\n   * grid.load(layout, false);\r\n   * \r\n   * @see {@link http://gridstackjs.com/demo/serialization.html} for complete example\r\n   */\r\n  public load(items: GridStackWidget[], addRemove: boolean | AddRemoveFcn = GridStack.addRemoveCB || true): GridStack {\r\n    items = Utils.cloneDeep(items); // so we can mod\r\n    const column = this.getColumn();\r\n\r\n    // make sure size 1x1 (default) is present as it may need to override current sizes\r\n    items.forEach(n => { n.w = n.w || 1; n.h = n.h || 1 });\r\n\r\n    // sort items. those without coord will be appended last\r\n    items = Utils.sort(items);\r\n\r\n    this.engine.skipCacheUpdate = this._ignoreLayoutsNodeChange = true; // skip layout update\r\n\r\n    // if we're loading a layout into for example 1 column and items don't fit, make sure to save\r\n    // the original wanted layout so we can scale back up correctly #1471\r\n    let maxColumn = 0;\r\n    items.forEach(n => { maxColumn = Math.max(maxColumn, (n.x || 0) + n.w) });\r\n    if (maxColumn > this.engine.defaultColumn) this.engine.defaultColumn = maxColumn;\r\n    if (maxColumn > column) {\r\n      // if we're loading (from empty) into a smaller column, check for special responsive layout\r\n      if (this.engine.nodes.length === 0 && this.responseLayout) {\r\n        this.engine.nodes = items;\r\n        this.engine.columnChanged(maxColumn, column, this.responseLayout);\r\n        items = this.engine.nodes;\r\n        this.engine.nodes = [];\r\n        delete this.responseLayout;\r\n      } else this.engine.cacheLayout(items, maxColumn, true);\r\n    }\r\n\r\n    // if given a different callback, temporally set it as global option so creating will use it\r\n    const prevCB = GridStack.addRemoveCB;\r\n    if (typeof (addRemove) === 'function') GridStack.addRemoveCB = addRemove as AddRemoveFcn;\r\n\r\n    const removed: GridStackNode[] = [];\r\n    this.batchUpdate();\r\n\r\n    // if we are loading from empty temporarily remove animation\r\n    const blank = !this.engine.nodes.length;\r\n    const noAnim = blank && this.opts.animate;\r\n    if (noAnim) this.setAnimation(false);\r\n\r\n    // see if any items are missing from new layout and need to be removed first\r\n    if (!blank && addRemove) {\r\n      const copyNodes = [...this.engine.nodes]; // don't loop through array you modify\r\n      copyNodes.forEach(n => {\r\n        if (!n.id) return;\r\n        const item = Utils.find(items, n.id);\r\n        if (!item) {\r\n          if (GridStack.addRemoveCB) GridStack.addRemoveCB(this.el, n, false, false);\r\n          removed.push(n); // batch keep track\r\n          this.removeWidget(n.el, true, false);\r\n        }\r\n      });\r\n    }\r\n\r\n    // now add/update the widgets - starting with removing items in the new layout we will reposition\r\n    // to reduce collision and add no-coord ones at next available spot\r\n    this.engine._loading = true; // help with collision\r\n    const updateNodes: GridStackWidget[] = [];\r\n    this.engine.nodes = this.engine.nodes.filter(n => {\r\n      if (Utils.find(items, n.id)) { updateNodes.push(n); return false; } // remove if found from list\r\n      return true;\r\n    });\r\n    items.forEach(w => {\r\n      const item = Utils.find(updateNodes, w.id);\r\n      if (item) {\r\n        // if item sizes to content, re-use the exiting height so it's a better guess at the final size (same if width doesn't change)\r\n        if (Utils.shouldSizeToContent(item)) w.h = item.h;\r\n        // check if missing coord, in which case find next empty slot with new (or old if missing) sizes\r\n        this.engine.nodeBoundFix(w);\r\n        if (w.autoPosition || w.x === undefined || w.y === undefined) {\r\n          w.w = w.w || item.w;\r\n          w.h = w.h || item.h;\r\n          this.engine.findEmptyPosition(w);\r\n        }\r\n\r\n        // add back to current list BUT force a collision check if it 'appears' we didn't change to make sure we don't overlap others now\r\n        this.engine.nodes.push(item);\r\n        if (Utils.samePos(item, w) && this.engine.nodes.length > 1) {\r\n          this.moveNode(item, { ...w, forceCollide: true });\r\n          Utils.copyPos(w, item); // use possily updated values before update() is called next (no-op since already moved)\r\n        }\r\n\r\n        this.update(item.el, w);\r\n\r\n        if (w.subGridOpts?.children) { // update any sub grid as well\r\n          const sub = item.el.querySelector('.grid-stack') as GridHTMLElement;\r\n          if (sub && sub.gridstack) {\r\n            sub.gridstack.load(w.subGridOpts.children); // TODO: support updating grid options ?\r\n          }\r\n        }\r\n      } else if (addRemove) {\r\n        this.addWidget(w);\r\n      }\r\n    });\r\n\r\n    delete this.engine._loading; // done loading\r\n    this.engine.removedNodes = removed;\r\n    this.batchUpdate(false);\r\n\r\n    // after commit, clear that flag\r\n    delete this._ignoreLayoutsNodeChange;\r\n    delete this.engine.skipCacheUpdate;\r\n    prevCB ? GridStack.addRemoveCB = prevCB : delete GridStack.addRemoveCB;\r\n    if (noAnim) this.setAnimation(true, true); // delay adding animation back\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * use before calling a bunch of `addWidget()` to prevent un-necessary relayouts in between (more efficient)\r\n   * and get a single event callback. You will see no changes until `batchUpdate(false)` is called.\r\n   */\r\n  public batchUpdate(flag = true): GridStack {\r\n    this.engine.batchUpdate(flag);\r\n    if (!flag) {\r\n      this._updateContainerHeight();\r\n      this._triggerRemoveEvent();\r\n      this._triggerAddEvent();\r\n      this._triggerChangeEvent();\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Gets the current cell height in pixels. This takes into account the unit type and converts to pixels if necessary.\r\n   * \r\n   * @param forcePixel if true, forces conversion to pixels even when cellHeight is specified in other units\r\n   * @returns the cell height in pixels\r\n   * \r\n   * @example\r\n   * const height = grid.getCellHeight();\r\n   * console.log('Cell height:', height, 'px');\r\n   * \r\n   * // Force pixel conversion\r\n   * const pixelHeight = grid.getCellHeight(true);\r\n   */\r\n  public getCellHeight(forcePixel = false): number {\r\n    if (this.opts.cellHeight && this.opts.cellHeight !== 'auto' &&\r\n      (!forcePixel || !this.opts.cellHeightUnit || this.opts.cellHeightUnit === 'px')) {\r\n      return this.opts.cellHeight as number;\r\n    }\r\n    // do rem/em/cm/mm to px conversion\r\n    if (this.opts.cellHeightUnit === 'rem') {\r\n      return (this.opts.cellHeight as number) * parseFloat(getComputedStyle(document.documentElement).fontSize);\r\n    }\r\n    if (this.opts.cellHeightUnit === 'em') {\r\n      return (this.opts.cellHeight as number) * parseFloat(getComputedStyle(this.el).fontSize);\r\n    }\r\n    if (this.opts.cellHeightUnit === 'cm') {\r\n      // 1cm = 96px/2.54. See https://www.w3.org/TR/css-values-3/#absolute-lengths\r\n      return (this.opts.cellHeight as number) * (96 / 2.54);\r\n    }\r\n    if (this.opts.cellHeightUnit === 'mm') {\r\n      return (this.opts.cellHeight as number) * (96 / 2.54) / 10;\r\n    }\r\n    // else get first cell height\r\n    const el = this.el.querySelector('.' + this.opts.itemClass) as HTMLElement;\r\n    if (el) {\r\n      const h = Utils.toNumber(el.getAttribute('gs-h')) || 1; // since we don't write 1 anymore\r\n      return Math.round(el.offsetHeight / h);\r\n    }\r\n    // else do entire grid and # of rows (but doesn't work if min-height is the actual constrain)\r\n    const rows = parseInt(this.el.getAttribute('gs-current-row'));\r\n    return rows ? Math.round(this.el.getBoundingClientRect().height / rows) : this.opts.cellHeight as number;\r\n  }\r\n\r\n  /**\r\n   * Update current cell height - see `GridStackOptions.cellHeight` for format by updating eh Browser CSS variable.\r\n   *\r\n   * @param val the cell height. Options:\r\n   *   - `undefined`: cells content will be made square (match width minus margin)\r\n   *   - `0`: the CSS will be generated by the application instead\r\n   *   - number: height in pixels\r\n   *   - string: height with units (e.g., '70px', '5rem', '2em')\r\n   * @returns the grid instance for chaining\r\n   *\r\n   * @example\r\n   * grid.cellHeight(100);     // 100px height\r\n   * grid.cellHeight('70px');  // explicit pixel height\r\n   * grid.cellHeight('5rem');  // relative to root font size\r\n   * grid.cellHeight(grid.cellWidth() * 1.2); // aspect ratio\r\n   * grid.cellHeight('auto');  // auto-size based on content\r\n   */\r\n  public cellHeight(val?: numberOrString): GridStack {\r\n\r\n    // if not called internally, check if we're changing mode\r\n    if (val !== undefined) {\r\n      if (this._isAutoCellHeight !== (val === 'auto')) {\r\n        this._isAutoCellHeight = (val === 'auto');\r\n        this._updateResizeEvent();\r\n      }\r\n    }\r\n    if (val === 'initial' || val === 'auto') { val = undefined; }\r\n\r\n    // make item content be square\r\n    if (val === undefined) {\r\n      const marginDiff = - (this.opts.marginRight as number) - (this.opts.marginLeft as number)\r\n        + (this.opts.marginTop as number) + (this.opts.marginBottom as number);\r\n      val = this.cellWidth() + marginDiff;\r\n    }\r\n\r\n    const data = Utils.parseHeight(val);\r\n    if (this.opts.cellHeightUnit === data.unit && this.opts.cellHeight === data.h) {\r\n      return this;\r\n    }\r\n    this.opts.cellHeightUnit = data.unit;\r\n    this.opts.cellHeight = data.h;\r\n\r\n    // finally update var and container\r\n    this.el.style.setProperty('--gs-cell-height', `${this.opts.cellHeight}${this.opts.cellHeightUnit}`);\r\n    this._updateContainerHeight();\r\n    this.resizeToContentCheck();\r\n\r\n    return this;\r\n  }\r\n\r\n  /** Gets current cell width. */\r\n  /**\r\n   * Gets the current cell width in pixels. This is calculated based on the grid container width divided by the number of columns.\r\n   * \r\n   * @returns the cell width in pixels\r\n   * \r\n   * @example\r\n   * const width = grid.cellWidth();\r\n   * console.log('Cell width:', width, 'px');\r\n   * \r\n   * // Use cell width to calculate widget dimensions\r\n   * const widgetWidth = width * 3; // For a 3-column wide widget\r\n   */\r\n  public cellWidth(): number {\r\n    return this._widthOrContainer() / this.getColumn();\r\n  }\r\n  /** return our expected width (or parent) , and optionally of window for dynamic column check */\r\n  protected _widthOrContainer(forBreakpoint = false): number {\r\n    // use `offsetWidth` or `clientWidth` (no scrollbar) ?\r\n    // https://stackoverflow.com/questions/21064101/understanding-offsetwidth-clientwidth-scrollwidth-and-height-respectively\r\n    return forBreakpoint && this.opts.columnOpts?.breakpointForWindow ? window.innerWidth : (this.el.clientWidth || this.el.parentElement.clientWidth || window.innerWidth);\r\n  }\r\n  /** checks for dynamic column count for our current size, returning true if changed */\r\n  protected checkDynamicColumn(): boolean {\r\n    const resp = this.opts.columnOpts;\r\n    if (!resp || (!resp.columnWidth && !resp.breakpoints?.length)) return false;\r\n    const column = this.getColumn();\r\n    let newColumn = column;\r\n    const w = this._widthOrContainer(true);\r\n    if (resp.columnWidth) {\r\n      newColumn = Math.min(Math.round(w / resp.columnWidth) || 1, resp.columnMax);\r\n    } else {\r\n      // find the closest breakpoint (already sorted big to small) that matches\r\n      newColumn = resp.columnMax;\r\n      let i = 0;\r\n      while (i < resp.breakpoints.length && w <= resp.breakpoints[i].w) {\r\n        newColumn = resp.breakpoints[i++].c || column;\r\n      }\r\n    }\r\n    if (newColumn !== column) {\r\n      const bk = resp.breakpoints?.find(b => b.c === newColumn);\r\n      this.column(newColumn, bk?.layout || resp.layout);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Re-layout grid items to reclaim any empty space. This is useful after removing widgets\r\n   * or when you want to optimize the layout.\r\n   * \r\n   * @param layout layout type. Options:\r\n   *   - 'compact' (default): might re-order items to fill any empty space  \r\n   *   - 'list': keep the widget left->right order the same, even if that means leaving an empty slot if things don't fit\r\n   * @param doSort re-sort items first based on x,y position. Set to false to do your own sorting ahead (default: true)\r\n   * @returns the grid instance for chaining\r\n   * \r\n   * @example\r\n   * // Compact layout after removing widgets\r\n   * grid.removeWidget('.widget-to-remove');\r\n   * grid.compact();\r\n   * \r\n   * // Use list layout (preserve order)\r\n   * grid.compact('list');\r\n   * \r\n   * // Compact without sorting first\r\n   * grid.compact('compact', false);\r\n   */\r\n  public compact(layout: CompactOptions = 'compact', doSort = true): GridStack {\r\n    this.engine.compact(layout, doSort);\r\n    this._triggerChangeEvent();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the number of columns in the grid. Will update existing widgets to conform to new number of columns,\r\n   * as well as cache the original layout so you can revert back to previous positions without loss.\r\n   * \r\n   * Requires `gridstack-extra.css` or `gridstack-extra.min.css` for [2-11] columns,\r\n   * else you will need to generate correct CSS.\r\n   * See: https://github.com/gridstack/gridstack.js#change-grid-columns\r\n   * \r\n   * @param column Integer > 0 (default 12)\r\n   * @param layout specify the type of re-layout that will happen. Options:\r\n   *   - 'moveScale' (default): scale widget positions and sizes\r\n   *   - 'move': keep widget sizes, only move positions\r\n   *   - 'scale': keep widget positions, only scale sizes  \r\n   *   - 'none': don't change widget positions or sizes\r\n   *   Note: items will never be outside of the current column boundaries.\r\n   *   Ignored for `column=1` as we always want to vertically stack.\r\n   * @returns the grid instance for chaining\r\n   * \r\n   * @example\r\n   * // Change to 6 columns with default scaling\r\n   * grid.column(6);\r\n   * \r\n   * // Change to 4 columns, only move positions\r\n   * grid.column(4, 'move');\r\n   * \r\n   * // Single column layout (vertical stack)\r\n   * grid.column(1);\r\n   */\r\n  public column(column: number, layout: ColumnOptions = 'moveScale'): GridStack {\r\n    if (!column || column < 1 || this.opts.column === column) return this;\r\n\r\n    const oldColumn = this.getColumn();\r\n    this.opts.column = column;\r\n    if (!this.engine) {\r\n      // called in constructor, noting else to do but remember that breakpoint layout\r\n      this.responseLayout = layout;\r\n      return this;\r\n    }\r\n\r\n    this.engine.column = column;\r\n    this.el.classList.remove('gs-' + oldColumn);\r\n    this._updateColumnVar();\r\n\r\n    // update the items now\r\n    this.engine.columnChanged(oldColumn, column, layout);\r\n    if (this._isAutoCellHeight) this.cellHeight();\r\n\r\n    this.resizeToContentCheck(true); // wait for width resizing\r\n\r\n    // and trigger our event last...\r\n    this._ignoreLayoutsNodeChange = true; // skip layout update\r\n    this._triggerChangeEvent();\r\n    delete this._ignoreLayoutsNodeChange;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Get the number of columns in the grid (default 12).\r\n   * \r\n   * @returns the current number of columns in the grid\r\n   * \r\n   * @example\r\n   * const columnCount = grid.getColumn(); // returns 12 by default\r\n   */\r\n  public getColumn(): number { return this.opts.column as number; }\r\n\r\n  /**\r\n   * Returns an array of grid HTML elements (no placeholder) - used to iterate through our children in DOM order.\r\n   * This method excludes placeholder elements and returns only actual grid items.\r\n   * \r\n   * @returns array of GridItemHTMLElement instances representing all grid items\r\n   * \r\n   * @example\r\n   * const items = grid.getGridItems();\r\n   * items.forEach(item => {\r\n   *   console.log('Item ID:', item.gridstackNode.id);\r\n   * });\r\n   */\r\n  public getGridItems(): GridItemHTMLElement[] {\r\n    return Array.from(this.el.children)\r\n      .filter((el: HTMLElement) => el.matches('.' + this.opts.itemClass) && !el.matches('.' + this.opts.placeholderClass)) as GridItemHTMLElement[];\r\n  }\r\n\r\n  /**\r\n   * Returns true if change callbacks should be ignored due to column change, sizeToContent, loading, etc.\r\n   * This is useful for callers who want to implement dirty flag functionality.\r\n   * \r\n   * @returns true if change callbacks are currently being ignored\r\n   * \r\n   * @example\r\n   * if (!grid.isIgnoreChangeCB()) {\r\n   *   // Process the change event\r\n   *   console.log('Grid layout changed');\r\n   * }\r\n   */\r\n  public isIgnoreChangeCB(): boolean { return this._ignoreLayoutsNodeChange; }\r\n\r\n  /**\r\n   * Destroys a grid instance. DO NOT CALL any methods or access any vars after this as it will free up members.\r\n   * @param removeDOM if `false` grid and items HTML elements will not be removed from the DOM (Optional. Default `true`).\r\n   */\r\n  public destroy(removeDOM = true): GridStack {\r\n    if (!this.el) return; // prevent multiple calls\r\n    this.offAll();\r\n    this._updateResizeEvent(true);\r\n    this.setStatic(true, false); // permanently removes DD but don't set CSS class (we're going away)\r\n    this.setAnimation(false);\r\n    if (!removeDOM) {\r\n      this.removeAll(removeDOM);\r\n      this.el.removeAttribute('gs-current-row');\r\n    } else {\r\n      this.el.parentNode.removeChild(this.el);\r\n    }\r\n    if (this.parentGridNode) delete this.parentGridNode.subGrid;\r\n    delete this.parentGridNode;\r\n    delete this.opts;\r\n    delete this._placeholder?.gridstackNode;\r\n    delete this._placeholder;\r\n    delete this.engine;\r\n    delete this.el.gridstack; // remove circular dependency that would prevent a freeing\r\n    delete this.el;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Enable/disable floating widgets (default: `false`). When enabled, widgets can float up to fill empty spaces.\r\n   * See [example](http://gridstackjs.com/demo/float.html)\r\n   * \r\n   * @param val true to enable floating, false to disable\r\n   * @returns the grid instance for chaining\r\n   * \r\n   * @example\r\n   * grid.float(true);  // Enable floating\r\n   * grid.float(false); // Disable floating (default)\r\n   */\r\n  public float(val: boolean): GridStack {\r\n    if (this.opts.float !== val) {\r\n      this.opts.float = this.engine.float = val;\r\n      this._triggerChangeEvent();\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Get the current float mode setting.\r\n   * \r\n   * @returns true if floating is enabled, false otherwise\r\n   * \r\n   * @example\r\n   * const isFloating = grid.getFloat();\r\n   * console.log('Floating enabled:', isFloating);\r\n   */\r\n  public getFloat(): boolean {\r\n    return this.engine.float;\r\n  }\r\n\r\n  /**\r\n   * Get the position of the cell under a pixel on screen.\r\n   * @param position the position of the pixel to resolve in\r\n   * absolute coordinates, as an object with top and left properties\r\n   * @param useDocRelative if true, value will be based on document position vs parent position (Optional. Default false).\r\n   * Useful when grid is within `position: relative` element\r\n   *\r\n   * Returns an object with properties `x` and `y` i.e. the column and row in the grid.\r\n   */\r\n  public getCellFromPixel(position: MousePosition, useDocRelative = false): CellPosition {\r\n    const box = this.el.getBoundingClientRect();\r\n    // console.log(`getBoundingClientRect left: ${box.left} top: ${box.top} w: ${box.w} h: ${box.h}`)\r\n    let containerPos: { top: number, left: number };\r\n    if (useDocRelative) {\r\n      containerPos = { top: box.top + document.documentElement.scrollTop, left: box.left };\r\n      // console.log(`getCellFromPixel scrollTop: ${document.documentElement.scrollTop}`)\r\n    } else {\r\n      containerPos = { top: this.el.offsetTop, left: this.el.offsetLeft }\r\n      // console.log(`getCellFromPixel offsetTop: ${containerPos.left} offsetLeft: ${containerPos.top}`)\r\n    }\r\n    const relativeLeft = position.left - containerPos.left;\r\n    const relativeTop = position.top - containerPos.top;\r\n\r\n    const columnWidth = (box.width / this.getColumn());\r\n    const rowHeight = (box.height / parseInt(this.el.getAttribute('gs-current-row')));\r\n\r\n    return { x: Math.floor(relativeLeft / columnWidth), y: Math.floor(relativeTop / rowHeight) };\r\n  }\r\n\r\n  /**\r\n   * Returns the current number of rows, which will be at least `minRow` if set.\r\n   * The row count is based on the highest positioned widget in the grid.\r\n   * \r\n   * @returns the current number of rows in the grid\r\n   * \r\n   * @example\r\n   * const rowCount = grid.getRow();\r\n   * console.log('Grid has', rowCount, 'rows');\r\n   */\r\n  public getRow(): number {\r\n    return Math.max(this.engine.getRow(), this.opts.minRow || 0);\r\n  }\r\n\r\n  /**\r\n   * Checks if the specified rectangular area is empty (no widgets occupy any part of it).\r\n   * \r\n   * @param x the x coordinate (column) of the area to check\r\n   * @param y the y coordinate (row) of the area to check  \r\n   * @param w the width in columns of the area to check\r\n   * @param h the height in rows of the area to check\r\n   * @returns true if the area is completely empty, false if any widget overlaps\r\n   * \r\n   * @example\r\n   * // Check if a 2x2 area at position (1,1) is empty\r\n   * if (grid.isAreaEmpty(1, 1, 2, 2)) {\r\n   *   console.log('Area is available for placement');\r\n   * }\r\n   */\r\n  public isAreaEmpty(x: number, y: number, w: number, h: number): boolean {\r\n    return this.engine.isAreaEmpty(x, y, w, h);\r\n  }\r\n\r\n  /**\r\n   * If you add elements to your grid by hand (or have some framework creating DOM), you have to tell gridstack afterwards to make them widgets.\r\n   * If you want gridstack to add the elements for you, use `addWidget()` instead.\r\n   * Makes the given element a widget and returns it.\r\n   * \r\n   * @param els widget or single selector to convert.\r\n   * @param options widget definition to use instead of reading attributes or using default sizing values\r\n   * @returns the converted GridItemHTMLElement\r\n   *\r\n   * @example\r\n   * const grid = GridStack.init();\r\n   * \r\n   * // Create HTML content manually, possibly looking like:\r\n   * // <div id=\"item-1\" gs-x=\"0\" gs-y=\"0\" gs-w=\"3\" gs-h=\"2\"></div>\r\n   * grid.el.innerHTML = '<div id=\"item-1\" gs-w=\"3\"></div><div id=\"item-2\"></div>';\r\n   * \r\n   * // Convert existing elements to widgets\r\n   * grid.makeWidget('#item-1'); // Uses gs-* attributes from DOM\r\n   * grid.makeWidget('#item-2', {w: 2, h: 1, content: 'Hello World'});\r\n   * \r\n   * // Or pass DOM element directly\r\n   * const element = document.getElementById('item-3');\r\n   * grid.makeWidget(element, {x: 0, y: 1, w: 4, h: 2});\r\n   */\r\n  public makeWidget(els: GridStackElement, options?: GridStackWidget): GridItemHTMLElement {\r\n    const el = GridStack.getElement(els);\r\n    if (!el || el.gridstackNode) return el;\r\n    if (!el.parentElement) this.el.appendChild(el);\r\n    this._prepareElement(el, true, options);\r\n    const node = el.gridstackNode;\r\n\r\n    this._updateContainerHeight();\r\n\r\n    // see if there is a sub-grid to create\r\n    if (node.subGridOpts) {\r\n      this.makeSubGrid(el, node.subGridOpts, undefined, false); // node.subGrid will be used as option in method, no need to pass\r\n    }\r\n\r\n    // if we're adding an item into 1 column make sure\r\n    // we don't override the larger 12 column layout that was already saved. #1985\r\n    let resetIgnoreLayoutsNodeChange: boolean;\r\n    if (this.opts.column === 1 && !this._ignoreLayoutsNodeChange) {\r\n      resetIgnoreLayoutsNodeChange = this._ignoreLayoutsNodeChange = true;\r\n    }\r\n    this._triggerAddEvent();\r\n    this._triggerChangeEvent();\r\n    if (resetIgnoreLayoutsNodeChange) delete this._ignoreLayoutsNodeChange;\r\n\r\n    return el;\r\n  }\r\n\r\n  /**\r\n   * Register event handler for grid events. You can call this on a single event name, or space separated list.\r\n   * \r\n   * Supported events:\r\n   * - `added`: Called when widgets are being added to a grid\r\n   * - `change`: Occurs when widgets change their position/size due to constraints or direct changes\r\n   * - `disable`: Called when grid becomes disabled\r\n   * - `dragstart`: Called when grid item starts being dragged\r\n   * - `drag`: Called while grid item is being dragged (for each new row/column value)\r\n   * - `dragstop`: Called after user is done moving the item, with updated DOM attributes\r\n   * - `dropped`: Called when an item has been dropped and accepted over a grid\r\n   * - `enable`: Called when grid becomes enabled\r\n   * - `removed`: Called when items are being removed from the grid\r\n   * - `resizestart`: Called before user starts resizing an item\r\n   * - `resize`: Called while grid item is being resized (for each new row/column value)\r\n   * - `resizestop`: Called after user is done resizing the item, with updated DOM attributes\r\n   * \r\n   * @param name event name(s) to listen for (space separated for multiple)\r\n   * @param callback function to call when event occurs\r\n   * @returns the grid instance for chaining\r\n   * \r\n   * @example\r\n   * // Listen to multiple events at once\r\n   * grid.on('added removed change', (event, items) => {\r\n   *   items.forEach(item => console.log('Item changed:', item));\r\n   * });\r\n   * \r\n   * // Listen to individual events\r\n   * grid.on('added', (event, items) => {\r\n   *   items.forEach(item => console.log('Added item:', item));\r\n   * });\r\n   */\r\n  public on(name: 'dropped', callback: GridStackDroppedHandler): GridStack\r\n  public on(name: 'enable' | 'disable', callback: GridStackEventHandler): GridStack\r\n  public on(name: 'change' | 'added' | 'removed' | 'resizecontent', callback: GridStackNodesHandler): GridStack\r\n  public on(name: 'resizestart' | 'resize' | 'resizestop' | 'dragstart' | 'drag' | 'dragstop', callback: GridStackElementHandler): GridStack\r\n  public on(name: string, callback: GridStackEventHandlerCallback): GridStack\r\n  public on(name: GridStackEvent | string, callback: GridStackEventHandlerCallback): GridStack {\r\n    // check for array of names being passed instead\r\n    if (name.indexOf(' ') !== -1) {\r\n      const names = name.split(' ') as GridStackEvent[];\r\n      names.forEach(name => this.on(name, callback));\r\n      return this;\r\n    }\r\n\r\n    // native CustomEvent handlers - cash the generic handlers so we can easily remove\r\n    if (name === 'change' || name === 'added' || name === 'removed' || name === 'enable' || name === 'disable') {\r\n      const noData = (name === 'enable' || name === 'disable');\r\n      if (noData) {\r\n        this._gsEventHandler[name] = (event: Event) => (callback as GridStackEventHandler)(event);\r\n      } else {\r\n        this._gsEventHandler[name] = (event: CustomEvent) => {if (event.detail) (callback as GridStackNodesHandler)(event, event.detail)};\r\n      }\r\n      this.el.addEventListener(name, this._gsEventHandler[name]);\r\n    } else if (name === 'drag' || name === 'dragstart' || name === 'dragstop' || name === 'resizestart' || name === 'resize'\r\n      || name === 'resizestop' || name === 'dropped' || name === 'resizecontent') {\r\n      // drag&drop stop events NEED to be call them AFTER we update node attributes so handle them ourself.\r\n      // do same for start event to make it easier...\r\n      this._gsEventHandler[name] = callback;\r\n    } else {\r\n      console.error('GridStack.on(' + name + ') event not supported');\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * unsubscribe from the 'on' event GridStackEvent\r\n   * @param name of the event (see possible values) or list of names space separated\r\n   */\r\n  public off(name: GridStackEvent | string): GridStack {\r\n    // check for array of names being passed instead\r\n    if (name.indexOf(' ') !== -1) {\r\n      const names = name.split(' ') as GridStackEvent[];\r\n      names.forEach(name => this.off(name));\r\n      return this;\r\n    }\r\n\r\n    if (name === 'change' || name === 'added' || name === 'removed' || name === 'enable' || name === 'disable') {\r\n      // remove native CustomEvent handlers\r\n      if (this._gsEventHandler[name]) {\r\n        this.el.removeEventListener(name, this._gsEventHandler[name]);\r\n      }\r\n    }\r\n    delete this._gsEventHandler[name];\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Remove all event handlers from the grid. This is useful for cleanup when destroying a grid.\r\n   * \r\n   * @returns the grid instance for chaining\r\n   * \r\n   * @example\r\n   * grid.offAll(); // Remove all event listeners\r\n   */\r\n  public offAll(): GridStack {\r\n    Object.keys(this._gsEventHandler).forEach((key: GridStackEvent) => this.off(key));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes widget from the grid.\r\n   * @param el  widget or selector to modify\r\n   * @param removeDOM if `false` DOM element won't be removed from the tree (Default? true).\r\n   * @param triggerEvent if `false` (quiet mode) element will not be added to removed list and no 'removed' callbacks will be called (Default? true).\r\n   */\r\n  public removeWidget(els: GridStackElement, removeDOM = true, triggerEvent = true): GridStack {\r\n    if (!els) { console.error('Error: GridStack.removeWidget(undefined) called'); return this; }\r\n\r\n    GridStack.getElements(els).forEach(el => {\r\n      if (el.parentElement && el.parentElement !== this.el) return; // not our child!\r\n      let node = el.gridstackNode;\r\n      // For Meteor support: https://github.com/gridstack/gridstack.js/pull/272\r\n      if (!node) {\r\n        node = this.engine.nodes.find(n => el === n.el);\r\n      }\r\n      if (!node) return;\r\n\r\n      if (removeDOM && GridStack.addRemoveCB) {\r\n        GridStack.addRemoveCB(this.el, node, false, false);\r\n      }\r\n\r\n      // remove our DOM data (circular link) and drag&drop permanently\r\n      delete el.gridstackNode;\r\n      this._removeDD(el);\r\n\r\n      this.engine.removeNode(node, removeDOM, triggerEvent);\r\n\r\n      if (removeDOM && el.parentElement) {\r\n        el.remove(); // in batch mode engine.removeNode doesn't call back to remove DOM\r\n      }\r\n    });\r\n    if (triggerEvent) {\r\n      this._triggerRemoveEvent();\r\n      this._triggerChangeEvent();\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes all widgets from the grid.\r\n   * @param removeDOM if `false` DOM elements won't be removed from the tree (Default? `true`).\r\n   * @param triggerEvent if `false` (quiet mode) element will not be added to removed list and no 'removed' callbacks will be called (Default? true).\r\n   */\r\n  public removeAll(removeDOM = true, triggerEvent = true): GridStack {\r\n    // always remove our DOM data (circular link) before list gets emptied and drag&drop permanently\r\n    this.engine.nodes.forEach(n => {\r\n      if (removeDOM && GridStack.addRemoveCB) {\r\n        GridStack.addRemoveCB(this.el, n, false, false);\r\n      }\r\n      delete n.el.gridstackNode;\r\n      if (!this.opts.staticGrid) this._removeDD(n.el);\r\n    });\r\n    this.engine.removeAll(removeDOM, triggerEvent);\r\n    if (triggerEvent) this._triggerRemoveEvent();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Toggle the grid animation state.  Toggles the `grid-stack-animate` class.\r\n   * @param doAnimate if true the grid will animate.\r\n   * @param delay if true setting will be set on next event loop.\r\n   */\r\n  public setAnimation(doAnimate = this.opts.animate, delay?: boolean): GridStack {\r\n    if (delay) {\r\n      // delay, but check to make sure grid (opt) is still around\r\n      setTimeout(() => { if (this.opts) this.setAnimation(doAnimate) });\r\n    } else if (doAnimate) {\r\n      this.el.classList.add('grid-stack-animate');\r\n    } else {\r\n      this.el.classList.remove('grid-stack-animate');\r\n    }\r\n    this.opts.animate = doAnimate;\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  private hasAnimationCSS(): boolean { return this.el.classList.contains('grid-stack-animate') }\r\n\r\n  /**\r\n   * Toggle the grid static state, which permanently removes/add Drag&Drop support, unlike disable()/enable() that just turns it off/on.\r\n   * Also toggle the grid-stack-static class.\r\n   * @param val if true the grid become static.\r\n   * @param updateClass true (default) if css class gets updated\r\n   * @param recurse true (default) if sub-grids also get updated\r\n   */\r\n  public setStatic(val: boolean, updateClass = true, recurse = true): GridStack {\r\n    if (!!this.opts.staticGrid === val) return this;\r\n    val ? this.opts.staticGrid = true : delete this.opts.staticGrid;\r\n    this._setupRemoveDrop();\r\n    this._setupAcceptWidget();\r\n    this.engine.nodes.forEach(n => {\r\n      this.prepareDragDrop(n.el); // either delete or init Drag&drop\r\n      if (n.subGrid && recurse) n.subGrid.setStatic(val, updateClass, recurse);\r\n    });\r\n    if (updateClass) { this._setStaticClass(); }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Updates the passed in options on the grid (similar to update(widget) for for the grid options).\r\n   * @param options PARTIAL grid options to update - only items specified will be updated.\r\n   * NOTE: not all options updating are currently supported (lot of code, unlikely to change)\r\n   */\r\n  public updateOptions(o: GridStackOptions): GridStack {\r\n    const opts = this.opts;\r\n    if (o === opts) return this; // nothing to do\r\n    if (o.acceptWidgets !== undefined) { opts.acceptWidgets = o.acceptWidgets; this._setupAcceptWidget(); }\r\n    if (o.animate !== undefined) this.setAnimation(o.animate);\r\n    if (o.cellHeight) this.cellHeight(o.cellHeight);\r\n    if (o.class !== undefined && o.class !== opts.class) { if (opts.class) this.el.classList.remove(opts.class); if (o.class) this.el.classList.add(o.class); }\r\n    // responsive column take over actual count (keep what we have now)\r\n    if (o.columnOpts) {\r\n      this.opts.columnOpts = o.columnOpts;\r\n      this.checkDynamicColumn();\r\n    } else if (o.columnOpts === null && this.opts.columnOpts) {\r\n      delete this.opts.columnOpts;\r\n      this._updateResizeEvent();\r\n    } else if (typeof(o.column) === 'number') this.column(o.column);\r\n    if (o.margin !== undefined) this.margin(o.margin);\r\n    if (o.staticGrid !== undefined) this.setStatic(o.staticGrid);\r\n    if (o.disableDrag !== undefined && !o.staticGrid) this.enableMove(!o.disableDrag);\r\n    if (o.disableResize !== undefined && !o.staticGrid) this.enableResize(!o.disableResize);\r\n    if (o.float !== undefined) this.float(o.float);\r\n    if (o.row !== undefined) {\r\n      opts.minRow = opts.maxRow = opts.row = o.row;\r\n      this._updateContainerHeight();\r\n    } else {\r\n      if (o.minRow !== undefined) { opts.minRow = o.minRow; this._updateContainerHeight(); }\r\n      if (o.maxRow !== undefined) opts.maxRow = o.maxRow;\r\n    }\r\n    if (o.children?.length) this.load(o.children);\r\n    // TBD if we have a real need for these (more complex code)\r\n    // alwaysShowResizeHandle, draggable, handle, handleClass, itemClass, layout, placeholderClass, placeholderText, resizable, removable, row,...\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Updates widget position/size and other info. This is used to change widget properties after creation.\r\n   * Can update position, size, content, and other widget properties.\r\n   * \r\n   * Note: If you need to call this on all nodes, use load() instead which will update what changed.\r\n   * Setting the same x,y for multiple items will be indeterministic and likely unwanted.\r\n   * \r\n   * @param els widget element(s) or selector to modify\r\n   * @param opt new widget options (x,y,w,h, etc.). Only those set will be updated.\r\n   * @returns the grid instance for chaining\r\n   * \r\n   * @example\r\n   * // Update widget size and position\r\n   * grid.update('.my-widget', { x: 2, y: 1, w: 3, h: 2 });\r\n   * \r\n   * // Update widget content\r\n   * grid.update(widget, { content: '<p>New content</p>' });\r\n   * \r\n   * // Update multiple properties\r\n   * grid.update('#my-widget', {\r\n   *   w: 4,\r\n   *   h: 3,\r\n   *   noResize: true,\r\n   *   locked: true\r\n   * });\r\n   */\r\n  public update(els: GridStackElement, opt: GridStackWidget): GridStack {\r\n\r\n    GridStack.getElements(els).forEach(el => {\r\n      const n = el?.gridstackNode;\r\n      if (!n) return;\r\n      const w = {...Utils.copyPos({}, n), ...Utils.cloneDeep(opt)}; // make a copy we can modify in case they re-use it or multiple items\r\n      this.engine.nodeBoundFix(w);\r\n      delete w.autoPosition;\r\n\r\n      // move/resize widget if anything changed\r\n      const keys = ['x', 'y', 'w', 'h'];\r\n      let m: GridStackWidget;\r\n      if (keys.some(k => w[k] !== undefined && w[k] !== n[k])) {\r\n        m = {};\r\n        keys.forEach(k => {\r\n          m[k] = (w[k] !== undefined) ? w[k] : n[k];\r\n          delete w[k];\r\n        });\r\n      }\r\n      // for a move as well IFF there is any min/max fields set\r\n      if (!m && (w.minW || w.minH || w.maxW || w.maxH)) {\r\n        m = {}; // will use node position but validate values\r\n      }\r\n\r\n      // check for content changing\r\n      if (w.content !== undefined) {\r\n        const itemContent = el.querySelector('.grid-stack-item-content') as HTMLElement;\r\n        if (itemContent && itemContent.textContent !== w.content) {\r\n          n.content = w.content;\r\n          GridStack.renderCB(itemContent, w);\r\n          // restore any sub-grid back\r\n          if (n.subGrid?.el) {\r\n            itemContent.appendChild(n.subGrid.el);\r\n            n.subGrid._updateContainerHeight();\r\n          }\r\n        }\r\n        delete w.content;\r\n      }\r\n\r\n      // any remaining fields are assigned, but check for dragging changes, resize constrain\r\n      let changed = false;\r\n      let ddChanged = false;\r\n      for (const key in w) {\r\n        if (key[0] !== '_' && n[key] !== w[key]) {\r\n          n[key] = w[key];\r\n          changed = true;\r\n          ddChanged = ddChanged || (!this.opts.staticGrid && (key === 'noResize' || key === 'noMove' || key === 'locked'));\r\n        }\r\n      }\r\n      Utils.sanitizeMinMax(n);\r\n\r\n      // finally move the widget and update attr\r\n      if (m) {\r\n        const widthChanged = (m.w !== undefined && m.w !== n.w);\r\n        this.moveNode(n, m);\r\n        if (widthChanged && n.subGrid) {\r\n          // if we're animating the client size hasn't changed yet, so force a change (not exact size)\r\n          n.subGrid.onResize(this.hasAnimationCSS() ? n.w : undefined);\r\n        } else {\r\n          this.resizeToContentCheck(widthChanged, n);\r\n        }\r\n        delete n._orig; // clear out original position now that we moved #2669\r\n      }\r\n      if (m || changed) {\r\n        this._writeAttr(el, n);\r\n      }\r\n      if (ddChanged) {\r\n        this.prepareDragDrop(n.el);\r\n      }\r\n      if (GridStack.updateCB) GridStack.updateCB(n); // call user callback so they know widget got updated\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  private moveNode(n: GridStackNode, m: GridStackMoveOpts) {\r\n    const wasUpdating = n._updating;\r\n    if (!wasUpdating) this.engine.cleanNodes().beginUpdate(n);\r\n    this.engine.moveNode(n, m);\r\n    this._updateContainerHeight();\r\n    if (!wasUpdating) {\r\n      this._triggerChangeEvent();\r\n      this.engine.endUpdate();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates widget height to match the content height to avoid vertical scrollbars or dead space.\r\n   * This automatically adjusts the widget height based on its content size.\r\n   * \r\n   * Note: This assumes only 1 child under resizeToContentParent='.grid-stack-item-content' \r\n   * (sized to gridItem minus padding) that represents the entire content size.\r\n   * \r\n   * @param el the grid item element to resize\r\n   * \r\n   * @example\r\n   * // Resize a widget to fit its content\r\n   * const widget = document.querySelector('.grid-stack-item');\r\n   * grid.resizeToContent(widget);\r\n   * \r\n   * // This is commonly used with dynamic content:\r\n   * widget.querySelector('.content').innerHTML = 'New longer content...';\r\n   * grid.resizeToContent(widget);\r\n   */\r\n  public resizeToContent(el: GridItemHTMLElement) {\r\n    if (!el) return;\r\n    el.classList.remove('size-to-content-max');\r\n    if (!el.clientHeight) return; // 0 when hidden, skip\r\n    const n = el.gridstackNode;\r\n    if (!n) return;\r\n    const grid = n.grid;\r\n    if (!grid || el.parentElement !== grid.el) return; // skip if we are not inside a grid\r\n    const cell = grid.getCellHeight(true);\r\n    if (!cell) return;\r\n    let height = n.h ? n.h * cell : el.clientHeight; // getBoundingClientRect().height seem to flicker back and forth\r\n    let item: Element;\r\n    if (n.resizeToContentParent) item = el.querySelector(n.resizeToContentParent);\r\n    if (!item) item = el.querySelector(GridStack.resizeToContentParent);\r\n    if (!item) return;\r\n    const padding = el.clientHeight - item.clientHeight; // full - available height to our child (minus border, padding...)\r\n    const itemH = n.h ? n.h * cell - padding : item.clientHeight; // calculated to what cellHeight is or will become (rather than actual to prevent waiting for animation to finish)\r\n    let wantedH: number;\r\n    if (n.subGrid) {\r\n      // sub-grid - use their actual row count * their cell height, BUT append any content outside of the grid (eg: above text)\r\n      wantedH = n.subGrid.getRow() * n.subGrid.getCellHeight(true);\r\n      const subRec = n.subGrid.el.getBoundingClientRect();\r\n      const parentRec = el.getBoundingClientRect();\r\n      wantedH += subRec.top - parentRec.top;\r\n    } else if (n.subGridOpts?.children?.length) {\r\n      // not sub-grid just yet (case above) wait until we do\r\n      return;\r\n    } else {\r\n      // NOTE: clientHeight & getBoundingClientRect() is undefined for text and other leaf nodes. use <div> container!\r\n      const child = item.firstElementChild;\r\n      if (!child) {\r\n        console.error(`Error: GridStack.resizeToContent() widget id:${n.id} '${GridStack.resizeToContentParent}'.firstElementChild is null, make sure to have a div like container. Skipping sizing.`);\r\n        return;\r\n      }\r\n      wantedH = child.getBoundingClientRect().height || itemH;\r\n    }\r\n    if (itemH === wantedH) return;\r\n    height += wantedH - itemH;\r\n    let h = Math.ceil(height / cell);\r\n    // check for min/max and special sizing\r\n    const softMax = Number.isInteger(n.sizeToContent) ? n.sizeToContent as number : 0;\r\n    if (softMax && h > softMax) {\r\n      h = softMax;\r\n      el.classList.add('size-to-content-max');  // get v-scroll back\r\n    }\r\n    if (n.minH && h < n.minH) h = n.minH;\r\n    else if (n.maxH && h > n.maxH) h = n.maxH;\r\n    if (h !== n.h) {\r\n      grid._ignoreLayoutsNodeChange = true;\r\n      grid.moveNode(n, { h });\r\n      delete grid._ignoreLayoutsNodeChange;\r\n    }\r\n  }\r\n\r\n  /** call the user resize (so they can do extra work) else our build in version */\r\n  private resizeToContentCBCheck(el: GridItemHTMLElement) {\r\n    if (GridStack.resizeToContentCB) GridStack.resizeToContentCB(el);\r\n    else this.resizeToContent(el);\r\n  }\r\n\r\n  /**\r\n   * Rotate widgets by swapping their width and height. This is typically called when the user presses 'r' during dragging.\r\n   * The rotation swaps the w/h dimensions and adjusts min/max constraints accordingly.\r\n   * \r\n   * @param els widget element(s) or selector to rotate\r\n   * @param relative optional pixel coordinate relative to upper/left corner to rotate around (keeps that cell under cursor)\r\n   * @returns the grid instance for chaining\r\n   * \r\n   * @example\r\n   * // Rotate a specific widget\r\n   * grid.rotate('.my-widget');\r\n   * \r\n   * // Rotate with relative positioning during drag\r\n   * grid.rotate(widget, { left: 50, top: 30 });\r\n   */\r\n  public rotate(els: GridStackElement, relative?: Position): GridStack {\r\n    GridStack.getElements(els).forEach(el => {\r\n      const n = el.gridstackNode;\r\n      if (!Utils.canBeRotated(n)) return;\r\n      const rot: GridStackWidget = { w: n.h, h: n.w, minH: n.minW, minW: n.minH, maxH: n.maxW, maxW: n.maxH };\r\n      // if given an offset, adjust x/y by column/row bounds when user presses 'r' during dragging\r\n      if (relative) {\r\n        const pivotX = relative.left > 0 ? Math.floor(relative.left / this.cellWidth()) : 0;\r\n        const pivotY = relative.top > 0 ? Math.floor(relative.top / (this.opts.cellHeight as number)) : 0;\r\n        rot.x = n.x + pivotX - (n.h - (pivotY+1));\r\n        rot.y = (n.y + pivotY) - pivotX;\r\n      }\r\n      Object.keys(rot).forEach(k => { if (rot[k] === undefined) delete rot[k]; });\r\n      const _orig = n._orig;\r\n      this.update(el, rot);\r\n      n._orig = _orig; // restore as move() will delete it\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Updates the margins which will set all 4 sides at once - see `GridStackOptions.margin` for format options.\r\n   * Supports CSS string format of 1, 2, or 4 values or a single number.\r\n   * \r\n   * @param value margin value - can be:\r\n   *   - Single number: `10` (applies to all sides)\r\n   *   - Two values: `'10px 20px'` (top/bottom, left/right)\r\n   *   - Four values: `'10px 20px 5px 15px'` (top, right, bottom, left)\r\n   * @returns the grid instance for chaining\r\n   * \r\n   * @example\r\n   * grid.margin(10);           // 10px all sides\r\n   * grid.margin('10px 20px');  // 10px top/bottom, 20px left/right\r\n   * grid.margin('5px 10px 15px 20px'); // Different for each side\r\n   */\r\n  public margin(value: numberOrString): GridStack {\r\n    const isMultiValue = (typeof value === 'string' && value.split(' ').length > 1);\r\n    // check if we can skip... won't check if multi values (too much hassle)\r\n    if (!isMultiValue) {\r\n      const data = Utils.parseHeight(value);\r\n      if (this.opts.marginUnit === data.unit && this.opts.margin === data.h) return;\r\n    }\r\n    // re-use existing margin handling\r\n    this.opts.margin = value;\r\n    this.opts.marginTop = this.opts.marginBottom = this.opts.marginLeft = this.opts.marginRight = undefined;\r\n    this._initMargin();\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns the current margin value as a number (undefined if the 4 sides don't match).\r\n   * This only returns a number if all sides have the same margin value.\r\n   * \r\n   * @returns the margin value in pixels, or undefined if sides have different values\r\n   * \r\n   * @example\r\n   * const margin = grid.getMargin();\r\n   * if (margin !== undefined) {\r\n   *   console.log('Uniform margin:', margin, 'px');\r\n   * } else {\r\n   *   console.log('Margins are different on different sides');\r\n   * }\r\n   */\r\n  public getMargin(): number { return this.opts.margin as number; }\r\n\r\n  /**\r\n   * Returns true if the height of the grid will be less than the vertical\r\n   * constraint. Always returns true if grid doesn't have height constraint.\r\n   * @param node contains x,y,w,h,auto-position options\r\n   *\r\n   * @example\r\n   * if (grid.willItFit(newWidget)) {\r\n   *   grid.addWidget(newWidget);\r\n   * } else {\r\n   *   alert('Not enough free space to place the widget');\r\n   * }\r\n   */\r\n  public willItFit(node: GridStackWidget): boolean {\r\n    // support legacy call for now\r\n    if (arguments.length > 1) {\r\n      console.warn('gridstack.ts: `willItFit(x,y,w,h,autoPosition)` is deprecated. Use `willItFit({x, y,...})`. It will be removed soon');\r\n      // eslint-disable-next-line prefer-rest-params\r\n      const a = arguments; let i = 0,\r\n        w: GridStackWidget = { x: a[i++], y: a[i++], w: a[i++], h: a[i++], autoPosition: a[i++] };\r\n      return this.willItFit(w);\r\n    }\r\n    return this.engine.willItFit(node);\r\n  }\r\n\r\n  /** @internal */\r\n  protected _triggerChangeEvent(): GridStack {\r\n    if (this.engine.batchMode) return this;\r\n    const elements = this.engine.getDirtyNodes(true); // verify they really changed\r\n    if (elements && elements.length) {\r\n      if (!this._ignoreLayoutsNodeChange) {\r\n        this.engine.layoutsNodesChange(elements);\r\n      }\r\n      this._triggerEvent('change', elements);\r\n    }\r\n    this.engine.saveInitial(); // we called, now reset initial values & dirty flags\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _triggerAddEvent(): GridStack {\r\n    if (this.engine.batchMode) return this;\r\n    if (this.engine.addedNodes?.length) {\r\n      if (!this._ignoreLayoutsNodeChange) {\r\n        this.engine.layoutsNodesChange(this.engine.addedNodes);\r\n      }\r\n      // prevent added nodes from also triggering 'change' event (which is called next)\r\n      this.engine.addedNodes.forEach(n => { delete n._dirty; });\r\n      const addedNodes = [...this.engine.addedNodes];\r\n      this.engine.addedNodes = [];\r\n      this._triggerEvent('added', addedNodes);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  public _triggerRemoveEvent(): GridStack {\r\n    if (this.engine.batchMode) return this;\r\n    if (this.engine.removedNodes?.length) {\r\n      const removedNodes = [...this.engine.removedNodes];\r\n      this.engine.removedNodes = [];\r\n      this._triggerEvent('removed', removedNodes);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _triggerEvent(type: string, data?: GridStackNode[]): GridStack {\r\n    const event = data ? new CustomEvent(type, { bubbles: false, detail: data }) : new Event(type);\r\n    // check if we're nested, and if so call the outermost grid to trigger the event\r\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    let grid: GridStack = this;\r\n    while (grid.parentGridNode) grid = grid.parentGridNode.grid;\r\n    grid.el.dispatchEvent(event);\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _updateContainerHeight(): GridStack {\r\n    if (!this.engine || this.engine.batchMode) return this;\r\n    const parent = this.parentGridNode;\r\n    let row = this.getRow() + this._extraDragRow; // this checks for minRow already\r\n    const cellHeight = this.opts.cellHeight as number;\r\n    const unit = this.opts.cellHeightUnit;\r\n    if (!cellHeight) return this;\r\n\r\n    // check for css min height (non nested grid). TODO: support mismatch, say: min % while unit is px.\r\n    // If `minRow` was applied, don't override it with this check, and avoid performance issues\r\n    // (reflows) using `getComputedStyle`\r\n    if (!parent && !this.opts.minRow) {\r\n      const cssMinHeight = Utils.parseHeight(getComputedStyle(this.el)['minHeight']);\r\n      if (cssMinHeight.h > 0 && cssMinHeight.unit === unit) {\r\n        const minRow = Math.floor(cssMinHeight.h / cellHeight);\r\n        if (row < minRow) {\r\n          row = minRow;\r\n        }\r\n      }\r\n    }\r\n\r\n    this.el.setAttribute('gs-current-row', String(row));\r\n    this.el.style.removeProperty('min-height');\r\n    this.el.style.removeProperty('height');\r\n    if (row) {\r\n      // nested grids have 'insert:0' to fill the space of parent by default, but we may be taller so use min-height for possible scrollbars\r\n      this.el.style[parent ? 'minHeight' : 'height'] = row * cellHeight + unit;\r\n    }\r\n\r\n    // if we're a nested grid inside an sizeToContent item, tell it to resize itself too\r\n    if (parent && Utils.shouldSizeToContent(parent)) {\r\n      parent.grid.resizeToContentCBCheck(parent.el);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _prepareElement(el: GridItemHTMLElement, triggerAddEvent = false, node?: GridStackNode): GridStack {\r\n    node = node || this._readAttr(el);\r\n    el.gridstackNode = node;\r\n    node.el = el;\r\n    node.grid = this;\r\n    node = this.engine.addNode(node, triggerAddEvent);\r\n\r\n    // write the dom sizes and class\r\n    this._writeAttr(el, node);\r\n    el.classList.add(gridDefaults.itemClass, this.opts.itemClass);\r\n    const sizeToContent = Utils.shouldSizeToContent(node);\r\n    sizeToContent ? el.classList.add('size-to-content') : el.classList.remove('size-to-content');\r\n    if (sizeToContent) this.resizeToContentCheck(false, node);\r\n\r\n    if (!Utils.lazyLoad(node)) this.prepareDragDrop(node.el);\r\n\r\n    return this;\r\n  }\r\n\r\n  /** @internal write position CSS vars and x,y,w,h attributes (not used for CSS but by users) back to element */\r\n  protected _writePosAttr(el: HTMLElement, n: GridStackNode): GridStack {\r\n    // Avoid overwriting the inline style of the element during drag/resize, but always update the placeholder\r\n    if ((!n._moving && !n._resizing) || this._placeholder === el) {\r\n      // width/height:1 x/y:0 is set by default in the main CSS, so no need to set inlined vars\r\n      el.style.top = n.y ? (n.y === 1 ? `var(--gs-cell-height)` : `calc(${n.y} * var(--gs-cell-height))`) : null;\r\n      el.style.left = n.x ? (n.x === 1 ? `var(--gs-column-width)` : `calc(${n.x} * var(--gs-column-width))`) : null;\r\n      el.style.width = n.w > 1 ? `calc(${n.w} * var(--gs-column-width))` : null;\r\n      el.style.height = n.h > 1 ? `calc(${n.h} * var(--gs-cell-height))` : null;\r\n    }\r\n    // NOTE: those are technically not needed anymore (v12+) as we have CSS vars for everything, but some users depends on them to render item size using CSS\r\n    n.x > 0 ? el.setAttribute('gs-x', String(n.x)) : el.removeAttribute('gs-x');\r\n    n.y > 0 ? el.setAttribute('gs-y', String(n.y)) : el.removeAttribute('gs-y');\r\n    n.w > 1 ? el.setAttribute('gs-w', String(n.w)) : el.removeAttribute('gs-w');\r\n    n.h > 1 ? el.setAttribute('gs-h', String(n.h)) : el.removeAttribute('gs-h');\r\n    return this;\r\n  }\r\n\r\n  /** @internal call to write any default attributes back to element */\r\n  protected _writeAttr(el: HTMLElement, node: GridStackNode): GridStack {\r\n    if (!node) return this;\r\n    this._writePosAttr(el, node);\r\n\r\n    const attrs /*: GridStackWidget but strings */ = { // remaining attributes\r\n      // autoPosition: 'gs-auto-position', // no need to write out as already in node and doesn't affect CSS\r\n      noResize: 'gs-no-resize',\r\n      noMove: 'gs-no-move',\r\n      locked: 'gs-locked',\r\n      id: 'gs-id',\r\n      sizeToContent: 'gs-size-to-content',\r\n    };\r\n    for (const key in attrs) {\r\n      if (node[key]) { // 0 is valid for x,y only but done above already and not in list anyway\r\n        el.setAttribute(attrs[key], String(node[key]));\r\n      } else {\r\n        el.removeAttribute(attrs[key]);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** @internal call to read any default attributes from element */\r\n  protected _readAttr(el: HTMLElement, clearDefaultAttr = true): GridStackWidget {\r\n    const n: GridStackNode = {};\r\n    n.x = Utils.toNumber(el.getAttribute('gs-x'));\r\n    n.y = Utils.toNumber(el.getAttribute('gs-y'));\r\n    n.w = Utils.toNumber(el.getAttribute('gs-w'));\r\n    n.h = Utils.toNumber(el.getAttribute('gs-h'));\r\n    n.autoPosition = Utils.toBool(el.getAttribute('gs-auto-position'));\r\n    n.noResize = Utils.toBool(el.getAttribute('gs-no-resize'));\r\n    n.noMove = Utils.toBool(el.getAttribute('gs-no-move'));\r\n    n.locked = Utils.toBool(el.getAttribute('gs-locked'));\r\n    const attr = el.getAttribute('gs-size-to-content');\r\n    if (attr) {\r\n      if (attr === 'true' || attr === 'false') n.sizeToContent = Utils.toBool(attr);\r\n      else n.sizeToContent = parseInt(attr, 10);\r\n    }\r\n    n.id = el.getAttribute('gs-id');\r\n\r\n    // read but never written out\r\n    n.maxW = Utils.toNumber(el.getAttribute('gs-max-w'));\r\n    n.minW = Utils.toNumber(el.getAttribute('gs-min-w'));\r\n    n.maxH = Utils.toNumber(el.getAttribute('gs-max-h'));\r\n    n.minH = Utils.toNumber(el.getAttribute('gs-min-h'));\r\n\r\n    // v8.x optimization to reduce un-needed attr that don't render or are default CSS\r\n    if (clearDefaultAttr) {\r\n      if (n.w === 1) el.removeAttribute('gs-w');\r\n      if (n.h === 1) el.removeAttribute('gs-h');\r\n      if (n.maxW) el.removeAttribute('gs-max-w');\r\n      if (n.minW) el.removeAttribute('gs-min-w');\r\n      if (n.maxH) el.removeAttribute('gs-max-h');\r\n      if (n.minH) el.removeAttribute('gs-min-h');\r\n    }\r\n\r\n    // remove any key not found (null or false which is default, unless sizeToContent=false override)\r\n    for (const key in n) {\r\n      if (!n.hasOwnProperty(key)) return;\r\n      if (!n[key] && n[key] !== 0 && key !== 'sizeToContent') { // 0 can be valid value (x,y only really)\r\n        delete n[key];\r\n      }\r\n    }\r\n\r\n    return n;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _setStaticClass(): GridStack {\r\n    const classes = ['grid-stack-static'];\r\n\r\n    if (this.opts.staticGrid) {\r\n      this.el.classList.add(...classes);\r\n      this.el.setAttribute('gs-static', 'true');\r\n    } else {\r\n      this.el.classList.remove(...classes);\r\n      this.el.removeAttribute('gs-static');\r\n\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * called when we are being resized - check if the one Column Mode needs to be turned on/off\r\n   * and remember the prev columns we used, or get our count from parent, as well as check for cellHeight==='auto' (square)\r\n   * or `sizeToContent` gridItem options.\r\n   */\r\n  public onResize(clientWidth = this.el?.clientWidth): GridStack {\r\n    if (!clientWidth) return; // return if we're gone or no size yet (will get called again)\r\n    if (this.prevWidth === clientWidth) return; // no-op\r\n    this.prevWidth = clientWidth\r\n    // console.log('onResize ', clientWidth);\r\n\r\n    this.batchUpdate();\r\n\r\n    // see if we're nested and take our column count from our parent....\r\n    let columnChanged = false;\r\n    if (this._autoColumn && this.parentGridNode) {\r\n      if (this.opts.column !== this.parentGridNode.w) {\r\n        this.column(this.parentGridNode.w, this.opts.layout || 'list');\r\n        columnChanged = true;\r\n      }\r\n    } else {\r\n      // else check for dynamic column\r\n      columnChanged = this.checkDynamicColumn();\r\n    }\r\n\r\n    // make the cells content square again\r\n    if (this._isAutoCellHeight) this.cellHeight();\r\n\r\n    // update any nested grids, or items size\r\n    this.engine.nodes.forEach(n => {\r\n      if (n.subGrid) n.subGrid.onResize()\r\n    });\r\n\r\n    if (!this._skipInitialResize) this.resizeToContentCheck(columnChanged); // wait for anim of column changed (DOM reflow before we can size correctly)\r\n    delete this._skipInitialResize;\r\n\r\n    this.batchUpdate(false);\r\n\r\n    return this;\r\n  }\r\n\r\n  /** resizes content for given node (or all) if shouldSizeToContent() is true */\r\n  private resizeToContentCheck(delay = false, n: GridStackNode = undefined) {\r\n    if (!this.engine) return; // we've been deleted in between!\r\n\r\n    // update any gridItem height with sizeToContent, but wait for DOM $animation_speed to settle if we changed column count\r\n    // TODO: is there a way to know what the final (post animation) size of the content will be so we can animate the column width and height together rather than sequentially ?\r\n    if (delay && this.hasAnimationCSS()) return setTimeout(() => this.resizeToContentCheck(false, n), this.animationDelay);\r\n\r\n    if (n) {\r\n      if (Utils.shouldSizeToContent(n)) this.resizeToContentCBCheck(n.el);\r\n    } else if (this.engine.nodes.some(n => Utils.shouldSizeToContent(n))) {\r\n      const nodes = [...this.engine.nodes]; // in case order changes while resizing one\r\n      this.batchUpdate();\r\n      nodes.forEach(n => {\r\n        if (Utils.shouldSizeToContent(n)) this.resizeToContentCBCheck(n.el);\r\n      });\r\n      this._ignoreLayoutsNodeChange = true; // loop through each node will set/reset around each move, so set it here again\r\n      this.batchUpdate(false);\r\n      this._ignoreLayoutsNodeChange = false;\r\n    }\r\n    // call this regardless of shouldSizeToContent because widget might need to stretch to take available space after a resize\r\n    if (this._gsEventHandler['resizecontent']) this._gsEventHandler['resizecontent'](null, n ? [n] : this.engine.nodes);\r\n  }\r\n\r\n  /** add or remove the grid element size event handler */\r\n  protected _updateResizeEvent(forceRemove = false): GridStack {\r\n    // only add event if we're not nested (parent will call us) and we're auto sizing cells or supporting dynamic column (i.e. doing work)\r\n    // or supporting new sizeToContent option.\r\n    const trackSize = !this.parentGridNode && (this._isAutoCellHeight || this.opts.sizeToContent || this.opts.columnOpts\r\n      || this.engine.nodes.find(n => n.sizeToContent));\r\n\r\n    if (!forceRemove && trackSize && !this.resizeObserver) {\r\n      this._sizeThrottle = Utils.throttle(() => this.onResize(), this.opts.cellHeightThrottle);\r\n      this.resizeObserver = new ResizeObserver(() => this._sizeThrottle());\r\n      this.resizeObserver.observe(this.el);\r\n      this._skipInitialResize = true; // makeWidget will originally have called on startup\r\n    } else if ((forceRemove || !trackSize) && this.resizeObserver) {\r\n      this.resizeObserver.disconnect();\r\n      delete this.resizeObserver;\r\n      delete this._sizeThrottle;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /** @internal convert a potential selector into actual element */\r\n  public static getElement(els: GridStackElement = '.grid-stack-item'): GridItemHTMLElement { return Utils.getElement(els) }\r\n  /** @internal */\r\n  public static getElements(els: GridStackElement = '.grid-stack-item'): GridItemHTMLElement[] { return Utils.getElements(els) }\r\n  /** @internal */\r\n  public static getGridElement(els: GridStackElement): GridHTMLElement { return GridStack.getElement(els) }\r\n  /** @internal */\r\n  public static getGridElements(els: string): GridHTMLElement[] { return Utils.getElements(els) }\r\n\r\n  /** @internal initialize margin top/bottom/left/right and units */\r\n  protected _initMargin(): GridStack {\r\n    let data: HeightData;\r\n    let margin = 0;\r\n\r\n    // support passing multiple values like CSS (ex: '5px 10px 0 20px')\r\n    let margins: string[] = [];\r\n    if (typeof this.opts.margin === 'string') {\r\n      margins = this.opts.margin.split(' ')\r\n    }\r\n    if (margins.length === 2) { // top/bot, left/right like CSS\r\n      this.opts.marginTop = this.opts.marginBottom = margins[0];\r\n      this.opts.marginLeft = this.opts.marginRight = margins[1];\r\n    } else if (margins.length === 4) { // Clockwise like CSS\r\n      this.opts.marginTop = margins[0];\r\n      this.opts.marginRight = margins[1];\r\n      this.opts.marginBottom = margins[2];\r\n      this.opts.marginLeft = margins[3];\r\n    } else {\r\n      data = Utils.parseHeight(this.opts.margin);\r\n      this.opts.marginUnit = data.unit;\r\n      margin = this.opts.margin = data.h;\r\n    }\r\n\r\n    // see if top/bottom/left/right need to be set as well\r\n    const keys = ['marginTop', 'marginRight', 'marginBottom', 'marginLeft'];\r\n    keys.forEach(k => {\r\n      if (this.opts[k] === undefined) {\r\n        this.opts[k] = margin;\r\n      } else {\r\n        data = Utils.parseHeight(this.opts[k]);\r\n        this.opts[k] = data.h;\r\n        delete this.opts.margin;\r\n      }\r\n    });\r\n    this.opts.marginUnit = data.unit; // in case side were spelled out, use those units instead...\r\n    if (this.opts.marginTop === this.opts.marginBottom && this.opts.marginLeft === this.opts.marginRight && this.opts.marginTop === this.opts.marginRight) {\r\n      this.opts.margin = this.opts.marginTop; // makes it easier to check for no-ops in setMargin()\r\n    }\r\n\r\n    // finally Update the CSS margin variables (inside the cell height) */\r\n    const style = this.el.style;\r\n    style.setProperty('--gs-item-margin-top', `${this.opts.marginTop}${this.opts.marginUnit}`);\r\n    style.setProperty('--gs-item-margin-bottom', `${this.opts.marginBottom}${this.opts.marginUnit}`);\r\n    style.setProperty('--gs-item-margin-right', `${this.opts.marginRight}${this.opts.marginUnit}`);\r\n    style.setProperty('--gs-item-margin-left', `${this.opts.marginLeft}${this.opts.marginUnit}`);\r\n\r\n    return this;\r\n  }\r\n\r\n  /** @internal current version compiled in code */\r\n  static GDRev = '12.3.0';\r\n\r\n  /* ===========================================================================================\r\n   * drag&drop methods that used to be stubbed out and implemented in dd-gridstack.ts\r\n   * but caused loading issues in prod - see https://github.com/gridstack/gridstack.js/issues/2039\r\n   * ===========================================================================================\r\n   */\r\n\r\n  /**\r\n   * Get the global drag & drop implementation instance.\r\n   * This provides access to the underlying drag & drop functionality.\r\n   * \r\n   * @returns the DDGridStack instance used for drag & drop operations\r\n   * \r\n   * @example\r\n   * const dd = GridStack.getDD();\r\n   * // Access drag & drop functionality\r\n   */\r\n  public static getDD(): DDGridStack {\r\n    return dd;\r\n  }\r\n\r\n  /**\r\n   * call to setup dragging in from the outside (say toolbar), by specifying the class selection and options.\r\n   * Called during GridStack.init() as options, but can also be called directly (last param are used) in case the toolbar\r\n   * is dynamically create and needs to be set later.\r\n   * @param dragIn string selector (ex: '.sidebar-item') or list of dom elements\r\n   * @param dragInOptions options - see DDDragOpt. (default: {handle: '.grid-stack-item-content', appendTo: 'body'}\r\n   * @param widgets GridStackWidget def to assign to each element which defines what to create on drop\r\n   * @param root optional root which defaults to document (for shadow dom pass the parent HTMLDocument)\r\n   */\r\n  public static setupDragIn(dragIn?: string | HTMLElement[], dragInOptions?: DDDragOpt, widgets?: GridStackWidget[], root: HTMLElement | Document = document): void {\r\n    if (dragInOptions?.pause !== undefined) {\r\n      DDManager.pauseDrag = dragInOptions.pause;\r\n    }\r\n\r\n    dragInOptions = { appendTo: 'body', helper: 'clone', ...(dragInOptions || {}) }; // default to handle:undefined = drag by the whole item\r\n    const els = (typeof dragIn === 'string') ? Utils.getElements(dragIn, root) : dragIn;\r\n    els.forEach((el, i) => {\r\n      if (!dd.isDraggable(el)) dd.dragIn(el, dragInOptions);\r\n      if (widgets?.[i]) (el as GridItemHTMLElement).gridstackNode = widgets[i];\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Enables/Disables dragging by the user for specific grid elements. \r\n   * For all items and future items, use enableMove() instead. No-op for static grids.\r\n   * \r\n   * Note: If you want to prevent an item from moving due to being pushed around by another \r\n   * during collision, use the 'locked' property instead.\r\n   * \r\n   * @param els widget element(s) or selector to modify\r\n   * @param val if true widget will be draggable, assuming the parent grid isn't noMove or static\r\n   * @returns the grid instance for chaining\r\n   * \r\n   * @example\r\n   * // Make specific widgets draggable\r\n   * grid.movable('.my-widget', true);\r\n   * \r\n   * // Disable dragging for specific widgets\r\n   * grid.movable('#fixed-widget', false);\r\n   */\r\n  public movable(els: GridStackElement, val: boolean): GridStack {\r\n    if (this.opts.staticGrid) return this; // can't move a static grid!\r\n    GridStack.getElements(els).forEach(el => {\r\n      const n = el.gridstackNode;\r\n      if (!n) return;\r\n      val ? delete n.noMove : n.noMove = true;\r\n      this.prepareDragDrop(n.el); // init DD if need be, and adjust\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Enables/Disables user resizing for specific grid elements.\r\n   * For all items and future items, use enableResize() instead. No-op for static grids.\r\n   * \r\n   * @param els widget element(s) or selector to modify\r\n   * @param val if true widget will be resizable, assuming the parent grid isn't noResize or static\r\n   * @returns the grid instance for chaining\r\n   * \r\n   * @example\r\n   * // Make specific widgets resizable\r\n   * grid.resizable('.my-widget', true);\r\n   * \r\n   * // Disable resizing for specific widgets\r\n   * grid.resizable('#fixed-size-widget', false);\r\n   */\r\n  public resizable(els: GridStackElement, val: boolean): GridStack {\r\n    if (this.opts.staticGrid) return this; // can't resize a static grid!\r\n    GridStack.getElements(els).forEach(el => {\r\n      const n = el.gridstackNode;\r\n      if (!n) return;\r\n      val ? delete n.noResize : n.noResize = true;\r\n      this.prepareDragDrop(n.el); // init DD if need be, and adjust\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Temporarily disables widgets moving/resizing.\r\n   * If you want a more permanent way (which freezes up resources) use `setStatic(true)` instead.\r\n   * \r\n   * Note: This is a no-op for static grids.\r\n   * \r\n   * This is a shortcut for:\r\n   * ```typescript\r\n   * grid.enableMove(false);\r\n   * grid.enableResize(false);\r\n   * ```\r\n   * \r\n   * @param recurse if true (default), sub-grids also get updated\r\n   * @returns the grid instance for chaining\r\n   * \r\n   * @example\r\n   * // Disable all interactions\r\n   * grid.disable();\r\n   * \r\n   * // Disable only this grid, not sub-grids\r\n   * grid.disable(false);\r\n   */\r\n  public disable(recurse = true): GridStack {\r\n    if (this.opts.staticGrid) return;\r\n    this.enableMove(false, recurse);\r\n    this.enableResize(false, recurse);\r\n    this._triggerEvent('disable');\r\n    return this;\r\n  }\r\n  /**\r\n   * Re-enables widgets moving/resizing - see disable().\r\n   * Note: This is a no-op for static grids.\r\n   * \r\n   * This is a shortcut for:\r\n   * ```typescript\r\n   * grid.enableMove(true);\r\n   * grid.enableResize(true);\r\n   * ```\r\n   * \r\n   * @param recurse if true (default), sub-grids also get updated\r\n   * @returns the grid instance for chaining\r\n   * \r\n   * @example\r\n   * // Re-enable all interactions\r\n   * grid.enable();\r\n   * \r\n   * // Enable only this grid, not sub-grids\r\n   * grid.enable(false);\r\n   */\r\n  public enable(recurse = true): GridStack {\r\n    if (this.opts.staticGrid) return;\r\n    this.enableMove(true, recurse);\r\n    this.enableResize(true, recurse);\r\n    this._triggerEvent('enable');\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Enables/disables widget moving for all widgets. No-op for static grids.\r\n   * Note: locally defined items (with noMove property) still override this setting.\r\n   * \r\n   * @param doEnable if true widgets will be movable, if false moving is disabled\r\n   * @param recurse if true (default), sub-grids also get updated\r\n   * @returns the grid instance for chaining\r\n   * \r\n   * @example\r\n   * // Enable moving for all widgets\r\n   * grid.enableMove(true);\r\n   * \r\n   * // Disable moving for all widgets\r\n   * grid.enableMove(false);\r\n   * \r\n   * // Enable only this grid, not sub-grids\r\n   * grid.enableMove(true, false);\r\n   */\r\n  public enableMove(doEnable: boolean, recurse = true): GridStack {\r\n    if (this.opts.staticGrid) return this; // can't move a static grid!\r\n    doEnable ? delete this.opts.disableDrag : this.opts.disableDrag = true; // FIRST before we update children as grid overrides #1658\r\n    this.engine.nodes.forEach(n => {\r\n      this.prepareDragDrop(n.el);\r\n      if (n.subGrid && recurse) n.subGrid.enableMove(doEnable, recurse);\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Enables/disables widget resizing for all widgets. No-op for static grids.\r\n   * Note: locally defined items (with noResize property) still override this setting.\r\n   * \r\n   * @param doEnable if true widgets will be resizable, if false resizing is disabled\r\n   * @param recurse if true (default), sub-grids also get updated  \r\n   * @returns the grid instance for chaining\r\n   * \r\n   * @example\r\n   * // Enable resizing for all widgets\r\n   * grid.enableResize(true);\r\n   * \r\n   * // Disable resizing for all widgets\r\n   * grid.enableResize(false);\r\n   * \r\n   * // Enable only this grid, not sub-grids\r\n   * grid.enableResize(true, false);\r\n   */\r\n  public enableResize(doEnable: boolean, recurse = true): GridStack {\r\n    if (this.opts.staticGrid) return this; // can't size a static grid!\r\n    doEnable ? delete this.opts.disableResize : this.opts.disableResize = true; // FIRST before we update children as grid overrides #1658\r\n    this.engine.nodes.forEach(n => {\r\n      this.prepareDragDrop(n.el);\r\n      if (n.subGrid && recurse) n.subGrid.enableResize(doEnable, recurse);\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /** @internal call when drag (and drop) needs to be cancelled (Esc key) */\r\n  public cancelDrag() {\r\n    const n = this._placeholder?.gridstackNode;\r\n    if (!n) return;\r\n    if (n._isExternal) {\r\n      // remove any newly inserted nodes (from outside)\r\n      n._isAboutToRemove = true;\r\n      this.engine.removeNode(n);\r\n    } else if (n._isAboutToRemove) {\r\n      // restore any temp removed (dragged over trash)\r\n      GridStack._itemRemoving(n.el, false);\r\n    }\r\n\r\n    this.engine.restoreInitial();\r\n  }\r\n\r\n  /** @internal removes any drag&drop present (called during destroy) */\r\n  protected _removeDD(el: DDElementHost): GridStack {\r\n    dd.draggable(el, 'destroy').resizable(el, 'destroy');\r\n    if (el.gridstackNode) {\r\n      delete el.gridstackNode._initDD; // reset our DD init flag\r\n    }\r\n    delete el.ddElement;\r\n    return this;\r\n  }\r\n\r\n  /** @internal called to add drag over to support widgets being added externally */\r\n  protected _setupAcceptWidget(): GridStack {\r\n\r\n    // check if we need to disable things\r\n    if (this.opts.staticGrid || (!this.opts.acceptWidgets && !this.opts.removable)) {\r\n      dd.droppable(this.el, 'destroy');\r\n      return this;\r\n    }\r\n\r\n    // vars shared across all methods\r\n    let cellHeight: number, cellWidth: number;\r\n\r\n    const onDrag = (event: DragEvent, el: GridItemHTMLElement, helper: GridItemHTMLElement) => {\r\n      helper = helper || el;\r\n      const node = helper.gridstackNode;\r\n      if (!node) return;\r\n\r\n      // if the element is being dragged from outside, scale it down to match the grid's scale\r\n      // and slightly adjust its position relative to the mouse\r\n      if (!node.grid?.el) {\r\n        // this scales the helper down\r\n        helper.style.transform = `scale(${1 / this.dragTransform.xScale},${1 / this.dragTransform.yScale})`;\r\n        // this makes it so that the helper is well positioned relative to the mouse after scaling\r\n        const helperRect = helper.getBoundingClientRect();\r\n        helper.style.left = helperRect.x + (this.dragTransform.xScale - 1) * (event.clientX - helperRect.x) / this.dragTransform.xScale + 'px';\r\n        helper.style.top = helperRect.y + (this.dragTransform.yScale - 1) * (event.clientY - helperRect.y) / this.dragTransform.yScale + 'px';\r\n        helper.style.transformOrigin = `0px 0px`\r\n      }\r\n\r\n      let { top, left } = helper.getBoundingClientRect();\r\n      const rect = this.el.getBoundingClientRect();\r\n      left -= rect.left;\r\n      top -= rect.top;\r\n      const ui: DDUIData = {\r\n        position: {\r\n          top: top * this.dragTransform.xScale,\r\n          left: left * this.dragTransform.yScale\r\n        }\r\n      };\r\n\r\n      if (node._temporaryRemoved) {\r\n        node.x = Math.max(0, Math.round(left / cellWidth));\r\n        node.y = Math.max(0, Math.round(top / cellHeight));\r\n        delete node.autoPosition;\r\n        this.engine.nodeBoundFix(node);\r\n\r\n        // don't accept *initial* location if doesn't fit #1419 (locked drop region, or can't grow), but maybe try if it will go somewhere\r\n        if (!this.engine.willItFit(node)) {\r\n          node.autoPosition = true; // ignore x,y and try for any slot...\r\n          if (!this.engine.willItFit(node)) {\r\n            dd.off(el, 'drag'); // stop calling us\r\n            return; // full grid or can't grow\r\n          }\r\n          if (node._willFitPos) {\r\n            // use the auto position instead #1687\r\n            Utils.copyPos(node, node._willFitPos);\r\n            delete node._willFitPos;\r\n          }\r\n        }\r\n\r\n        // re-use the existing node dragging method\r\n        this._onStartMoving(helper, event, ui, node, cellWidth, cellHeight);\r\n      } else {\r\n        // re-use the existing node dragging that does so much of the collision detection\r\n        this._dragOrResize(helper, event, ui, node, cellWidth, cellHeight);\r\n      }\r\n    }\r\n\r\n    dd.droppable(this.el, {\r\n      accept: (el: GridItemHTMLElement) => {\r\n        const node: GridStackNode = el.gridstackNode || this._readAttr(el, false);\r\n        // set accept drop to true on ourself (which we ignore) so we don't get \"can't drop\" icon in HTML5 mode while moving\r\n        if (node?.grid === this) return true;\r\n        if (!this.opts.acceptWidgets) return false;\r\n        // check for accept method or class matching\r\n        let canAccept = true;\r\n        if (typeof this.opts.acceptWidgets === 'function') {\r\n          canAccept = this.opts.acceptWidgets(el);\r\n        } else {\r\n          const selector = (this.opts.acceptWidgets === true ? '.grid-stack-item' : this.opts.acceptWidgets as string);\r\n          canAccept = el.matches(selector);\r\n        }\r\n        // finally check to make sure we actually have space left #1571 #2633\r\n        if (canAccept && node && this.opts.maxRow) {\r\n          const n = { w: node.w, h: node.h, minW: node.minW, minH: node.minH }; // only width/height matters and autoPosition\r\n          canAccept = this.engine.willItFit(n);\r\n        }\r\n        return canAccept;\r\n      }\r\n    })\r\n      /**\r\n       * entering our grid area\r\n       */\r\n      .on(this.el, 'dropover', (event: Event, el: GridItemHTMLElement, helper: GridItemHTMLElement) => {\r\n        // console.log(`over ${this.el.gridstack.opts.id} ${count++}`); // TEST\r\n        let node = helper?.gridstackNode || el.gridstackNode;\r\n        // ignore drop enter on ourself (unless we temporarily removed) which happens on a simple drag of our item\r\n        if (node?.grid === this && !node._temporaryRemoved) {\r\n          // delete node._added; // reset this to track placeholder again in case we were over other grid #1484 (dropout doesn't always clear)\r\n          return false; // prevent parent from receiving msg (which may be a grid as well)\r\n        }\r\n\r\n        // If sidebar item, restore the sidebar node size to ensure consistent behavior when dragging between grids\r\n        if (node?._sidebarOrig) {\r\n          node.w = node._sidebarOrig.w;\r\n          node.h = node._sidebarOrig.h;\r\n        }\r\n\r\n        // fix #1578 when dragging fast, we may not get a leave on the previous grid so force one now\r\n        if (node?.grid && node.grid !== this && !node._temporaryRemoved) {\r\n          // console.log('dropover without leave'); // TEST\r\n          const otherGrid = node.grid;\r\n          otherGrid._leave(el, helper);\r\n        }\r\n        helper = helper || el;\r\n\r\n        // cache cell dimensions (which don't change), position can animate if we removed an item in otherGrid that affects us...\r\n        cellWidth = this.cellWidth();\r\n        cellHeight = this.getCellHeight(true);\r\n\r\n        // sidebar items: load any element attributes if we don't have a node on first enter from the sidebar\r\n        if (!node) {\r\n          const attr = helper.getAttribute('data-gs-widget') || helper.getAttribute('gridstacknode'); // TBD: temp support for old V11.0.0 attribute\r\n          if (attr) {\r\n            try {\r\n              node = JSON.parse(attr);\r\n            } catch (error) {\r\n              console.error(\"Gridstack dropover: Bad JSON format: \", attr);\r\n            }\r\n            helper.removeAttribute('data-gs-widget');\r\n            helper.removeAttribute('gridstacknode');\r\n          }\r\n          if (!node) node = this._readAttr(helper); // used to pass false for #2354, but now we clone top level node\r\n          // On first grid enter from sidebar, set the initial sidebar item size properties for the node\r\n          node._sidebarOrig = { w: node.w, h: node.h }\r\n        }\r\n        if (!node.grid) { // sidebar item\r\n          if (!node.el) node = {...node}; // clone first time we're coming from sidebar (since 'clone' doesn't copy vars)\r\n          node._isExternal = true;\r\n          helper.gridstackNode = node;\r\n        }\r\n\r\n        // calculate the grid size based on element outer size\r\n        const w = node.w || Math.round(helper.offsetWidth / cellWidth) || 1;\r\n        const h = node.h || Math.round(helper.offsetHeight / cellHeight) || 1;\r\n\r\n        // if the item came from another grid, make a copy and save the original info in case we go back there\r\n        if (node.grid && node.grid !== this) {\r\n          // copy the node original values (min/max/id/etc...) but override width/height/other flags which are this grid specific\r\n          // console.log('dropover cloning node'); // TEST\r\n          if (!el._gridstackNodeOrig) el._gridstackNodeOrig = node; // shouldn't have multiple nested!\r\n          el.gridstackNode = node = { ...node, w, h, grid: this };\r\n          delete node.x;\r\n          delete node.y;\r\n          this.engine.cleanupNode(node)\r\n            .nodeBoundFix(node);\r\n          // restore some internal fields we need after clearing them all\r\n          node._initDD =\r\n            node._isExternal =  // DOM needs to be re-parented on a drop\r\n            node._temporaryRemoved = true; // so it can be inserted onDrag below\r\n        } else {\r\n          node.w = w;\r\n          node.h = h;\r\n          node._temporaryRemoved = true; // so we can insert it\r\n        }\r\n\r\n        // clear any marked for complete removal (Note: don't check _isAboutToRemove as that is cleared above - just do it)\r\n        GridStack._itemRemoving(node.el, false);\r\n\r\n        dd.on(el, 'drag', onDrag);\r\n        // make sure this is called at least once when going fast #1578\r\n        onDrag(event as DragEvent, el, helper);\r\n        return false; // prevent parent from receiving msg (which may be a grid as well)\r\n      })\r\n      /**\r\n       * Leaving our grid area...\r\n       */\r\n      .on(this.el, 'dropout', (event, el: GridItemHTMLElement, helper: GridItemHTMLElement) => {\r\n        // console.log(`out ${this.el.gridstack.opts.id} ${count++}`); // TEST\r\n        const node = helper?.gridstackNode || el.gridstackNode;\r\n        if (!node) return false;\r\n        // fix #1578 when dragging fast, we might get leave after other grid gets enter (which calls us to clean)\r\n        // so skip this one if we're not the active grid really..\r\n        if (!node.grid || node.grid === this) {\r\n          this._leave(el, helper);\r\n          // if we were created as temporary nested grid, go back to before state\r\n          if (this._isTemp) {\r\n            this.removeAsSubGrid(node);\r\n          }\r\n        }\r\n        return false; // prevent parent from receiving msg (which may be grid as well)\r\n      })\r\n      /**\r\n       * end - releasing the mouse\r\n       */\r\n      .on(this.el, 'drop', (event, el: GridItemHTMLElement, helper: GridItemHTMLElement) => {\r\n        const node = helper?.gridstackNode || el.gridstackNode;\r\n        // ignore drop on ourself from ourself that didn't come from the outside - dragend will handle the simple move instead\r\n        if (node?.grid === this && !node._isExternal) return false;\r\n\r\n        const wasAdded = !!this.placeholder.parentElement; // skip items not actually added to us because of constrains, but do cleanup #1419\r\n        const wasSidebar = el !== helper;\r\n        this.placeholder.remove();\r\n        delete this.placeholder.gridstackNode;\r\n\r\n        // disable animation when replacing a placeholder (already positioned) with actual content\r\n        if (wasAdded && this.opts.animate) {\r\n          this.setAnimation(false);\r\n          this.setAnimation(true, true); // delay adding back\r\n        }\r\n\r\n        // notify previous grid of removal\r\n        // console.log('drop delete _gridstackNodeOrig') // TEST\r\n        const origNode = el._gridstackNodeOrig;\r\n        delete el._gridstackNodeOrig;\r\n        if (wasAdded && origNode?.grid && origNode.grid !== this) {\r\n          const oGrid = origNode.grid;\r\n          oGrid.engine.removeNodeFromLayoutCache(origNode);\r\n          oGrid.engine.removedNodes.push(origNode);\r\n          oGrid._triggerRemoveEvent()._triggerChangeEvent();\r\n          // if it's an empty sub-grid that got auto-created, nuke it\r\n          if (oGrid.parentGridNode && !oGrid.engine.nodes.length && oGrid.opts.subGridDynamic) {\r\n            oGrid.removeAsSubGrid();\r\n          }\r\n        }\r\n\r\n        if (!node) return false;\r\n\r\n        // use existing placeholder node as it's already in our list with drop location\r\n        if (wasAdded) {\r\n          this.engine.cleanupNode(node); // removes all internal _xyz values\r\n          node.grid = this;\r\n        }\r\n        delete node.grid?._isTemp;\r\n        dd.off(el, 'drag');\r\n        // if we made a copy insert that instead of the original (sidebar item)\r\n        if (helper !== el) {\r\n          helper.remove();\r\n          el = helper;\r\n        } else {\r\n          el.remove(); // reduce flicker as we change depth here, and size further down\r\n        }\r\n        this._removeDD(el);\r\n        if (!wasAdded) return false;\r\n        const subGrid = node.subGrid?.el?.gridstack; // set when actual sub-grid present\r\n        Utils.copyPos(node, this._readAttr(this.placeholder)); // placeholder values as moving VERY fast can throw things off #1578\r\n        Utils.removePositioningStyles(el);\r\n\r\n        // give the user a chance to alter the widget that will get inserted if new sidebar item\r\n        if (wasSidebar && (node.content || node.subGridOpts || GridStack.addRemoveCB)) {\r\n          delete node.el;\r\n          el = this.addWidget(node);\r\n        } else {\r\n          this._prepareElement(el, true, node);\r\n          this.el.appendChild(el);\r\n          // resizeToContent is skipped in _prepareElement() until node is visible (clientHeight=0) so call it now\r\n          this.resizeToContentCheck(false, node);\r\n          if (subGrid) {\r\n            subGrid.parentGridNode = node;\r\n          }\r\n          this._updateContainerHeight();\r\n        }\r\n        this.engine.addedNodes.push(node);\r\n        this._triggerAddEvent();\r\n        this._triggerChangeEvent();\r\n\r\n        this.engine.endUpdate();\r\n        if (this._gsEventHandler['dropped']) {\r\n          this._gsEventHandler['dropped']({ ...event, type: 'dropped' }, origNode && origNode.grid ? origNode : undefined, node);\r\n        }\r\n\r\n        return false; // prevent parent from receiving msg (which may be grid as well)\r\n      });\r\n    return this;\r\n  }\r\n\r\n  /** @internal mark item for removal */\r\n  private static _itemRemoving(el: GridItemHTMLElement, remove: boolean) {\r\n    if (!el) return;\r\n    const node = el ? el.gridstackNode : undefined;\r\n    if (!node?.grid || el.classList.contains(node.grid.opts.removableOptions.decline)) return;\r\n    remove ? node._isAboutToRemove = true : delete node._isAboutToRemove;\r\n    remove ? el.classList.add('grid-stack-item-removing') : el.classList.remove('grid-stack-item-removing');\r\n  }\r\n\r\n  /** @internal called to setup a trash drop zone if the user specifies it */\r\n  protected _setupRemoveDrop(): GridStack {\r\n    if (typeof this.opts.removable !== 'string') return this;\r\n    const trashEl = document.querySelector(this.opts.removable) as HTMLElement;\r\n    if (!trashEl) return this;\r\n\r\n    // only register ONE static drop-over/dropout callback for the 'trash', and it will\r\n    // update the passed in item and parent grid because the '.trash' is a shared resource anyway,\r\n    // and Native DD only has 1 event CB (having a list and technically a per grid removableOptions complicates things greatly)\r\n    if (!this.opts.staticGrid && !dd.isDroppable(trashEl)) {\r\n      dd.droppable(trashEl, this.opts.removableOptions)\r\n        .on(trashEl, 'dropover', (event, el) => GridStack._itemRemoving(el, true))\r\n        .on(trashEl, 'dropout', (event, el) => GridStack._itemRemoving(el, false));\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * prepares the element for drag&drop - this is normally called by makeWidget() unless are are delay loading\r\n   * @param el GridItemHTMLElement of the widget\r\n   * @param [force=false]\r\n   * */\r\n  public prepareDragDrop(el: GridItemHTMLElement, force = false): GridStack {\r\n    const node = el?.gridstackNode;\r\n    if (!node) return;\r\n    const noMove = node.noMove || this.opts.disableDrag;\r\n    const noResize = node.noResize || this.opts.disableResize;\r\n\r\n    // check for disabled grid first\r\n    const disable = this.opts.staticGrid || (noMove && noResize);\r\n    if (force || disable) {\r\n      if (node._initDD) {\r\n        this._removeDD(el); // nukes everything instead of just disable, will add some styles back next\r\n        delete node._initDD;\r\n      }\r\n      if (disable) el.classList.add('ui-draggable-disabled', 'ui-resizable-disabled'); // add styles one might depend on #1435\r\n      if (!force) return this;\r\n    }\r\n\r\n    if (!node._initDD) {\r\n      // variables used/cashed between the 3 start/move/end methods, in addition to node passed above\r\n      let cellWidth: number;\r\n      let cellHeight: number;\r\n\r\n      /** called when item starts moving/resizing */\r\n      const onStartMoving = (event: Event, ui: DDUIData) => {\r\n        // trigger any 'dragstart' / 'resizestart' manually\r\n        this.triggerEvent(event, event.target as GridItemHTMLElement);\r\n        cellWidth = this.cellWidth();\r\n        cellHeight = this.getCellHeight(true); // force pixels for calculations\r\n\r\n        this._onStartMoving(el, event, ui, node, cellWidth, cellHeight);\r\n      }\r\n\r\n      /** called when item is being dragged/resized */\r\n      const dragOrResize = (event: MouseEvent, ui: DDUIData) => {\r\n        this._dragOrResize(el, event, ui, node, cellWidth, cellHeight);\r\n      }\r\n\r\n      /** called when the item stops moving/resizing */\r\n      const onEndMoving = (event: Event) => {\r\n        this.placeholder.remove();\r\n        delete this.placeholder.gridstackNode;\r\n        delete node._moving;\r\n        delete node._resizing;\r\n        delete node._event;\r\n        delete node._lastTried;\r\n        const widthChanged = node.w !== node._orig.w;\r\n\r\n        // if the item has moved to another grid, we're done here\r\n        const target: GridItemHTMLElement = event.target as GridItemHTMLElement;\r\n        if (!target.gridstackNode || target.gridstackNode.grid !== this) return;\r\n\r\n        node.el = target;\r\n\r\n        if (node._isAboutToRemove) {\r\n          const grid = el.gridstackNode.grid;\r\n          if (grid._gsEventHandler[event.type]) {\r\n            grid._gsEventHandler[event.type](event, target);\r\n          }\r\n          grid.engine.nodes.push(node); // temp add it back so we can proper remove it next\r\n          grid.removeWidget(el, true, true);\r\n        } else {\r\n          Utils.removePositioningStyles(target);\r\n          if (node._temporaryRemoved) {\r\n            // use last position we were at (not _orig as we may have pushed others and moved) and add it back\r\n            this._writePosAttr(target, node);\r\n            this.engine.addNode(node);\r\n          } else {\r\n            // move to new placeholder location\r\n            this._writePosAttr(target, node);\r\n          }\r\n          this.triggerEvent(event, target);\r\n        }\r\n        // @ts-ignore\r\n        this._extraDragRow = 0;// @ts-ignore\r\n        this._updateContainerHeight();// @ts-ignore\r\n        this._triggerChangeEvent();\r\n\r\n        this.engine.endUpdate();\r\n\r\n        if (event.type === 'resizestop') {\r\n          if (Number.isInteger(node.sizeToContent)) node.sizeToContent = node.h; // new soft limit\r\n          this.resizeToContentCheck(widthChanged, node); // wait for width animation if changed\r\n        }\r\n      }\r\n\r\n      dd.draggable(el, {\r\n        start: onStartMoving,\r\n        stop: onEndMoving,\r\n        drag: dragOrResize\r\n      }).resizable(el, {\r\n        start: onStartMoving,\r\n        stop: onEndMoving,\r\n        resize: dragOrResize\r\n      });\r\n      node._initDD = true; // we've set DD support now\r\n    }\r\n\r\n    // finally fine tune move vs resize by disabling any part...\r\n    dd.draggable(el, noMove ? 'disable' : 'enable')\r\n      .resizable(el, noResize ? 'disable' : 'enable');\r\n\r\n    return this;\r\n  }\r\n\r\n  /** @internal handles actual drag/resize start */\r\n  protected _onStartMoving(el: GridItemHTMLElement, event: Event, ui: DDUIData, node: GridStackNode, cellWidth: number, cellHeight: number): void {\r\n    this.engine.cleanNodes()\r\n      .beginUpdate(node);\r\n    // @ts-ignore\r\n    this._writePosAttr(this.placeholder, node)\r\n    this.el.appendChild(this.placeholder);\r\n    this.placeholder.gridstackNode = node;\r\n    // console.log('_onStartMoving placeholder') // TEST\r\n\r\n    // if the element is inside a grid, it has already been scaled\r\n    // we can use that as a scale reference\r\n    if (node.grid?.el) {\r\n      this.dragTransform = Utils.getValuesFromTransformedElement(el);\r\n    }\r\n    // if the element is being dragged from outside (not from any grid)\r\n    // we use the grid as the transformation reference, since the helper is not subject to transformation\r\n    else if (this.placeholder && this.placeholder.closest('.grid-stack')) {\r\n      const gridEl = this.placeholder.closest('.grid-stack') as HTMLElement;\r\n      this.dragTransform = Utils.getValuesFromTransformedElement(gridEl);\r\n    }\r\n    // Fallback\r\n    else {\r\n      this.dragTransform = {\r\n        xScale: 1,\r\n        xOffset: 0,\r\n        yScale: 1,\r\n        yOffset: 0,\r\n      }\r\n    }\r\n\r\n    node.el = this.placeholder;\r\n    node._lastUiPosition = ui.position;\r\n    node._prevYPix = ui.position.top;\r\n    node._moving = (event.type === 'dragstart'); // 'dropover' are not initially moving so they can go exactly where they enter (will push stuff out of the way)\r\n    node._resizing = (event.type === 'resizestart');\r\n    delete node._lastTried;\r\n\r\n    if (event.type === 'dropover' && node._temporaryRemoved) {\r\n      // console.log('engine.addNode x=' + node.x); // TEST\r\n      this.engine.addNode(node); // will add, fix collisions, update attr and clear _temporaryRemoved\r\n      node._moving = true; // AFTER, mark as moving object (wanted fix location before)\r\n    }\r\n\r\n    // set the min/max resize info taking into account the column count and position (so we don't resize outside the grid)\r\n    this.engine.cacheRects(cellWidth, cellHeight, this.opts.marginTop as number, this.opts.marginRight as number, this.opts.marginBottom as number, this.opts.marginLeft as number);\r\n    if (event.type === 'resizestart') {\r\n      const colLeft = this.getColumn() - node.x;\r\n      const rowLeft = (this.opts.maxRow || Number.MAX_SAFE_INTEGER) - node.y;\r\n      dd.resizable(el, 'option', 'minWidth', cellWidth * Math.min(node.minW || 1, colLeft))\r\n        .resizable(el, 'option', 'minHeight', cellHeight * Math.min(node.minH || 1, rowLeft))\r\n        .resizable(el, 'option', 'maxWidth', cellWidth * Math.min(node.maxW || Number.MAX_SAFE_INTEGER, colLeft))\r\n        .resizable(el, 'option', 'maxWidthMoveLeft', cellWidth * Math.min(node.maxW || Number.MAX_SAFE_INTEGER, node.x+node.w))\r\n        .resizable(el, 'option', 'maxHeight', cellHeight * Math.min(node.maxH || Number.MAX_SAFE_INTEGER, rowLeft))\r\n        .resizable(el, 'option', 'maxHeightMoveUp', cellHeight * Math.min(node.maxH || Number.MAX_SAFE_INTEGER, node.y+node.h));\r\n    }\r\n  }\r\n\r\n  /** @internal handles actual drag/resize */\r\n  protected _dragOrResize(el: GridItemHTMLElement, event: MouseEvent, ui: DDUIData, node: GridStackNode, cellWidth: number, cellHeight: number): void {\r\n    const p = { ...node._orig }; // could be undefined (_isExternal) which is ok (drag only set x,y and w,h will default to node value)\r\n    let resizing: boolean;\r\n    let mLeft = this.opts.marginLeft as number,\r\n      mRight = this.opts.marginRight as number,\r\n      mTop = this.opts.marginTop as number,\r\n      mBottom = this.opts.marginBottom as number;\r\n\r\n    // if margins (which are used to pass mid point by) are large relative to cell height/width, reduce them down #1855\r\n    const mHeight = Math.round(cellHeight * 0.1),\r\n      mWidth = Math.round(cellWidth * 0.1);\r\n    mLeft = Math.min(mLeft, mWidth);\r\n    mRight = Math.min(mRight, mWidth);\r\n    mTop = Math.min(mTop, mHeight);\r\n    mBottom = Math.min(mBottom, mHeight);\r\n\r\n    if (event.type === 'drag') {\r\n      if (node._temporaryRemoved) return; // handled by dropover\r\n      const distance = ui.position.top - node._prevYPix;\r\n      node._prevYPix = ui.position.top;\r\n      if (this.opts.draggable.scroll !== false) {\r\n        Utils.updateScrollPosition(el, ui.position, distance);\r\n      }\r\n\r\n      // get new position taking into account the margin in the direction we are moving! (need to pass mid point by margin)\r\n      const left = ui.position.left + (ui.position.left > node._lastUiPosition.left ? -mRight : mLeft);\r\n      const top = ui.position.top + (ui.position.top > node._lastUiPosition.top ? -mBottom : mTop);\r\n      p.x = Math.round(left / cellWidth);\r\n      p.y = Math.round(top / cellHeight);\r\n\r\n      // @ts-ignore// if we're at the bottom hitting something else, grow the grid so cursor doesn't leave when trying to place below others\r\n      const prev = this._extraDragRow;\r\n      if (this.engine.collide(node, p)) {\r\n        const row = this.getRow();\r\n        let extra = Math.max(0, (p.y + node.h) - row);\r\n        if (this.opts.maxRow && row + extra > this.opts.maxRow) {\r\n          extra = Math.max(0, this.opts.maxRow - row);\r\n        }// @ts-ignore\r\n        this._extraDragRow = extra;// @ts-ignore\r\n      } else this._extraDragRow = 0;// @ts-ignore\r\n      if (this._extraDragRow !== prev) this._updateContainerHeight();\r\n\r\n      if (node.x === p.x && node.y === p.y) return; // skip same\r\n      // DON'T skip one we tried as we might have failed because of coverage <50% before\r\n      // if (node._lastTried && node._lastTried.x === x && node._lastTried.y === y) return;\r\n    } else if (event.type === 'resize') {\r\n      if (p.x < 0) return;\r\n      // Scrolling page if needed\r\n      Utils.updateScrollResize(event, el, cellHeight);\r\n\r\n      // get new size\r\n      p.w = Math.round((ui.size.width - mLeft) / cellWidth);\r\n      p.h = Math.round((ui.size.height - mTop) / cellHeight);\r\n      if (node.w === p.w && node.h === p.h) return;\r\n      if (node._lastTried && node._lastTried.w === p.w && node._lastTried.h === p.h) return; // skip one we tried (but failed)\r\n\r\n      // if we size on left/top side this might move us, so get possible new position as well\r\n      const left = ui.position.left + mLeft;\r\n      const top = ui.position.top + mTop;\r\n      p.x = Math.round(left / cellWidth);\r\n      p.y = Math.round(top / cellHeight);\r\n\r\n      resizing = true;\r\n    }\r\n\r\n    node._event = event;\r\n    node._lastTried = p; // set as last tried (will nuke if we go there)\r\n    const rect: GridStackPosition = { // screen pix of the dragged box\r\n      x: ui.position.left + mLeft,\r\n      y: ui.position.top + mTop,\r\n      w: (ui.size ? ui.size.width : node.w * cellWidth) - mLeft - mRight,\r\n      h: (ui.size ? ui.size.height : node.h * cellHeight) - mTop - mBottom\r\n    };\r\n    if (this.engine.moveNodeCheck(node, { ...p, cellWidth, cellHeight, rect, resizing })) {\r\n      node._lastUiPosition = ui.position;\r\n      this.engine.cacheRects(cellWidth, cellHeight, mTop, mRight, mBottom, mLeft);\r\n      delete node._skipDown;\r\n      if (resizing && node.subGrid) node.subGrid.onResize();\r\n      this._extraDragRow = 0;// @ts-ignore\r\n      this._updateContainerHeight();\r\n\r\n      const target = event.target as GridItemHTMLElement;// @ts-ignore\r\n      // Do not write sidebar item attributes back to the original sidebar el\r\n      if (!node._sidebarOrig) {\r\n        this._writePosAttr(target, node);\r\n      }\r\n      this.triggerEvent(event, target);\r\n    }\r\n  }\r\n\r\n  /** call given event callback on our main top-most grid (if we're nested) */\r\n  protected triggerEvent(event: Event, target: GridItemHTMLElement) {\r\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    let grid: GridStack = this;\r\n    while (grid.parentGridNode) grid = grid.parentGridNode.grid;\r\n    if (grid._gsEventHandler[event.type]) {\r\n      grid._gsEventHandler[event.type](event, target);\r\n    }\r\n  }\r\n\r\n  /** @internal called when item leaving our area by either cursor dropout event\r\n   * or shape is outside our boundaries. remove it from us, and mark temporary if this was\r\n   * our item to start with else restore prev node values from prev grid it came from.\r\n   */\r\n  protected _leave(el: GridItemHTMLElement, helper?: GridItemHTMLElement): void {\r\n    helper = helper || el;\r\n    const node = helper.gridstackNode;\r\n    if (!node) return;\r\n\r\n    // remove the scale of the helper on leave\r\n    helper.style.transform = helper.style.transformOrigin = null;\r\n    dd.off(el, 'drag'); // no need to track while being outside\r\n\r\n    // this gets called when cursor leaves and shape is outside, so only do this once\r\n    if (node._temporaryRemoved) return;\r\n    node._temporaryRemoved = true;\r\n\r\n    this.engine.removeNode(node); // remove placeholder as well, otherwise it's a sign node is not in our list, which is a bigger issue\r\n    node.el = node._isExternal && helper ? helper : el; // point back to real item being dragged\r\n    const sidebarOrig = node._sidebarOrig;\r\n    if (node._isExternal) this.engine.cleanupNode(node);\r\n    // Restore sidebar item initial size info to stay consistent when dragging between multiple grids\r\n    node._sidebarOrig = sidebarOrig;\r\n\r\n    if (this.opts.removable === true) { // boolean vs a class string\r\n      // item leaving us and we are supposed to remove on leave (no need to drag onto trash) mark it so\r\n      GridStack._itemRemoving(el, true);\r\n    }\r\n\r\n    // finally if item originally came from another grid, but left us, restore things back to prev info\r\n    if (el._gridstackNodeOrig) {\r\n      // console.log('leave delete _gridstackNodeOrig') // TEST\r\n      el.gridstackNode = el._gridstackNodeOrig;\r\n      delete el._gridstackNodeOrig;\r\n    } else if (node._isExternal) {\r\n      // item came from outside restore all nodes back to original\r\n      this.engine.restoreInitial();\r\n    }\r\n  }\r\n\r\n  // legacy method removed\r\n  public commit(): GridStack { obsolete(this, this.batchUpdate(false), 'commit', 'batchUpdate', '5.2'); return this; }\r\n}\r\n","/**\r\n * dd-gridstack.ts 12.3.0\r\n * Copyright (c) 2021-2025 Alain Dumesny - see GridStack root license\r\n */\r\n\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { GridItemHTMLElement, GridStackElement, DDDragOpt } from './types';\r\nimport { Utils } from './utils';\r\nimport { DDManager } from './dd-manager';\r\nimport { DDElement, DDElementHost } from './dd-element';\r\nimport { GridHTMLElement } from './gridstack';\r\n\r\n/**\r\n * Drag & Drop options for drop targets.\r\n * Configures which elements can be dropped onto a grid.\r\n */\r\nexport type DDDropOpt = {\r\n  /** Function to determine if an element can be dropped (see GridStackOptions.acceptWidgets) */\r\n  accept?: (el: GridItemHTMLElement) => boolean;\r\n}\r\n\r\n/**\r\n * Drag & Drop operation types used throughout the DD system.\r\n * Can be control commands or configuration objects.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport type DDOpts = 'enable' | 'disable' | 'destroy' | 'option' | string | any;\r\n\r\n/**\r\n * Keys for DD configuration options that can be set via the 'option' command.\r\n */\r\nexport type DDKey = 'minWidth' | 'minHeight' | 'maxWidth' | 'maxHeight' | 'maxHeightMoveUp' | 'maxWidthMoveLeft';\r\n\r\n/**\r\n * Values for DD configuration options (numbers or strings with units).\r\n */\r\nexport type DDValue = number | string;\r\n\r\n/**\r\n * Callback function type for drag & drop events.\r\n * \r\n * @param event - The DOM event that triggered the callback\r\n * @param arg2 - The grid item element being dragged/dropped\r\n * @param helper - Optional helper element used during drag operations\r\n */\r\nexport type DDCallback = (event: Event, arg2: GridItemHTMLElement, helper?: GridItemHTMLElement) => void;\r\n\r\n// let count = 0; // TEST\r\n\r\n/**\r\n * HTML Native Mouse and Touch Events Drag and Drop functionality.\r\n * \r\n * This class provides the main drag & drop implementation for GridStack,\r\n * handling resizing, dragging, and dropping of grid items using native HTML5 events.\r\n * It manages the interaction between different DD components and the grid system.\r\n */\r\nexport class DDGridStack {\r\n\r\n  /**\r\n   * Enable/disable/configure resizing for grid elements.\r\n   * \r\n   * @param el - Grid item element(s) to configure\r\n   * @param opts - Resize options or command ('enable', 'disable', 'destroy', 'option', or config object)\r\n   * @param key - Option key when using 'option' command\r\n   * @param value - Option value when using 'option' command\r\n   * @returns this instance for chaining\r\n   * \r\n   * @example\r\n   * dd.resizable(element, 'enable');  // Enable resizing\r\n   * dd.resizable(element, 'option', 'minWidth', 100);  // Set minimum width\r\n   */\r\n  public resizable(el: GridItemHTMLElement, opts: DDOpts, key?: DDKey, value?: DDValue): DDGridStack {\r\n    this._getDDElements(el, opts).forEach(dEl => {\r\n      if (opts === 'disable' || opts === 'enable') {\r\n        dEl.ddResizable && dEl.ddResizable[opts](); // can't create DD as it requires options for setupResizable()\r\n      } else if (opts === 'destroy') {\r\n        dEl.ddResizable && dEl.cleanResizable();\r\n      } else if (opts === 'option') {\r\n        dEl.setupResizable({ [key]: value });\r\n      } else {\r\n        const n = dEl.el.gridstackNode;\r\n        const grid = n.grid;\r\n        let handles = dEl.el.getAttribute('gs-resize-handles') || grid.opts.resizable.handles || 'e,s,se';\r\n        if (handles === 'all') handles = 'n,e,s,w,se,sw,ne,nw';\r\n        // NOTE: keep the resize handles as e,w don't have enough space (10px) to show resize corners anyway. limit during drag instead\r\n        // restrict vertical resize if height is done to match content anyway... odd to have it spring back\r\n        // if (Utils.shouldSizeToContent(n, true)) {\r\n        //   const doE = handles.indexOf('e') !== -1;\r\n        //   const doW = handles.indexOf('w') !== -1;\r\n        //   handles = doE ? (doW ? 'e,w' : 'e') : (doW ? 'w' : '');\r\n        // }\r\n        const autoHide = !grid.opts.alwaysShowResizeHandle;\r\n        dEl.setupResizable({\r\n          ...grid.opts.resizable,\r\n          ...{ handles, autoHide },\r\n          ...{\r\n            start: opts.start,\r\n            stop: opts.stop,\r\n            resize: opts.resize\r\n          }\r\n        });\r\n      }\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Enable/disable/configure dragging for grid elements.\r\n   * \r\n   * @param el - Grid item element(s) to configure\r\n   * @param opts - Drag options or command ('enable', 'disable', 'destroy', 'option', or config object)\r\n   * @param key - Option key when using 'option' command\r\n   * @param value - Option value when using 'option' command\r\n   * @returns this instance for chaining\r\n   * \r\n   * @example\r\n   * dd.draggable(element, 'enable');  // Enable dragging\r\n   * dd.draggable(element, {handle: '.drag-handle'});  // Configure drag handle\r\n   */\r\n  public draggable(el: GridItemHTMLElement, opts: DDOpts, key?: DDKey, value?: DDValue): DDGridStack {\r\n    this._getDDElements(el, opts).forEach(dEl => {\r\n      if (opts === 'disable' || opts === 'enable') {\r\n        dEl.ddDraggable && dEl.ddDraggable[opts](); // can't create DD as it requires options for setupDraggable()\r\n      } else if (opts === 'destroy') {\r\n        dEl.ddDraggable && dEl.cleanDraggable();\r\n      } else if (opts === 'option') {\r\n        dEl.setupDraggable({ [key]: value });\r\n      } else {\r\n        const grid = dEl.el.gridstackNode.grid;\r\n        dEl.setupDraggable({\r\n          ...grid.opts.draggable,\r\n          ...{\r\n            // containment: (grid.parentGridNode && grid.opts.dragOut === false) ? grid.el.parentElement : (grid.opts.draggable.containment || null),\r\n            start: opts.start,\r\n            stop: opts.stop,\r\n            drag: opts.drag\r\n          }\r\n        });\r\n      }\r\n    });\r\n    return this;\r\n  }\r\n\r\n  public dragIn(el: GridStackElement, opts: DDDragOpt): DDGridStack {\r\n    this._getDDElements(el).forEach(dEl => dEl.setupDraggable(opts));\r\n    return this;\r\n  }\r\n\r\n  public droppable(el: GridItemHTMLElement, opts: DDOpts | DDDropOpt, key?: DDKey, value?: DDValue): DDGridStack {\r\n    if (typeof opts.accept === 'function' && !opts._accept) {\r\n      opts._accept = opts.accept;\r\n      opts.accept = (el) => opts._accept(el);\r\n    }\r\n    this._getDDElements(el, opts).forEach(dEl => {\r\n      if (opts === 'disable' || opts === 'enable') {\r\n        dEl.ddDroppable && dEl.ddDroppable[opts]();\r\n      } else if (opts === 'destroy') {\r\n        dEl.ddDroppable && dEl.cleanDroppable();\r\n      } else if (opts === 'option') {\r\n        dEl.setupDroppable({ [key]: value });\r\n      } else {\r\n        dEl.setupDroppable(opts);\r\n      }\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /** true if element is droppable */\r\n  public isDroppable(el: DDElementHost): boolean {\r\n    return !!(el?.ddElement?.ddDroppable && !el.ddElement.ddDroppable.disabled);\r\n  }\r\n\r\n  /** true if element is draggable */\r\n  public isDraggable(el: DDElementHost): boolean {\r\n    return !!(el?.ddElement?.ddDraggable && !el.ddElement.ddDraggable.disabled);\r\n  }\r\n\r\n  /** true if element is draggable */\r\n  public isResizable(el: DDElementHost): boolean {\r\n    return !!(el?.ddElement?.ddResizable && !el.ddElement.ddResizable.disabled);\r\n  }\r\n\r\n  public on(el: GridItemHTMLElement, name: string, callback: DDCallback): DDGridStack {\r\n    this._getDDElements(el).forEach(dEl =>\r\n      dEl.on(name, (event: Event) => {\r\n        callback(\r\n          event,\r\n          DDManager.dragElement ? DDManager.dragElement.el : event.target as GridItemHTMLElement,\r\n          DDManager.dragElement ? DDManager.dragElement.helper : null)\r\n      })\r\n    );\r\n    return this;\r\n  }\r\n\r\n  public off(el: GridItemHTMLElement, name: string): DDGridStack {\r\n    this._getDDElements(el).forEach(dEl => dEl.off(name));\r\n    return this;\r\n  }\r\n\r\n  /** @internal returns a list of DD elements, creating them on the fly by default unless option is to destroy or disable */\r\n  protected _getDDElements(els: GridStackElement, opts?: DDOpts): DDElement[] {\r\n    // don't force create if we're going to destroy it, unless it's a grid which is used as drop target for it's children\r\n    const create = (els as GridHTMLElement).gridstack ||  opts !== 'destroy' && opts !== 'disable';\r\n    const hosts = Utils.getElements(els) as DDElementHost[];\r\n    if (!hosts.length) return [];\r\n    const list = hosts.map(e => e.ddElement || (create ? DDElement.init(e) : null)).filter(d => d); // remove nulls\r\n    return list;\r\n  }\r\n}\r\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Utils","getElements","els","document","doc","undefined","isNaN","el","getElementById","list","querySelectorAll","length","Array","from","getElement","substring","querySelector","lazyLoad","n","grid","opts","createDiv","classes","parent","createElement","forEach","c","classList","add","appendChild","shouldSizeToContent","strict","sizeToContent","isIntercepted","a","b","y","h","x","w","isTouching","areaIntercept","x0","x1","y0","y1","area","sort","nodes","dir","und","diffY","find","id","toBool","v","toLowerCase","Boolean","toNumber","value","Number","parseHeight","val","unit","match","Error","parseFloat","defaults","target","sources","source","same","keys","copyPos","doMinMax","minW","minH","maxW","maxH","samePos","sanitizeMinMax","node","removeInternalAndSame","aVal","bVal","removeInternalForSave","removeEl","autoPosition","noResize","noMove","locked","throttle","func","delay","isWaiting","args","setTimeout","removePositioningStyles","style","position","removeProperty","left","top","width","height","getScrollElement","scrollingElement","documentElement","getComputedStyle","test","overflow","overflowY","parentElement","updateScrollPosition","distance","scrollEl","elRect","getBoundingClientRect","scrollRect","innerHeightOrClientHeight","window","innerHeight","clientHeight","offsetDiffDown","bottom","Math","min","offsetDiffUp","max","prevScroll","scrollTop","offsetHeight","abs","updateScrollResize","event","offsetTop","pointerPosY","clientY","scrollBy","behavior","clone","cloneDeep","skipFields","ret","k","cloneNode","removeAttribute","appendTo","parentNode","addElStyles","styles","s","isArray","initEvent","e","info","evt","type","button","which","buttons","bubbles","cancelable","p","simulateMouseEvent","simulatedType","me","simulatedEvent","MouseEvent","composed","view","detail","screenX","screenY","clientX","ctrlKey","altKey","shiftKey","metaKey","relatedTarget","dispatchEvent","getValuesFromTransformedElement","transformReference","opacity","zIndex","transformValues","removeChild","remove","xScale","yScale","xOffset","yOffset","swap","tmp","canBeRotated","disableResize","GridStackEngine","addedNodes","removedNodes","defaultColumn","this","column","maxRow","_float","float","onChange","batchUpdate","flag","doPack","batchMode","_prevFloat","cleanNodes","saveInitial","_packNodes","_notify","_useEntireRowArea","nn","_hasLocked","_moving","_skipDown","_fixCollisions","collide","opt","sortNodes","nested","_loading","skip","didMove","newOpt","pack","counter","moved","newNN","moveNode","skip2","skipId","_id","skip2Id","collideAll","filter","directionCollideCoverage","collides","rect","_rect","r0","r","overMax","r2","yOver","MAX_VALUE","xOver","over","cacheRects","right","_doSwap","_dirty","touching","t","isAreaEmpty","compact","layout","doSort","wasBatch","wasColumnResize","_inColumnResize","copyNodes","index","after","addNode","_updating","_orig","newY","i","prepareNode","resizing","_idSeq","count","nodeBoundFix","before","skipCacheUpdate","findCacheLayout","copy","cacheOneLayout","getDirtyNodes","verify","dirtyNodes","concat","_lastTried","some","restoreInitial","findEmptyPosition","nodeList","found","floor","box","triggerAddEvent","dup","skipCollision","_temporaryRemoved","_removeDOM","push","removeNode","removeDOM","triggerEvent","_isAboutToRemove","removeAll","_layouts","moveNodeCheck","changedPosConstrain","clonedNode","map","canMove","getRow","gridstackNode","willItFit","_willFitPos","cleanupNode","content","wasUndefinedPack","forceCollide","prevPos","needToMove","activeDrag","subGridDynamic","_isTemp","a1","a2","makeSubGrid","reduce","row","beginUpdate","endUpdate","save","saveElement","saveCB","len","wl","l","layoutsNodesChange","ratio","round","columnChanged","prevColumn","doCompact","cacheLayout","newNodes","cacheNodes","lastIndex","cacheNode","j","findIndex","splice","move","scale","clear","existing","n2","removeNodeFromLayoutCache","gridDefaults","alwaysShowResizeHandle","animate","auto","cellHeight","cellHeightThrottle","cellHeightUnit","draggable","handle","scroll","itemClass","margin","marginUnit","minRow","placeholderClass","placeholderText","removableOptions","accept","decline","resizable","handles","rtl","DDManager","isTouch","DocumentTouch","navigator","maxTouchPoints","msMaxTouchPoints","DDTouch","touches","preventDefault","changedTouches","simulatePointerMouseEvent","touchstart","touchHandled","touchmove","touchend","pointerLeaveTimeout","clearTimeout","wasDragging","dragElement","pointerdown","pointerType","releasePointerCapture","pointerId","pointerenter","pointerleave","DDResizableHandle","constructor","host","option","moving","_mouseDown","bind","_mouseMove","_mouseUp","_keyEvent","_init","prefix","userSelect","addEventListener","destroy","mouseDownEvent","removeEventListener","capture","passive","stopPropagation","_triggerEvent","engine","name","DDBaseImplement","_eventRegister","disabled","_disabled","on","callback","off","enable","disable","eventName","DDResizable","super","rectScale","_ui","containmentRect","newRect","originalRect","scrolled","temporalRect","size","_mouseOver","_mouseOut","_setupAutoHide","autoHide","_setupHandlers","_removeHandlers","updateOption","updateHandles","updateAutoHide","overResizeElement","handlers","split","trim","start","_resizeStart","stop","_resizeStop","_resizing","scrollY","startEvent","_setupHelper","_applyChange","ev","_getChange","resize","_cleanHelper","elOriginStyleVal","_originStyleProp","parentOriginStylePosition","dragTransform","oEvent","offsetX","offsetY","moveLeft","moveUp","indexOf","constrain","_constrainSize","oWidth","oHeight","maxWidth","maxWidthMoveLeft","MAX_SAFE_INTEGER","minWidth","maxHeight","maxHeightMoveUp","minHeight","containmentEl","scaleReciprocal","DDDraggable","handleName","dragEls","contains","subGrid","dragEl","forDestroy","dragTimeout","helper","mouseHandled","closest","cancel","dragging","dropElement","currentTarget","activeElement","blur","_callDrag","drag","ui","lastDrag","_dragFollow","pauseDrag","pause","isInteger","ddElement","ddDroppable","_createHelper","_setupHelperContainmentStyle","helperContainment","dragOffset","_getDragOffset","_setupHelperStyle","_origRotate","_removeHelperStyle","drop","gridstack","cancelDrag","setAnimation","rotate","offsetLeft","dragElementOriginStyle","originStyleProp","pointerEvents","willChange","transition","offset","xformOffsetX","xformOffsetY","targetOffset","DDDroppable","_mouseEnter","_mouseLeave","_setupAccept","_canDrop","calledByEnter","out","parentDrop","matches","DDElement","init","ddDraggable","ddResizable","setupDraggable","cleanDraggable","setupResizable","cleanResizable","setupDroppable","cleanDroppable","dd","_getDDElements","dEl","getAttribute","dragIn","droppable","_accept","isDroppable","isDraggable","isResizable","create","hosts","d","GridStack","options","elOrString","getGridElement","console","error","initAll","selector","grids","getGridElements","addGrid","children","load","addRemoveCB","class","registerEngine","engineClass","placeholder","_placeholder","placeholderChild","textContent","animationDelay","_gsEventHandler","_extraDragRow","rowAttr","_alwaysShowResizeHandle","resp","columnOpts","bk","breakpoints","columnWidth","columnMax","staticGrid","handleClass","_initMargin","checkDynamicColumn","_updateColumnVar","direction","parentGridItem","parentGridNode","_isAutoCellHeight","_setStaticClass","getColumn","cbNodes","_writePosAttr","_updateContainerHeight","getGridItems","_prepareElement","_setupRemoveDrop","_setupAcceptWidget","_updateResizeEvent","setProperty","addWidget","ELEMENT_NODE","makeWidget","createWidgetDivs","domAttr","_readAttr","cont","visibleObservable","IntersectionObserver","entry","isIntersecting","disconnect","renderCB","prepareDragDrop","observe","ops","nodeToAdd","saveContent","subGridTemplate","autoColumn","subGridOpts","newItem","newItemOpt","_removeDD","update","_autoColumn","_event","resizeToContentCheck","removeAsSubGrid","nodeThatRemoved","pGrid","removeWidget","saveGridOpt","itemContent","innerHTML","listOrOpt","marginBottom","marginTop","marginRight","marginLeft","origShow","items","addRemove","_ignoreLayoutsNodeChange","maxColumn","responseLayout","prevCB","removed","blank","noAnim","updateNodes","item","sub","_triggerRemoveEvent","_triggerAddEvent","_triggerChangeEvent","getCellHeight","forcePixel","fontSize","rows","parseInt","marginDiff","cellWidth","data","_widthOrContainer","forBreakpoint","breakpointForWindow","innerWidth","clientWidth","newColumn","oldColumn","isIgnoreChangeCB","offAll","setStatic","getFloat","getCellFromPixel","useDocRelative","containerPos","relativeLeft","relativeTop","rowHeight","resetIgnoreLayoutsNodeChange","noData","doAnimate","hasAnimationCSS","updateClass","recurse","updateOptions","acceptWidgets","disableDrag","enableMove","enableResize","m","changed","ddChanged","widthChanged","onResize","_writeAttr","updateCB","wasUpdating","resizeToContent","cell","resizeToContentParent","padding","itemH","wantedH","subRec","parentRec","child","firstElementChild","ceil","softMax","resizeToContentCBCheck","resizeToContentCB","relative","rot","pivotX","pivotY","getMargin","arguments","warn","elements","CustomEvent","Event","cssMinHeight","setAttribute","String","attrs","clearDefaultAttr","attr","prevWidth","_skipInitialResize","forceRemove","trackSize","resizeObserver","_sizeThrottle","ResizeObserver","margins","getDD","setupDragIn","dragInOptions","widgets","movable","doEnable","_isExternal","_itemRemoving","_initDD","removable","onDrag","transform","helperRect","transformOrigin","_onStartMoving","_dragOrResize","canAccept","_sidebarOrig","_leave","JSON","parse","offsetWidth","_gridstackNodeOrig","wasAdded","wasSidebar","origNode","oGrid","trashEl","force","onStartMoving","dragOrResize","onEndMoving","gridEl","_lastUiPosition","_prevYPix","colLeft","rowLeft","mLeft","mRight","mTop","mBottom","mHeight","mWidth","prev","extra","sidebarOrig","commit","Engine","GDRev"],"sourceRoot":""}